/*
 * This file contains documention imported directly from TCL and is therefor under TCL's license.
 * 
 * This software is copyrighted by the Regents of the University of
 * California, Sun Microsystems, Inc., Scriptics Corporation, ActiveState
 * Corporation and other parties.  The following terms apply to all files
 * associated with the software unless explicitly disclaimed in
 * individual files.
 * 
 * The authors hereby grant permission to use, copy, modify, distribute,
 * and license this software and its documentation for any purpose, provided
 * that existing copyright notices are retained in all copies and that this
 * notice is included verbatim in any distributions. No written agreement,
 * license, or royalty fee is required for any of the authorized uses.
 * Modifications to this software may be copyrighted by their authors
 * and need not follow the licensing terms described here, provided that
 * the new terms are clearly indicated on the first page of each file where
 * they apply.
 * 
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
 * FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 * ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
 * DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
 * IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
 * NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.

 * GOVERNMENT USE: If you are acquiring this software on behalf of the
 * U.S. government, the Government shall have only "Restricted Rights"
 * in the software and related documentation as defined in the Federal 
 * Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
 * are acquiring the software on behalf of the Department of Defense, the
 * software shall be classified as "Commercial Computer Software" and the
 * Government shall have only "Restricted Rights" as defined in Clause
 * 252.227-7014 (b) (3) of DFARs.  Notwithstanding the foregoing, the
 * authors grant the U.S. Government and others acting in its behalf
 * permission to use and distribute the software in accordance with the
 * terms specified in this license.

*/

package com.basicer.parchment.tclstrings;

import java.util.HashMap;

public class Documentation {
	
	static class TCLDoc {
		public String body;
		public String summary;
		public String name;
		TCLDoc(String name, String summary, String body) {
			this.name = name;
			this.body = body;
			this.summary = summary;
		}
	}
	
	public static String getBody(String in) {
		if ( docs == null ) makeDocs();
		if ( docs.get(in) == null ) return null;
		return docs.get(in).body;
	}
	
	public static String getSumary(String in) {
		if ( docs == null ) makeDocs();
		if ( docs.get(in) == null ) return null;
		return docs.get(in).summary;
	}
	
	static HashMap<String, TCLDoc> docs;
	
	public static void makeDocs()
	{
		docs = new HashMap<String, TCLDoc>();
		docs.put("after", new TCLDoc("after", "Execute a command after a time delay"," This command is used to delay execution of the program or to execute a command in background sometime in the future.  It has several forms, depending on the first argument to the command: \n\n  after ms Ms must be an integer giving a time in milliseconds. The command sleeps for ms milliseconds and then returns. While the command is sleeping the application does not respond to events. \n\nafter ms ?script script script ...? In this form the command returns immediately, but it arranges for a Tcl command to be executed ms milliseconds later as an event handler. The command will be executed exactly once, at the given time. The delayed command is formed by concatenating all the script arguments in the same fashion as the concat command. The command will be executed at global level (outside the context of any Tcl procedure). If an error occurs while executing the delayed command then  the background error will be reported by the command registered with interp bgerror. The after command returns an identifier that can be used to cancel the delayed command using after cancel. \n\nafter cancel id Cancels the execution of a delayed command that was previously scheduled. Id indicates which command should be canceled;  it must have been the return value from a previous after command. If the command given by id has already been executed then the after cancel command has no effect. \n\nafter cancel script script ... This command also cancels the execution of a delayed command. The script arguments are concatenated together with space separators (just as in the concat command). If there is a pending command that matches the string, it is canceled and will never be executed;  if no such command is currently pending then the after cancel command has no effect. \n\nafter idle script ?script script ...? Concatenates the script arguments together with space separators (just as in the concat command), and arranges for the resulting script to be evaluated later as an idle callback. The script will be run exactly once, the next time the event loop is entered and there are no events to process. The command returns an identifier that can be used to cancel the delayed command using after cancel. If an error occurs while executing the script then the background error will be reported by the command registered with interp bgerror. \n\nafter info ?id? This command returns information about existing event handlers. If no id argument is supplied, the command returns a list of the identifiers for all existing event handlers created by the after command for this interpreter. If id is supplied, it specifies an existing handler; id must have been the return value from some previous call to after and it must not have triggered yet or been canceled. In this case the command returns a list with two elements. The first element of the list is the script associated with id, and the second element is either idle or timer to indicate what kind of event handler it is. \n\n \n\n The after ms and after idle forms of the command assume that the application is event driven:  the delayed commands will not be executed unless the application enters the event loop. In applications that are not normally event-driven, such as tclsh, the event loop can be entered with the vwait and update commands. "));
		docs.put("load", new TCLDoc("load", "Load machine code and initialize new commands"," This command loads binary code from a file into the application\'s address space and calls an initialization procedure in the package to incorporate it into an interpreter.  fileName is the name of the file containing the code;  its exact form varies from system to system but on most systems it is a shared library, such as a .so file under Solaris or a DLL under Windows. packageName is the name of the package, and is used to compute the name of an initialization procedure. interp is the path name of the interpreter into which to load the package (see the interp manual entry for details); if interp is omitted, it defaults to the interpreter in which the load command was invoked. \n\n Once the file has been loaded into the application\'s address space, one of two initialization procedures will be invoked in the new code. Typically the initialization procedure will add new commands to a Tcl interpreter. The name of the initialization procedure is determined by packageName and whether or not the target interpreter is a safe one.  For normal interpreters the name of the initialization procedure will have the form pkg_Init, where pkg is the same as packageName except that the first letter is converted to upper case and all other letters are converted to lower case.  For example, if packageName is foo or FOo, the initialization procedure\'s name will be Foo_Init. \n\n If the target interpreter is a safe interpreter, then the name of the initialization procedure will be pkg_SafeInit instead of pkg_Init. The pkg_SafeInit function should be written carefully, so that it initializes the safe interpreter only with partial functionality provided by the package that is safe for use by untrusted code. For more information on Safe-Tcl, see the safe manual entry. \n\n The initialization procedure must match the following prototype: \n\n typedef int Tcl_PackageInitProc(         Tcl_Interp *interp); \n\n The interp argument identifies the interpreter in which the package is to be loaded.  The initialization procedure must return TCL_OK or TCL_ERROR to indicate whether or not it completed successfully;  in the event of an error it should set the interpreter\'s result to point to an error message.  The result of the load command will be the result returned by the initialization procedure. \n\n The actual loading of a file will only be done once for each fileName in an application.  If a given fileName is loaded into multiple interpreters, then the first load will load the code and call the initialization procedure;  subsequent loads will call the initialization procedure without loading the code again. For Tcl versions lower than 8.5, it is not possible to unload or reload a package. From version 8.5 however, the unload command allows the unloading of libraries loaded with load, for libraries that are aware of the Tcl\'s unloading mechanism. \n\n The load command also supports packages that are statically linked with the application, if those packages have been registered by calling the Tcl_StaticPackage procedure. If fileName is an empty string, then packageName must be specified. \n\n If packageName is omitted or specified as an empty string, Tcl tries to guess the name of the package. This may be done differently on different platforms. The default guess, which is used on most UNIX platforms, is to take the last element of fileName, strip off the first three characters if they are lib, and use any following alphabetic and underline characters as the module name. For example, the command load libxyz4.2.so uses the module name xyz and the command load bin/last.so {} uses the module name last. \n\n If fileName is an empty string, then packageName must be specified. The load command first searches for a statically loaded package (one that has been registered by calling the Tcl_StaticPackage procedure) by that name; if one is found, it is used. Otherwise, the load command searches for a dynamically loaded package by that name, and uses it if it is found.  If several different files have been loaded with different versions of the package, Tcl picks the file that was loaded first. \n\n If -global is specified preceding the filename, all symbols found in the shared library are exported for global use by other libraries. The option -lazy delays the actual loading of symbols until their first actual use. The options may be abbreviated. The option -- indicates the end of the options, and should be used if you wish to use a filename which starts with - and you provide a packageName to the load command. \n\n On platforms which do not support the -global or -lazy options, the options still exist but have no effect. Note that use of the -global or -lazy option may lead to crashes in your application later (in case of symbol conflicts resp. missing symbols), which cannot be detected during the load. So, only use this when you know what you are doing, you will not get a nice error message when something is wrong with the loaded library. "));
		docs.put("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", new TCLDoc("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", "standard library of Tcl procedures",""));
		docs.put("append", new TCLDoc("append", "Append to variable"," Append all of the value arguments to the current value of variable varName.  If varName does not exist, it is given a value equal to the concatenation of all the value arguments. The result of this command is the new value stored in variable varName. This command provides an efficient way to build up long variables incrementally. For example, &#8220;append a $b&#8221; is much more efficient than &#8220;set a $a$b&#8221; if $a is long. "));
		docs.put("eval", new TCLDoc("eval", "Evaluate a Tcl script"," Eval takes one or more arguments, which together comprise a Tcl script containing one or more commands. Eval concatenates all its arguments in the same fashion as the concat command, passes the concatenated string to the Tcl interpreter recursively, and returns the result of that evaluation (or any error generated by it). Note that the list command quotes sequences of words in such a way that they are not further expanded by the eval command. "));
		docs.put("lrange", new TCLDoc("lrange", "Return one or more adjacent elements from a list"," List must be a valid Tcl list.  This command will return a new list consisting of elements first through last, inclusive. The index values first and last are interpreted the same as index values for the command string index, supporting simple index arithmetic and indices relative to the end of the list. If first is less than zero, it is treated as if it were zero. If last is greater than or equal to the number of elements in the list, then it is treated as if it were end. If first is greater than last then an empty string is returned. Note: &#8220;lrange list first first&#8221; does not always produce the same result as &#8220;lindex list first&#8221; (although it often does for simple fields that are not enclosed in braces); it does, however, produce exactly the same results as &#8220;list [lindex list first]&#8221; "));
		docs.put("read", new TCLDoc("read", "Read from a channel"," In the first form, the read command reads all of the data from channelId up to the end of the file.  If the -nonewline switch is specified then the last character of the file is discarded if it is a newline.  In the second form, the extra argument specifies how many characters to read.  Exactly that many characters will be read and returned, unless there are fewer than numChars left in the file; in this case all the remaining characters are returned.  If the channel is configured to use a multi-byte encoding, then the number of characters read may not be the same as the number of bytes read. \n\n ChannelId must be an identifier for an open channel such as the Tcl standard input channel (stdin), the return value from an invocation of open or socket, or the result of a channel creation command provided by a Tcl extension. The channel must have been opened for input. \n\n If channelId is in nonblocking mode, the command may not read as many characters as requested: once all available input has been read, the command will return the data that is available rather than blocking for more input.  If the channel is configured to use a multi-byte encoding, then there may actually be some bytes remaining in the internal buffers that do not form a complete character.  These bytes will not be returned until a complete character is available or end-of-file is reached.  The -nonewline switch is ignored if the command returns before reaching the end of the file. \n\n Read translates end-of-line sequences in the input into newline characters according to the -translation option for the channel. See the fconfigure manual entry for a discussion on ways in which fconfigure will alter input. "));
		docs.put("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", new TCLDoc("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", "standard library of Tcl procedures",""));
		docs.put("apply", new TCLDoc("apply", "Apply an anonymous function"," The command apply applies the function func to the arguments arg1 arg2 ... and returns the result.  \n\n The function func is a two element list {args body} or a three element list {args body namespace} (as if the list command had been used).  The first element args specifies the formal arguments to func. The specification of the formal arguments args is shared with the proc command, and is described in detail in the corresponding manual page. \n\n The contents of body are executed by the Tcl interpreter after the local variables corresponding to the formal arguments are given the values of the actual parameters arg1 arg2 .... When body is being executed, variable names normally refer to local variables, which are created automatically when referenced and deleted when apply returns.  One local variable is automatically created for each of the function\'s arguments. Global variables can only be accessed by invoking the global command or the upvar command. Namespace variables can only be accessed by invoking the variable command or the upvar command. \n\n The invocation of apply adds a call frame to Tcl\'s evaluation stack (the stack of frames accessed via uplevel). The execution of body proceeds in this call frame, in the namespace given by namespace or in the global namespace if none was specified. If given, namespace is interpreted relative to the global namespace even if its name does not start with &#8220;::&#8221;. \n\n The semantics of apply can also be described by: \n\n proc apply {fun args} {     set len [llength $fun]     if {($len < 2) || ($len > 3)} {          error \"can\'t interpret \\\"$fun\\\" as anonymous function\"     }     lassign $fun argList body ns     set name ::$ns::[getGloballyUniqueName]     set body0 {          rename [lindex [info level 0] 0] {}     }     proc $name $argList ${body0}$body     set code [catch {uplevel 1 $name $args} res opt]     return -options $opt $res } "));
		docs.put("exec", new TCLDoc("exec", "Invoke subprocesses"," This command treats its arguments as the specification of one or more subprocesses to execute. The arguments take the form of a standard shell pipeline where each arg becomes one word of a command, and each distinct command becomes a subprocess. \n\n If the initial arguments to exec start with - then they are treated as command-line switches and are not part of the pipeline specification.  The following switches are currently supported: \n\n  -ignorestderr Stops the exec command from treating the output of messages to the pipeline\'s standard error channel as an error case. \n\n-keepnewline Retains a trailing newline in the pipeline\'s output. Normally a trailing newline will be deleted. \n\n-- Marks the end of switches.  The argument following this one will be treated as the first arg even if it starts with a -. \n\n \n\n If an arg (or pair of args) has one of the forms described below then it is used by exec to control the flow of input and output among the subprocess(es). Such arguments will not be passed to the subprocess(es).  In forms such as &#8220;& fileName Both standard output from the last command and standard error from all commands are redirected to the file named fileName, overwriting its previous contents. \n\n>> fileName Standard output from the last command is redirected to the file named fileName, appending to it rather than overwriting it. \n\n2>> fileName Standard error from all commands in the pipeline is redirected to the file named fileName, appending to it rather than overwriting it. \n\n>>& fileName Both standard output from the last command and standard error from all commands are redirected to the file named fileName, appending to it rather than overwriting it. \n\n>@ fileId FileId must be the identifier for an open file, such as the return value from a previous call to open. Standard output from the last command is redirected to fileId\'s file, which must have been opened for writing. \n\n2>@ fileId FileId must be the identifier for an open file, such as the return value from a previous call to open. Standard error from all commands in the pipeline is redirected to fileId\'s file. The file must have been opened for writing. \n\n2>@1  Standard error from all commands in the pipeline is redirected to the command result.  This operator is only valid at the end of the command pipeline. \n\n>&@ fileId FileId must be the identifier for an open file, such as the return value from a previous call to open. Both standard output from the last command and standard error from all commands are redirected to fileId\'s file. The file must have been opened for writing. \n\n \n\n If standard output has not been redirected then the exec command returns the standard output from the last command in the pipeline, unless &#8220;2>@1&#8221; was specified, in which case standard error is included as well. If any of the commands in the pipeline exit abnormally or are killed or suspended, then exec will return an error and the error message will include the pipeline\'s output followed by error messages describing the abnormal terminations; the -errorcode return option will contain additional information about the last abnormal termination encountered. If any of the commands writes to its standard error file and that standard error is not redirected and -ignorestderr is not specified, then exec will return an error;  the error message will include the pipeline\'s standard output, followed by messages about abnormal terminations (if any), followed by the standard error output. \n\n If the last character of the result or error message is a newline then that character is normally deleted from the result or error message. This is consistent with other Tcl return values, which do not normally end with newlines. However, if -keepnewline is specified then the trailing newline is retained. \n\n If standard input is not redirected with &#8220;"));
		docs.put("lrepeat", new TCLDoc("lrepeat", "Build a list by repeating elements"," The lrepeat command creates a list of size count * number of elements by repeating count times the sequence of elements element ....  count must be a non-negative integer, element can be any Tcl value.  Note that lrepeat 1 element ... is identical to list element .... "));
		docs.put("refchan", new TCLDoc("refchan", "command handler API of reflected channels"," The Tcl-level handler for a reflected channel has to be a command with subcommands (termed an ensemble, as it is a command such as that created by namespace ensemble create, though the implementation of handlers for reflected channel is not tied to namespace ensembles in any way; see EXAMPLE below for how to build an oo::class that supports the API). Note that cmdPrefix is whatever was specified in the call to chan create, and may consist of multiple arguments; this will be expanded to multiple words in place of the prefix. \n\n Of all the possible subcommands, the handler must support initialize, finalize, and watch. Support for the other subcommands is optional. MANDATORY SUBCOMMANDS  cmdPrefix initialize channelId mode An invocation of this subcommand will be the first call the cmdPrefix will receive for the specified new channelId. It is the responsibility of this subcommand to set up any internal data structures required to keep track of the channel and its state. \n\n The return value of the method has to be a list containing the names of all subcommands supported by the cmdPrefix. This also tells the Tcl core which version of the API for reflected channels is used by this command handler. \n\n Any error thrown by the method will abort the creation of the channel and no channel will be created. The thrown error will appear as error thrown by chan create. Any exception other than an error (e.g., break, etc.) is treated as (and converted to) an error. \n\n Note: If the creation of the channel was aborted due to failures here, then the finalize subcommand will not be called. \n\n The mode argument tells the handler whether the channel was opened for reading, writing, or both. It is a list containing any of the strings read or write. The list will always contain at least one element. \n\nThe subcommand must throw an error if the chosen mode is not supported by the cmdPrefix. \n\ncmdPrefix finalize channelId An invocation of this subcommand will be the last call the cmdPrefix will receive for the specified channelId. It will be generated just before the destruction of the data structures of the channel held by the Tcl core. The command handler must not access the channelId anymore in no way. Upon this subcommand being called, any internal resources allocated to this channel must be cleaned up. \n\n The return value of this subcommand is ignored. \n\n If the subcommand throws an error the command which caused its invocation (usually chan close) will appear to have thrown this error. Any exception beyond error (e.g., break, etc.) is treated as (and converted to) an error. \n\nThis subcommand is not invoked if the creation of the channel was aborted during initialize (See above). \n\ncmdPrefix watch channelId eventspec This subcommand notifies the cmdPrefix that the specified channelId is interested in the events listed in the eventspec. This argument is a list containing any of read and write. The list may be empty, which signals that the channel does not wish to be notified of any events. In that situation, the handler should disable event generation completely. \n\n Warning: Any return value of the subcommand is ignored. This includes all errors thrown by the subcommand, break, continue, and custom return codes. \n\nThis subcommand interacts with chan postevent. Trying to post an event which was not listed in the last call to watch will cause chan postevent to throw an error. \n\n OPTIONAL SUBCOMMANDS  cmdPrefix read channelId count This optional subcommand is called when the user requests data from the channel channelId. count specifies how many bytes have been requested. If the subcommand is not supported then it is not possible to read from the channel handled by the command. \n\n The return value of this subcommand is taken as the requested data bytes. If the returned data contains more bytes than requested, an error will be signaled and later thrown by the command which performed the read (usually gets or read). However, returning fewer bytes than requested is acceptable. \n\n Note that returning nothing (0 bytes) is a signal to the higher layers that EOF has been reached on the channel. To signal that the channel is out of data right now, but has not yet reached EOF, it is necessary to throw the error \"EAGAIN\", i.e. to either \n\n return -code error EAGAIN or error EAGAIN \n\n For extensibility any error whose value is a negative integer number will cause the higher layers to set the C-level variable \"errno\" to the absolute value of this number, signaling a system error. However, note that the exact mapping between these error numbers and their meanings is operating system dependent. \n\n For example, while on Linux both \n\n return -code error -11 and error -11 \n\n are equivalent to the examples above, using the more readable string \"EAGAIN\", this is not true for BSD, where the equivalent number is -35. \n\n The symbolic string however is the same across systems, and internally translated to the correct number. No other error value has such a mapping to a symbolic string. \n\nIf the subcommand throws any other error, the command which caused its invocation (usually gets, or read) will appear to have thrown this error. Any exception beyond error, (e.g., break, etc.) is treated as and converted to an error. \n\ncmdPrefix write channelId data This optional subcommand is called when the user writes data to the channel channelId. The data argument contains bytes, not characters. Any type of transformation (EOL, encoding) configured for the channel has already been applied at this point. If this subcommand is not supported then it is not possible to write to the channel handled by the command. \n\n The return value of the subcommand is taken as the number of bytes written by the channel. Anything non-numeric will cause an error to be signaled and later thrown by the command which performed the write. A negative value implies that the write failed. Returning a value greater than the number of bytes given to the handler, or zero, is forbidden and will cause the Tcl core to throw an error. \n\n To signal that the channel is not able to accept data for writing right now, it is necessary to throw the error \"EAGAIN\", i.e. to either \n\n return -code error EAGAIN or error EAGAIN \n\n For extensibility any error whose value is a negative integer number will cause the higher layers to set the C-level variable \"errno\" to the absolute value of this number, signaling a system error. However, note that the exact mapping between these error numbers and their meanings is operating system dependent. \n\n For example, while on Linux both \n\n return -code error -11 and error -11 \n\n are equivalent to the examples above, using the more readable string \"EAGAIN\", this is not true for BSD, where the equivalent number is -35. \n\n The symbolic string however is the same across systems, and internally translated to the correct number. No other error value has such a mapping to a symbolic string. \n\nIf the subcommand throws any other error the command which caused its invocation (usually puts) will appear to have thrown this error. Any exception beyond error (e.g., break, etc.) is treated as and converted to an error. \n\ncmdPrefix seek channelId offset base This optional subcommand is responsible for the handling of chan seek and chan tell requests on the channel channelId. If it is not supported then seeking will not be possible for the channel. \n\n The base argument is the same as the equivalent argument of the builtin chan seek, namely: \n\n  start Seeking is relative to the beginning of the channel. \n\ncurrent Seeking is relative to the current seek position. \n\nend Seeking is relative to the end of the channel. \n\n \n\n The offset is an integer number specifying the amount of bytes to seek forward or backward. A positive number should seek forward, and a negative number should seek backward. A channel may provide only limited seeking. For example sockets can seek forward, but not backward. \n\n The return value of the subcommand is taken as the (new) location of the channel, counted from the start. This has to be an integer number greater than or equal to zero. If the subcommand throws an error the command which caused its invocation (usually chan seek, or chan tell) will appear to have thrown this error. Any exception beyond error (e.g., break, etc.) is treated as and converted to an error. \n\nThe offset/base combination of 0/current signals a chan tell request, i.e., seek nothing relative to the current location, making the new location identical to the current one, which is then returned. \n\ncmdPrefix configure channelId option value This optional subcommand is for setting the type-specific options of channel channelId. The option argument indicates the option to be written, and the value argument indicates the value to set the option to. \n\n This subcommand will never try to update more than one option at a time; that is behavior implemented in the Tcl channel core. \n\n The return value of the subcommand is ignored. \n\nIf the subcommand throws an error the command which performed the (re)configuration or query (usually fconfigure or chan configure) will appear to have thrown this error. Any exception beyond error (e.g., break, etc.) is treated as and converted to an error. \n\ncmdPrefix cget channelId option This optional subcommand is used when reading a single type-specific option of channel channelId. If this subcommand is supported then the subcommand cgetall must be supported as well. \n\n The subcommand should return the value of the specified option. \n\nIf the subcommand throws an error, the command which performed the (re)configuration or query (usually fconfigure or chan configure) will appear to have thrown this error. Any exception beyond error (e.g., break, etc.) is treated as and converted to an error. \n\ncmdPrefix cgetall channelId This optional subcommand is used for reading all type-specific options of channel channelId. If this subcommand is supported then the subcommand cget has to be supported as well. \n\n The subcommand should return a list of all options and their values. This list must have an even number of elements. \n\nIf the subcommand throws an error the command which performed the (re)configuration or query (usually fconfigure or chan configure) will appear to have thrown this error. Any exception beyond error (e.g., break, etc.) is treated as and converted to an error. \n\ncmdPrefix blocking channelId mode This optional subcommand handles changes to the blocking mode of the channel channelId. The mode is a boolean flag. A true value means that the channel has to be set to blocking, and a false value means that the channel should be non-blocking. \n\n The return value of the subcommand is ignored. \n\nIf the subcommand throws an error the command which caused its invocation (usually fconfigure or chan configure) will appear to have thrown this error. Any exception beyond error (e.g., break, etc.) is treated as and converted to an error. \n\n "));
		docs.put("exit", new TCLDoc("exit", "End the application"," Terminate the process, returning returnCode to the system as the exit status. If returnCode is not specified then it defaults to 0. "));
		docs.put("lreplace", new TCLDoc("lreplace", "Replace elements in a list with new elements"," lreplace returns a new list formed by replacing one or more elements of list with the element arguments. first and last are index values specifying the first and last elements of the range to replace. The index values first and last are interpreted the same as index values for the command string index, supporting simple index arithmetic and indices relative to the end of the list. 0 refers to the first element of the list, and end refers to the last element of the list. If list is empty, then first and last are ignored. \n\n If first is less than zero, it is considered to refer to before the first element of the list.  For non-empty lists, the element indicated by first must exist or first must indicate before the start of the list. \n\n If last is less than first, then any specified elements will be inserted into the list at the point specified by first with no elements being deleted. \n\n The element arguments specify zero or more new arguments to be added to the list in place of those that were deleted. Each element argument will become a separate element of the list.  If no element arguments are specified, then the elements between first and last are simply deleted.  If list is empty, any element arguments are added to the end of the list. "));
		docs.put("regexp", new TCLDoc("regexp", "Match a regular expression against a string"," Determines whether the regular expression exp matches part or all of string and returns 1 if it does, 0 if it does not, unless -inline is specified (see below). (Regular expression matching is described in the re_syntax reference page.) \n\n If additional arguments are specified after string then they are treated as the names of variables in which to return information about which part(s) of string matched exp. MatchVar will be set to the range of string that matched all of exp.  The first subMatchVar will contain the characters in string that matched the leftmost parenthesized subexpression within exp, the next subMatchVar will contain the characters that matched the next parenthesized subexpression to the right in exp, and so on. \n\n If the initial arguments to regexp start with - then they are treated as switches.  The following switches are currently supported: \n\n  -about Instead of attempting to match the regular expression, returns a list containing information about the regular expression.  The first element of the list is a subexpression count.  The second element is a list of property names that describe various attributes of the regular expression. This switch is primarily intended for debugging purposes. \n\n-expanded Enables use of the expanded regular expression syntax where whitespace and comments are ignored.  This is the same as specifying the (?x) embedded option (see the re_syntax manual page). \n\n-indices Changes what is stored in the subMatchVars.  Instead of storing the matching characters from string, each variable will contain a list of two decimal strings giving the indices in string of the first and last characters in the matching range of characters. \n\n-line Enables newline-sensitive matching.  By default, newline is a completely ordinary character with no special meaning.  With this flag, &#8220;[^&#8221; bracket expressions and &#8220;.&#8221; never match newline, &#8220;^&#8221; matches an empty string after any newline in addition to its normal function, and &#8220;$&#8221; matches an empty string before any newline in addition to its normal function.  This flag is equivalent to specifying both -linestop and -lineanchor, or the (?n) embedded option (see the re_syntax manual page). \n\n-linestop Changes the behavior of &#8220;[^&#8221; bracket expressions and &#8220;.&#8221; so that they stop at newlines.  This is the same as specifying the (?p) embedded option (see the re_syntax manual page). \n\n-lineanchor Changes the behavior of &#8220;^&#8221; and &#8220;$&#8221; (the &#8220;anchors&#8221;) so they match the beginning and end of a line respectively.  This is the same as specifying the (?w) embedded option (see the re_syntax manual page). \n\n-nocase Causes upper-case characters in string to be treated as lower case during the matching process. \n\n-all Causes the regular expression to be matched as many times as possible in the string, returning the total number of matches found.  If this is specified with match variables, they will contain information for the last match only. \n\n-inline Causes the command to return, as a list, the data that would otherwise be placed in match variables.  When using -inline, match variables may not be specified.  If used with -all, the list will be concatenated at each iteration, such that a flat list is always returned.  For each match iteration, the command will append the overall match data, plus one element for each subexpression in the regular expression.  Examples are: \n\n regexp -inline -- {\\w(\\w)} \" inlined \"       &#8594; in n regexp -all -inline -- {\\w(\\w)} \" inlined \"       &#8594; in n li i ne e \n\n-start index Specifies a character index offset into the string to start matching the regular expression at.   The index value is interpreted in the same manner as the index argument to string index. When using this switch, &#8220;^&#8221; will not match the beginning of the line, and \\A will still match the start of the string at index.  If -indices is specified, the indices will be indexed starting from the absolute beginning of the input string. index will be constrained to the bounds of the input string. \n\n-- Marks the end of switches.  The argument following this one will be treated as exp even if it starts with a -. \n\n \n\n If there are more subMatchVars than parenthesized subexpressions within exp, or if a particular subexpression in exp does not match the string (e.g. because it was in a portion of the expression that was not matched), then the corresponding subMatchVar will be set to &#8220;-1 -1&#8221; if -indices has been specified or to an empty string otherwise. "));
		docs.put("expr", new TCLDoc("expr", "Evaluate an expression"," Concatenates args (adding separator spaces between them), evaluates the result as a Tcl expression, and returns the value. The operators permitted in Tcl expressions include a subset of the operators permitted in C expressions.  For those operators common to both Tcl and C, Tcl applies the same meaning and precedence as the corresponding C operators. Expressions almost always yield numeric results (integer or floating-point values). For example, the expression \n\n expr 8.2 + 6 \n\n evaluates to 14.2. Tcl expressions differ from C expressions in the way that operands are specified.  Also, Tcl expressions support non-numeric operands and string comparisons, as well as some additional operators not found in C. OPERANDS A Tcl expression consists of a combination of operands, operators, parentheses and commas. White space may be used between the operands and operators and parentheses (or commas); it is ignored by the expression\'s instructions. Where possible, operands are interpreted as integer values. Integer values may be specified in decimal (the normal case), in binary (if the first two characters of the operand are 0b), in octal (if the first two characters of the operand are 0o), or in hexadecimal (if the first two characters of the operand are 0x).  For compatibility with older Tcl releases, an octal integer value is also indicated simply when the first character of the operand is 0, whether or not the second character is also o. If an operand does not have one of the integer formats given above, then it is treated as a floating-point number if that is possible.  Floating-point numbers may be specified in any of several common formats making use of the decimal digits, the decimal point ., the characters e or E indicating scientific notation, and the sign characters + or -.  For example, all of the following are valid floating-point numbers:  2.1, 3., 6e4, 7.91e+16. Also recognized as floating point values are the strings Inf and NaN making use of any case for each character. If no numeric interpretation is possible (note that all literal operands that are not numeric or boolean must be quoted with either braces or with double quotes), then an operand is left as a string (and only a limited set of operators may be applied to it). \n\n Operands may be specified in any of the following ways: \n\n   As a numeric value, either integer or floating-point. \n\n As a boolean value, using any form understood by string is boolean. \n\n As a Tcl variable, using standard $ notation. The variable\'s value will be used as the operand. \n\n As a string enclosed in double-quotes. The expression parser will perform backslash, variable, and command substitutions on the information between the quotes, and use the resulting value as the operand \n\n As a string enclosed in braces. The characters between the open brace and matching close brace will be used as the operand without any substitutions. \n\n As a Tcl command enclosed in brackets. The command will be executed and its result will be used as the operand. \n\n As a mathematical function whose arguments have any of the above forms for operands, such as sin($x).  See MATH FUNCTIONS below for a discussion of how mathematical functions are handled. \n\n \n\n Where the above substitutions occur (e.g. inside quoted strings), they are performed by the expression\'s instructions. However, the command parser may already have performed one round of substitution before the expression processor was called. As discussed below, it is usually best to enclose expressions in braces to prevent the command parser from performing substitutions on the contents. \n\n For some examples of simple expressions, suppose the variable a has the value 3 and the variable b has the value 6. Then the command on the left side of each of the lines below will produce the value on the right side of the line: \n\n expr 3.1 + $a	6.1 expr 2 + \"$a.$b\"	5.6 expr 4*[llength \"6 2\"]	8 expr {{word one} < \"word $a\"}	0 OPERATORS The valid operators (most of which are also available as commands in the tcl::mathop namespace; see the mathop(n) manual page for details) are listed below, grouped in decreasing order of precedence: \n\n  -  +  ~  ! Unary minus, unary plus, bit-wise NOT, logical NOT.  None of these operators may be applied to string operands, and bit-wise NOT may be applied only to integers. \n\n** Exponentiation.  Valid for any numeric operands. \n\n*  /  % Multiply, divide, remainder.  None of these operators may be applied to string operands, and remainder may be applied only to integers. The remainder will always have the same sign as the divisor and an absolute value smaller than the absolute value of the divisor. \n\n When applied to integers, the division and remainder operators can be considered to partition the number line into a sequence of equal-sized adjacent non-overlapping pieces where each piece is the size of the divisor; the division result identifies which piece the divisor lay within, and the remainder result identifies where within that piece the divisor lay. A consequence of this is that the result of &#8220;-57 / 10&#8221; is always -6, and the result of &#8220;-57 % 10&#8221; is always 3. \n\n+  - Add and subtract.  Valid for any numeric operands. \n\n> Left and right shift.  Valid for integer operands only. A right shift always propagates the sign bit. \n\n<  >  = Boolean less, greater, less than or equal, and greater than or equal. Each operator produces 1 if the condition is true, 0 otherwise. These operators may be applied to strings as well as numeric operands, in which case string comparison is used. \n\n==  != Boolean equal and not equal.  Each operator produces a zero/one result. Valid for all operand types. \n\neq  ne Boolean string equal and string not equal.  Each operator produces a zero/one result.  The operand types are interpreted only as strings. \n\nin  ni List containment and negated list containment.  Each operator produces a zero/one result and treats its first argument as a string and its second argument as a Tcl list.  The in operator indicates whether the first argument is a member of the second argument list; the ni operator inverts the sense of the result. \n\n& Bit-wise AND.  Valid for integer operands only. \n\n^ Bit-wise exclusive OR.  Valid for integer operands only. \n\n| Bit-wise OR.  Valid for integer operands only. \n\n&& Logical AND.  Produces a 1 result if both operands are non-zero, 0 otherwise. Valid for boolean and numeric (integers or floating-point) operands only. \n\n|| Logical OR.  Produces a 0 result if both operands are zero, 1 otherwise. Valid for boolean and numeric (integers or floating-point) operands only. \n\nx?y:z If-then-else, as in C.  If x evaluates to non-zero, then the result is the value of y. Otherwise the result is the value of z. The x operand must have a boolean or numeric value. \n\n \n\n See the C manual for more details on the results produced by each operator. The exponentiation operator promotes types like the multiply and divide operators, and produces a result that is the same as the output of the pow function (after any type conversions.) All of the binary operators but exponentiation group left-to-right within the same precedence level; exponentiation groups right-to-left.  For example, the command \n\n expr {4*2 < 7} \n\n returns 0, while \n\n expr {2**3**2} \n\n returns 512. \n\n The &&, ||, and ?: operators have &#8220;lazy evaluation&#8221;, just as in C, which means that operands are not evaluated if they are not needed to determine the outcome.  For example, in the command \n\n expr {$v ? [a] : [b]} \n\n only one of &#8220;[a]&#8221; or &#8220;[b]&#8221; will actually be evaluated, depending on the value of $v.  Note, however, that this is only true if the entire expression is enclosed in braces;  otherwise the Tcl parser will evaluate both &#8220;[a]&#8221; and &#8220;[b]&#8221; before invoking the expr command. MATH FUNCTIONS When the expression parser encounters a mathematical function such as sin($x), it replaces it with a call to an ordinary Tcl function in the tcl::mathfunc namespace.  The processing of an expression such as: \n\n expr {sin($x+$y)} \n\n is the same in every way as the processing of: \n\n expr {[tcl::mathfunc::sin [expr {$x+$y}]]} \n\n which in turn is the same as the processing of: \n\n tcl::mathfunc::sin [expr {$x+$y}] \n\n The executor will search for tcl::mathfunc::sin using the usual rules for resolving functions in namespaces. Either ::tcl::mathfunc::sin or [namespace current]::tcl::mathfunc::sin will satisfy the request, and others may as well (depending on the current namespace path setting). \n\n Some mathematical functions have several arguments, separated by commas like in C. Thus: \n\n expr {hypot($x,$y)} \n\n ends up as \n\n tcl::mathfunc::hypot $x $y \n\n See the mathfunc(n) manual page for the math functions that are available by default. TYPES, OVERFLOW, AND PRECISION All internal computations involving integers are done calling on the LibTomMath multiple precision integer library as required so that all integer calculations are performed exactly.  Note that in Tcl releases prior to 8.5, integer calculations were performed with one of the C types long int or Tcl_WideInt, causing implicit range truncation in those calculations where values overflowed the range of those types. Any code that relied on these implicit truncations will need to explicitly add int() or wide() function calls to expressions at the points where such truncation is required to take place. \n\n All internal computations involving floating-point are done with the C type double. When converting a string to floating-point, exponent overflow is detected and results in the double value of Inf or -Inf as appropriate.  Floating-point overflow and underflow are detected to the degree supported by the hardware, which is generally pretty reliable. \n\n Conversion among internal representations for integer, floating-point, and string operands is done automatically as needed. For arithmetic computations, integers are used until some floating-point number is introduced, after which floating-point is used. For example, \n\n expr {5 / 4} \n\n returns 1, while \n\n expr {5 / 4.0} expr {5 / ( [string length \"abcd\"] + 0.0 )} \n\n both return 1.25. Floating-point values are always returned with a &#8220;.&#8221; or an &#8220;e&#8221; so that they will not look like integer values.  For example, \n\n expr {20.0/5.0} \n\n returns 4.0, not 4. STRING OPERATIONS String values may be used as operands of the comparison operators, although the expression evaluator tries to do comparisons as integer or floating-point when it can, i.e., when all arguments to the operator allow numeric interpretations, except in the case of the eq and ne operators. If one of the operands of a comparison is a string and the other has a numeric value, a canonical string representation of the numeric operand value is generated to compare with the string operand. Canonical string representation for integer values is a decimal string format.  Canonical string representation for floating-point values is that produced by the %g format specifier of Tcl\'s format command.  For example, the commands \n\n expr {\"0x03\" > \"2\"} expr {\"0y\" > \"0x12\"} \n\n both return 1.  The first comparison is done using integer comparison, and the second is done using string comparison. Because of Tcl\'s tendency to treat values as numbers whenever possible, it is not generally a good idea to use operators like == when you really want string comparison and the values of the operands could be arbitrary;  it is better in these cases to use the eq or ne operators, or the string command instead. "));
		docs.put("lreverse", new TCLDoc("lreverse", "Reverse the order of a list"," The lreverse command returns a list that has the same elements as its input list, list, except with the elements in the reverse order. "));
		docs.put("registry", new TCLDoc("registry", "Manipulate the Windows registry"," The registry package provides a general set of operations for manipulating the Windows registry.  The package implements the registry Tcl command.  This command is only supported on the Windows platform.  Warning: this command should be used with caution as a corrupted registry can leave your system in an unusable state. \n\n KeyName is the name of a registry key.  Registry keys must be one of the following forms:  \n\n \\\\hostname\\rootname\\keypath \n\n rootname\\keypath \n\n rootname  \n\n Hostname specifies the name of any valid Windows host that exports its registry.  The rootname component must be one of HKEY_LOCAL_MACHINE, HKEY_USERS, HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_CURRENT_CONFIG, HKEY_PERFORMANCE_DATA, or HKEY_DYN_DATA.  The keypath can be one or more registry key names separated by backslash (\\) characters. \n\n The optional -mode argument indicates which registry to work with; when it is -32bit the 32-bit registry will be used, and when it is -64bit the 64-bit registry will be used. If this argument is omitted, the system\'s default registry will be the subject of the requested operation. \n\n Option indicates what to do with the registry key name.  Any unique abbreviation for option is acceptable.  The valid options are: \n\n  registry broadcast keyName ?-timeout milliseconds? Sends a broadcast message to the system and running programs to notify them of certain updates.  This is necessary to propagate changes to key registry keys like Environment.  The timeout specifies the amount of time, in milliseconds, to wait for applications to respond to the broadcast message. It defaults to 3000.  The following example demonstrates how to add a path to the global Environment and notify applications of the change without requiring a logoff/logon step (assumes admin privileges): \n\n set regPath [join {     HKEY_LOCAL_MACHINE     SYSTEM     CurrentControlSet     Control     {Session Manager}     Environment } \"\\\\\"] set curPath [registry get $regPath \"Path\"] registry set $regPath \"Path\" \"$curPath;$addPath\" registry broadcast \"Environment\" \n\nregistry delete keyName ?valueName? If the optional valueName argument is present, the specified value under keyName will be deleted from the registry.  If the optional valueName is omitted, the specified key and any subkeys or values beneath it in the registry hierarchy will be deleted.  If the key could not be deleted then an error is generated.  If the key did not exist, the command has no effect. \n\nregistry get keyName valueName Returns the data associated with the value valueName under the key keyName.  If either the key or the value does not exist, then an error is generated.  For more details on the format of the returned data, see SUPPORTED TYPES, below. \n\nregistry keys keyName ?pattern? If pattern is not specified, returns a list of names of all the subkeys of keyName.  If pattern is specified, only those names matching pattern are returned.  Matching is determined using the same rules as for string match.  If the specified keyName does not exist, then an error is generated. \n\nregistry set keyName ?valueName data ?type?? If valueName is not specified, creates the key keyName if it does not already exist.  If valueName is specified, creates the key keyName and value valueName if necessary.  The contents of valueName are set to data with the type indicated by type.  If type is not specified, the type sz is assumed.  For more details on the data and type arguments, see SUPPORTED TYPES below. \n\nregistry type keyName valueName Returns the type of the value valueName in the key keyName.  For more information on the possible types, see SUPPORTED TYPES, below. \n\nregistry values keyName ?pattern? If pattern is not specified, returns a list of names of all the values of keyName.  If pattern is specified, only those names matching pattern are returned.  Matching is determined using the same rules as for string match. \n\n "));
		docs.put("fblocked", new TCLDoc("fblocked", "Test whether the last input operation exhausted all available input"," The fblocked command returns 1 if the most recent input operation on channelId returned less information than requested because all available input was exhausted. For example, if gets is invoked when there are only three characters available for input and no end-of-line sequence, gets returns an empty string and a subsequent call to fblocked will return 1. \n\n ChannelId must be an identifier for an open channel such as a Tcl standard channel (stdin, stdout, or stderr), the return value from an invocation of open or socket, or the result of a channel creation command provided by a Tcl extension. "));
		docs.put("lsearch", new TCLDoc("lsearch", "See if a list contains a particular element"," This command searches the elements of list to see if one of them matches pattern.  If so, the command returns the index of the first matching element (unless the options -all or -inline are specified.) If not, the command returns -1.  The option arguments indicates how the elements of the list are to be matched against pattern and must have one of the values below: MATCHING STYLE OPTIONS If all matching style options are omitted, the default matching style is -glob.  If more than one matching style is specified, the last matching style given takes precedence. \n\n  -exact Pattern is a literal string that is compared for exact equality against each list element. \n\n-glob Pattern is a glob-style pattern which is matched against each list element using the same rules as the string match command. \n\n-regexp Pattern is treated as a regular expression and matched against each list element using the rules described in the re_syntax reference page. \n\n-sorted The list elements are in sorted order.  If this option is specified, lsearch will use a more efficient searching algorithm to search list.  If no other options are specified, list is assumed to be sorted in increasing order, and to contain ASCII strings.  This option is mutually exclusive with -glob and -regexp, and is treated exactly like -exact when either -all or -not are specified. \n\n GENERAL MODIFIER OPTIONS These options may be given with all matching styles. \n\n  -all Changes the result to be the list of all matching indices (or all matching values if -inline is specified as well.) If indices are returned, the indices will be in numeric order. If values are returned, the order of the values will be the order of those values within the input list. \n\n-inline The matching value is returned instead of its index (or an empty string if no value matches.)  If -all is also specified, then the result of the command is the list of all values that matched. \n\n-not This negates the sense of the match, returning the index of the first non-matching value in the list. \n\n-start index The list is searched starting at position index. The interpretation of the index value is the same as for the command string index, supporting simple index arithmetic and indices relative to the end of the list. \n\n CONTENTS DESCRIPTION OPTIONS These options describe how to interpret the items in the list being searched.  They are only meaningful when used with the -exact and -sorted options.  If more than one is specified, the last one takes precedence.  The default is -ascii. \n\n  -ascii The list elements are to be examined as Unicode strings (the name is for backward-compatibility reasons.) \n\n-dictionary The list elements are to be compared using dictionary-style comparisons (see lsort for a fuller description). Note that this only makes a meaningful difference from the -ascii option when the -sorted option is given, because values are only dictionary-equal when exactly equal. \n\n-integer The list elements are to be compared as integers. \n\n-nocase Causes comparisons to be handled in a case-insensitive manner.  Has no effect if combined with the -dictionary, -integer, or  -real options. \n\n-real The list elements are to be compared as floating-point values. \n\n SORTED LIST OPTIONS These options (only meaningful with the -sorted option) specify how the list is sorted.  If more than one is given, the last one takes precedence.  The default option is -increasing. \n\n  -decreasing The list elements are sorted in decreasing order.  This option is only meaningful when used with -sorted. \n\n-increasing The list elements are sorted in increasing order.  This option is only meaningful when used with -sorted. \n\n-bisect Inexact search when the list elements are in sorted order. For an increasing list the last index where the element is less than or equal to the pattern is returned. For a decreasing list the last index where the element is greater than or equal to the pattern is returned. If the pattern is before the first element or the list is empty, -1 is returned. This option implies -sorted and cannot be used with either -all or -not. \n\n NESTED LIST OPTIONS These options are used to search lists of lists.  They may be used with any other options. \n\n  -index indexList This option is designed for use when searching within nested lists. The indexList argument gives a path of indices (much as might be used with the lindex or lset commands) within each element to allow the location of the term being matched against. \n\n-subindices If this option is given, the index result from this command (or every index result when -all is also specified) will be a complete path (suitable for use with lindex or lset) within the overall list to the term found.  This option has no effect unless the -index is also specified, and is just a convenience short-cut. \n\n "));
		docs.put("regsub", new TCLDoc("regsub", "Perform substitutions based on regular expression pattern matching"," This command matches the regular expression exp against string, and either copies string to the variable whose name is given by varName or returns string if varName is not present. (Regular expression matching is described in the re_syntax reference page.) If there is a match, then while copying string to varName (or to the result of this command if varName is not present) the portion of string that matched exp is replaced with subSpec. If subSpec contains a &#8220;&&#8221; or &#8220;\\0&#8221;, then it is replaced in the substitution with the portion of string that matched exp. If subSpec contains a &#8220;\\n&#8221;, where n is a digit between 1 and 9, then it is replaced in the substitution with the portion of string that matched the n\'th parenthesized subexpression of exp. Additional backslashes may be used in subSpec to prevent special interpretation of &#8220;&&#8221;, &#8220;\\0&#8221;, &#8220;\\n&#8221; and backslashes. The use of backslashes in subSpec tends to interact badly with the Tcl parser\'s use of backslashes, so it is generally safest to enclose subSpec in braces if it includes backslashes. \n\n If the initial arguments to regsub start with - then they are treated as switches.  The following switches are currently supported: \n\n  -all All ranges in string that match exp are found and substitution is performed for each of these ranges. Without this switch only the first matching range is found and substituted. If -all is specified, then &#8220;&&#8221; and &#8220;\\n&#8221; sequences are handled for each substitution using the information from the corresponding match. \n\n-expanded Enables use of the expanded regular expression syntax where whitespace and comments are ignored.  This is the same as specifying the (?x) embedded option (see the re_syntax manual page). \n\n-line Enables newline-sensitive matching.  By default, newline is a completely ordinary character with no special meaning.  With this flag, &#8220;[^&#8221; bracket expressions and &#8220;.&#8221; never match newline, &#8220;^&#8221; matches an empty string after any newline in addition to its normal function, and &#8220;$&#8221; matches an empty string before any newline in addition to its normal function.  This flag is equivalent to specifying both -linestop and -lineanchor, or the (?n) embedded option (see the re_syntax manual page). \n\n-linestop Changes the behavior of &#8220;[^&#8221; bracket expressions and &#8220;.&#8221; so that they stop at newlines.  This is the same as specifying the (?p) embedded option (see the re_syntax manual page). \n\n-lineanchor Changes the behavior of &#8220;^&#8221; and &#8220;$&#8221; (the &#8220;anchors&#8221;) so they match the beginning and end of a line respectively.  This is the same as specifying the (?w) embedded option (see the re_syntax manual page). \n\n-nocase Upper-case characters in string will be converted to lower-case before matching against exp;  however, substitutions specified by subSpec use the original unconverted form of string. \n\n-start index Specifies a character index offset into the string to start matching the regular expression at.   The index value is interpreted in the same manner as the index argument to string index. When using this switch, &#8220;^&#8221; will not match the beginning of the line, and \\A will still match the start of the string at index. index will be constrained to the bounds of the input string. \n\n-- Marks the end of switches.  The argument following this one will be treated as exp even if it starts with a -. \n\n \n\n If varName is supplied, the command returns a count of the number of matching ranges that were found and replaced, otherwise the string after replacement is returned. See the manual entry for regexp for details on the interpretation of regular expressions. "));
		docs.put("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", new TCLDoc("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", "standard library of Tcl procedures",""));
		docs.put("array", new TCLDoc("array", "Manipulate array variables"," This command performs one of several operations on the variable given by arrayName. Unless otherwise specified for individual commands below, arrayName must be the name of an existing array variable. The option argument determines what action is carried out by the command. The legal options (which may be abbreviated) are: \n\n  array anymore arrayName searchId Returns 1 if there are any more elements left to be processed in an array search, 0 if all elements have already been returned. SearchId indicates which search on arrayName to check, and must have been the return value from a previous invocation of array startsearch. This option is particularly useful if an array has an element with an empty name, since the return value from array nextelement will not indicate whether the search has been completed. \n\narray donesearch arrayName searchId This command terminates an array search and destroys all the state associated with that search.  SearchId indicates which search on arrayName to destroy, and must have been the return value from a previous invocation of array startsearch.  Returns an empty string. \n\narray exists arrayName Returns 1 if arrayName is an array variable, 0 if there is no variable by that name or if it is a scalar variable. \n\narray get arrayName ?pattern? Returns a list containing pairs of elements.  The first element in each pair is the name of an element in arrayName and the second element of each pair is the value of the array element.  The order of the pairs is undefined. If pattern is not specified, then all of the elements of the array are included in the result. If pattern is specified, then only those elements whose names match pattern (using the matching rules of string match) are included. If arrayName is not the name of an array variable, or if the array contains no elements, then an empty list is returned. If traces on the array modify the list of elements, the elements returned are those that exist both before and after the call to array get. \n\narray names arrayName ?mode? ?pattern? Returns a list containing the names of all of the elements in the array that match pattern.  Mode may be one of -exact, -glob, or -regexp.  If specified, mode designates which matching rules to use to match pattern against the names of the elements in the array.  If not specified, mode defaults to -glob.  See the documentation for string match for information on glob style matching, and the documentation for regexp for information on regexp matching. If pattern is omitted then the command returns all of the element names in the array.  If there are no (matching) elements in the array, or if arrayName is not the name of an array variable, then an empty string is returned. \n\narray nextelement arrayName searchId Returns the name of the next element in arrayName, or an empty string if all elements of arrayName have already been returned in this search.  The searchId argument identifies the search, and must have been the return value of an array startsearch command. Warning:  if elements are added to or deleted from the array, then all searches are automatically terminated just as if array donesearch had been invoked; this will cause array nextelement operations to fail for those searches. \n\narray set arrayName list Sets the values of one or more elements in arrayName. list must have a form like that returned by array get, consisting of an even number of elements. Each odd-numbered element in list is treated as an element name within arrayName, and the following element in list is used as a new value for that array element. If the variable arrayName does not already exist and list is empty, arrayName is created with an empty array value. \n\narray size arrayName Returns a decimal string giving the number of elements in the array. If arrayName is not the name of an array then 0 is returned. \n\narray startsearch arrayName This command initializes an element-by-element search through the array given by arrayName, such that invocations of the array nextelement command will return the names of the individual elements in the array. When the search has been completed, the array donesearch command should be invoked. The return value is a search identifier that must be used in array nextelement and array donesearch commands; it allows multiple searches to be underway simultaneously for the same array. It is currently more efficient and easier to use either the array get or array names, together with foreach, to iterate over all but very large arrays.  See the examples below for how to do this. \n\narray statistics arrayName Returns statistics about the distribution of data within the hashtable that represents the array.  This information includes the number of entries in the table, the number of buckets, and the utilization of the buckets. \n\narray unset arrayName ?pattern? Unsets all of the elements in the array that match pattern (using the matching rules of string match).  If arrayName is not the name of an array variable or there are no matching elements in the array, no error will be raised.  If pattern is omitted and arrayName is an array variable, then the command unsets the entire array. The command always returns an empty string. \n\n "));
		docs.put("fconfigure", new TCLDoc("fconfigure", "Set and get options on a channel"," The fconfigure command sets and retrieves options for channels. \n\n ChannelId identifies the channel for which to set or query an option and must refer to an open channel such as a Tcl standard channel (stdin, stdout, or stderr), the return value from an invocation of open or socket, or the result of a channel creation command provided by a Tcl extension. \n\n If no name or value arguments are supplied, the command returns a list containing alternating option names and values for the channel. If name is supplied but no value then the command returns the current value of the given option. If one or more pairs of name and value are supplied, the command sets each of the named options to the corresponding value; in this case the return value is an empty string. \n\n The options described below are supported for all channels. In addition, each channel type may add options that only it supports. See the manual entry for the command that creates each type of channels for the options that that specific type of channel supports. For example, see the manual entry for the socket command for additional options for sockets, and the open command for additional options for serial devices. \n\n  -blocking boolean The -blocking option determines whether I/O operations on the channel can cause the process to block indefinitely. The value of the option must be a proper boolean value. Channels are normally in blocking mode;  if a channel is placed into nonblocking mode it will affect the operation of the gets, read, puts, flush, and close commands by allowing them to operate asynchronously; see the documentation for those commands for details. For nonblocking mode to work correctly, the application must be using the Tcl event loop (e.g. by calling Tcl_DoOneEvent or invoking the vwait command). \n\n-buffering newValue If newValue is full then the I/O system will buffer output until its internal buffer is full or until the flush command is invoked. If newValue is line, then the I/O system will automatically flush output for the channel whenever a newline character is output. If newValue is none, the I/O system will flush automatically after every output operation.  The default is for -buffering to be set to full except for channels that connect to terminal-like devices; for these channels the initial setting is line.  Additionally, stdin and stdout are initially set to line, and stderr is set to none. \n\n-buffersize newSize Newvalue must be an integer; its value is used to set the size of buffers, in bytes, subsequently allocated for this channel to store input or output. Newvalue must be between ten and one million, allowing buffers of ten to one million bytes in size. \n\n-encoding name This option is used to specify the encoding of the channel, so that the data can be converted to and from Unicode for use in Tcl.  For instance, in order for Tcl to read characters from a Japanese file in shiftjis and properly process and display the contents, the encoding would be set to shiftjis.  Thereafter, when reading from the channel, the bytes in the Japanese file would be converted to Unicode as they are read. Writing is also supported - as Tcl strings are written to the channel they will automatically be converted to the specified encoding on output. \n\n If a file contains pure binary data (for instance, a JPEG image), the encoding for the channel should be configured to be binary.  Tcl will then assign no interpretation to the data in the file and simply read or write raw bytes.  The Tcl binary command can be used to manipulate this byte-oriented data.  It is usually better to set the -translation option to binary when you want to transfer binary data, as this turns off the other automatic interpretations of the bytes in the stream as well. \n\nThe default encoding for newly opened channels is the same platform- and locale-dependent system encoding used for interfacing with the operating system, as returned by encoding system. \n\n-eofchar char \n\n-eofchar {inChar outChar} This option supports DOS file systems that use Control-z (\\x1a) as an end of file marker.  If char is not an empty string, then this character signals end-of-file when it is encountered during input.  For output, the end-of-file character is output when the channel is closed. If char is the empty string, then there is no special end of file character marker.  For read-write channels, a two-element list specifies the end of file marker for input and output, respectively.  As a convenience, when setting the end-of-file character for a read-write channel you can specify a single value that will apply to both reading and writing.  When querying the end-of-file character of a read-write channel, a two-element list will always be returned.  The default value for -eofchar is the empty string in all cases except for files under Windows.  In that case the -eofchar is Control-z (\\x1a) for reading and the empty string for writing. The acceptable range for -eofchar values is \\x01 - \\x7f; attempting to set -eofchar to a value outside of this range will generate an error. \n\n-translation mode \n\n-translation {inMode outMode} In Tcl scripts the end of a line is always represented using a single newline character (\\n).  However, in actual files and devices the end of a line may be represented differently on different platforms, or even for different devices on the same platform.  For example, under UNIX newlines are used in files, whereas carriage-return-linefeed sequences are normally used in network connections.  On input (i.e., with gets and read) the Tcl I/O system automatically translates the external end-of-line representation into newline characters.  Upon output (i.e., with puts), the I/O system translates newlines to the external end-of-line representation.  The default translation mode, auto, handles all the common cases automatically, but the -translation option provides explicit control over the end of line translations. \n\n The value associated with -translation is a single item for read-only and write-only channels.  The value is a two-element list for read-write channels; the read translation mode is the first element of the list, and the write translation mode is the second element.  As a convenience, when setting the translation mode for a read-write channel you can specify a single value that will apply to both reading and writing.  When querying the translation mode of a read-write channel, a two-element list will always be returned.  The following values are currently supported: \n\n  auto As the input translation mode, auto treats any of newline (lf), carriage return (cr), or carriage return followed by a newline (crlf) as the end of line representation.  The end of line representation can even change from line-to-line, and all cases are translated to a newline.  As the output translation mode, auto chooses a platform specific representation; for sockets on all platforms Tcl chooses crlf, for all Unix flavors, it chooses lf, and for the various flavors of Windows it chooses crlf.  The default setting for -translation is auto for both input and output. \n\nbinary No end-of-line translations are performed.  This is nearly identical to lf mode, except that in addition binary mode also sets the end-of-file character to the empty string (which disables it) and sets the encoding to binary (which disables encoding filtering).  See the description of -eofchar and -encoding for more information. \n\n Internally, i.e. when it comes to the actual behaviour of the translator this value is identical to lf and is therefore reported as such when queried. Even if binary was used to set the translation. \n\ncr The end of a line in the underlying file or device is represented by a single carriage return character.  As the input translation mode, cr mode converts carriage returns to newline characters.  As the output translation mode, cr mode translates newline characters to carriage returns. \n\ncrlf The end of a line in the underlying file or device is represented by a carriage return character followed by a linefeed character.  As the input translation mode, crlf mode converts carriage-return-linefeed sequences to newline characters.  As the output translation mode, crlf mode translates newline characters to carriage-return-linefeed sequences.  This mode is typically used on Windows platforms and for network connections. \n\nlf The end of a line in the underlying file or device is represented by a single newline (linefeed) character.  In this mode no translations occur during either input or output.  This mode is typically used on UNIX platforms. \n\n \n\n \n\n "));
		docs.put("lset", new TCLDoc("lset", "Change an element in a list"," The lset command accepts a parameter, varName, which it interprets as the name of a variable containing a Tcl list.  It also accepts zero or more indices into the list.  The indices may be presented either consecutively on the command line, or grouped in a Tcl list and presented as a single argument. Finally, it accepts a new value for an element of varName. \n\n If no indices are presented, the command takes the form: \n\n lset varName newValue \n\n or \n\n lset varName {} newValue \n\n In this case, newValue replaces the old value of the variable varName. \n\n When presented with a single index, the lset command treats the content of the varName variable as a Tcl list. It addresses the index\'th element in it  (0 refers to the first element of the list). When interpreting the list, lset observes the same rules concerning braces and quotes and backslashes as the Tcl command interpreter; however, variable substitution and command substitution do not occur. The command constructs a new list in which the designated element is replaced with newValue.  This new list is stored in the variable varName, and is also the return value from the lset command. \n\n If index is negative or greater than the number of elements in $varName, then an error occurs. \n\n If index is equal to the number of elements in $varName, then the given element is appended to the list. \n\n The interpretation of each simple index value is the same as for the command string index, supporting simple index arithmetic and indices relative to the end of the list. \n\n If additional index arguments are supplied, then each argument is used in turn to address an element within a sublist designated by the previous indexing operation, allowing the script to alter elements in sublists (or append elements to sublists).  The command, \n\n lset a 1 2 newValue \n\n or \n\n lset a {1 2} newValue \n\n replaces element 2 of sublist 1 with newValue. \n\n The integer appearing in each index argument must be greater than or equal to zero.  The integer appearing in each index argument must be less than or equal to the length of the corresponding list.  In other words, the lset command can change the size of a list only by appending an element (setting the one after the current end).  If an index is outside the permitted range, an error is reported. "));
		docs.put("rename", new TCLDoc("rename", "Rename or delete a command"," Rename the command that used to be called oldName so that it is now called newName. If newName is an empty string then oldName is deleted. oldName and newName may include namespace qualifiers (names of containing namespaces). If a command is renamed into a different namespace, future invocations of it will execute in the new namespace. The rename command returns an empty string as result. "));
		docs.put("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", new TCLDoc("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", "standard library of Tcl procedures",""));
		docs.put("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", new TCLDoc("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", "standard library of Tcl procedures",""));
		docs.put("fcopy", new TCLDoc("fcopy", "Copy data from one channel to another"," The fcopy command copies data from one I/O channel, inchan to another I/O channel, outchan. The fcopy command leverages the buffering in the Tcl I/O system to avoid extra copies and to avoid buffering too much data in main memory when copying large files to slow destinations like network sockets. \n\n The fcopy  command transfers data from inchan until end of file or size bytes have been  transferred. If no -size argument is given, then the copy goes until end of file. All the data read from inchan is copied to outchan. Without the -command option, fcopy blocks until the copy is complete and returns the number of bytes written to outchan. \n\n The -command argument makes fcopy work in the background. In this case it returns immediately and the callback is invoked later when the copy completes. The callback is called with one or two additional  arguments that indicates how many bytes were written to outchan. If an error occurred during the background copy, the second argument is the error string associated with the error. With a background copy, it is not necessary to put inchan or outchan into non-blocking mode; the fcopy command takes care of that automatically. However, it is necessary to enter the event loop by using the vwait command or by using Tk. \n\n You are not allowed to do other I/O operations with inchan or outchan during a background fcopy. If either inchan or outchan get closed while the copy is in progress, the current copy is stopped and the command callback is not made. If inchan is closed, then all data already queued for outchan is written out. \n\n Note that inchan can become readable during a background copy. You should turn off any fileevent handlers during a background copy so those handlers do not interfere with the copy. Any I/O attempted by a fileevent handler will get a &#8220;channel busy&#8221; error. \n\n Fcopy translates end-of-line sequences in inchan and outchan according to the -translation option for these channels. See the manual entry for fconfigure for details on the -translation option. The translations mean that the number of bytes read from inchan can be different than the number of bytes written to outchan. Only the number of bytes written to outchan is reported, either as the return value of a synchronous fcopy or as the argument to the callback for an asynchronous fcopy. \n\n Fcopy obeys the encodings and character translations configured for the channels. This means that the incoming characters are converted internally first UTF-8 and then into the encoding of the channel fcopy writes to. See the manual entry for fconfigure for details on the -encoding and -translation options. No conversion is done if both channels are set to encoding &#8220;binary&#8221; and have matching translations. If only the output channel is set to encoding &#8220;binary&#8221; the system will write the internal UTF-8 representation of the incoming characters. If only the input channel is set to encoding &#8220;binary&#8221; the system will assume that the incoming bytes are valid UTF-8 characters and convert them according to the output encoding. The behaviour of the system for bytes which are not valid UTF-8 characters is undefined in this case. "));
		docs.put("lsort", new TCLDoc("lsort", "Sort the elements of a list"," This command sorts the elements of list, returning a new list in sorted order.  The implementation of the lsort command uses the merge-sort algorithm which is a stable sort that has O(n log n) performance characteristics. \n\n By default ASCII sorting is used with the result returned in increasing order.  However, any of the following options may be specified before list to control the sorting process (unique abbreviations are accepted): \n\n  -ascii Use string comparison with Unicode code-point collation order (the name is for backward-compatibility reasons.)  This is the default. \n\n-dictionary Use dictionary-style comparison.  This is the same as -ascii except (a) case is ignored except as a tie-breaker and (b) if two strings contain embedded numbers, the numbers compare as integers, not characters.  For example, in -dictionary mode, bigBoy sorts between bigbang and bigboy, and x10y sorts between x9y and x11y. \n\n-integer Convert list elements to integers and use integer comparison. \n\n-real Convert list elements to floating-point values and use floating comparison. \n\n-command command Use command as a comparison command. To compare two elements, evaluate a Tcl script consisting of command with the two elements appended as additional arguments.  The script should return an integer less than, equal to, or greater than zero if the first element is to be considered less than, equal to, or greater than the second, respectively. \n\n-increasing Sort the list in increasing order (&#8220;smallest&#8221;items first). This is the default. \n\n-decreasing Sort the list in decreasing order (&#8220;largest&#8221;items first). \n\n-indices Return a list of indices into list in sorted order instead of the values themselves. \n\n-index indexList If this option is specified, each of the elements of list must itself be a proper Tcl sublist (unless -stride is used). Instead of sorting based on whole sublists, lsort will extract the indexList\'th element from each sublist (as if the overall element and the indexList were passed to lindex) and sort based on the given element. For example, \n\n lsort -integer -index 1 \\       {{First 24} {Second 18} {Third 30}} \n\n returns {Second 18} {First 24} {Third 30}, \n\n lsort -index end-1 \\         {{a 1 e i} {b 2 3 f g} {c 4 5 6 d h}} \n\n returns {c 4 5 6 d h} {a 1 e i} {b 2 3 f g}, and \n\n lsort -index {0 1} {     {{b i g} 12345}     {{d e m o} 34512}     {{c o d e} 54321} } \n\nreturns {{d e m o} 34512} {{b i g} 12345} {{c o d e} 54321} (because e sorts before i which sorts before o.) This option is much more efficient than using -command to achieve the same effect. \n\n-stride strideLength If this option is specified, the list is treated as consisting of groups of strideLength elements and the groups are sorted by either their first element or, if the -index option is used, by the element within each group given by the first index passed to -index (which is then ignored by -index). Elements always remain in the same position within their group. \n\n The list length must be an integer multiple of strideLength, which in turn must be at least 2. \n\n For example, \n\n lsort -stride 2 {carrot 10 apple 50 banana 25} \n\n returns &#8220;apple 50 banana 25 carrot 10&#8221;, and \n\n lsort -stride 2 -index 1 -integer {carrot 10 apple 50 banana 25} \n\nreturns &#8220;carrot 10 banana 25 apple 50&#8221;. \n\n-nocase Causes comparisons to be handled in a case-insensitive manner.  Has no effect if combined with the -dictionary, -integer, or  -real options. \n\n-unique If this option is specified, then only the last set of duplicate elements found in the list will be retained.  Note that duplicates are determined relative to the comparison used in the sort.  Thus if  -index 0 is used, {1 a} and {1 b} would be considered duplicates and only the second element, {1 b}, would be retained. \n\n "));
		docs.put("return", new TCLDoc("return", "Return from a procedure, or set return code of a script"," In its simplest usage, the return command is used without options in the body of a procedure to immediately return control to the caller of the procedure.  If a result argument is provided, its value becomes the result of the procedure passed back to the caller.   If result is not specified then an empty string will be returned to the caller as the result of the procedure. \n\n The return command serves a similar function within script files that are evaluated by the source command.  When source evaluates the contents of a file as a script, an invocation of the return command will cause script evaluation to immediately cease, and the value result (or an empty string) will be returned as the result of the source command. "));
		docs.put("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", new TCLDoc("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", "standard library of Tcl procedures",""));
		docs.put("file", new TCLDoc("file", "Manipulate file names and attributes"," This command provides several operations on a file\'s name or attributes. Name is the name of a file; if it starts with a tilde, then tilde substitution is done before executing the command (see the manual entry for filename for details).  Option indicates what to do with the file name.  Any unique abbreviation for option is acceptable.  The valid options are: \n\n  file atime name ?time? Returns a decimal string giving the time at which file name was last accessed.  If time is specified, it is an access time to set for the file.  The time is measured in the standard POSIX fashion as seconds from a fixed starting time (often January 1, 1970).  If the file does not exist or its access time cannot be queried or set then an error is generated.  On Windows, FAT file systems do not support access time. \n\nfile attributes name \n\nfile attributes name ?option? \n\nfile attributes name ?option value option value...? This subcommand returns or sets platform specific values associated with a file. The first form returns a list of the platform specific flags and their values. The second form returns the value for the specific option. The third form sets one or more of the values. The values are as follows: \n\n On Unix, -group gets or sets the group name for the file. A group id can be given to the command, but it returns a group name. -owner gets or sets the user name of the owner of the file. The command returns the owner name, but the numerical id can be passed when setting the owner. -permissions sets or retrieves the octal code that chmod(1) uses.  This command does also has limited support for setting using the symbolic attributes for chmod(1), of the form [ugo]?[[+-=][rwxst],[...]], where multiple symbolic attributes can be separated by commas (example: u+s,go-rw add sticky bit for user, remove read and write permissions for group and other).  A simplified ls style string, of the form rwxrwxrwx (must be 9 characters), is also supported (example: rwxr-xr-t is equivalent to 01755). On versions of Unix supporting file flags, -readonly gives the value or sets or clears the readonly attribute of the file, i.e. the user immutable flag uchg to chflags(1). \n\n On Windows, -archive gives the value or sets or clears the archive attribute of the file. -hidden gives the value or sets or clears the hidden attribute of the file. -longname will expand each path element to its long version. This attribute cannot be set. -readonly gives the value or sets or clears the readonly attribute of the file. -shortname gives a string where every path element is replaced with its short (8.3) version of the name. This attribute cannot be set. -system gives or sets or clears the value of the system attribute of the file. \n\nOn Mac OS X and Darwin, -creator gives or sets the Finder creator type of the file. -hidden gives or sets or clears the hidden attribute of the file. -readonly gives or sets or clears the readonly attribute of the file. -rsrclength gives the length of the resource fork of the file, this attribute can only be set to the value 0, which results in the resource fork being stripped off the file. \n\nfile channels ?pattern? If pattern is not specified, returns a list of names of all registered open channels in this interpreter.  If pattern is specified, only those names matching pattern are returned.  Matching is determined using the same rules as for string match. \n\nfile copy ?-force? ?--? source target \n\nfile copy ?-force? ?--? source ?source ...? targetDir The first form makes a copy of the file or directory source under the pathname target. If target is an existing directory, then the second form is used.  The second form makes a copy inside targetDir of each source file listed.  If a directory is specified as a source, then the contents of the directory will be recursively copied into targetDir. Existing files will not be overwritten unless the -force option is specified (when Tcl will also attempt to adjust permissions on the destination file or directory if that is necessary to allow the copy to proceed).  When copying within a single filesystem, file copy will copy soft links (i.e. the links themselves are copied, not the things they point to).  Trying to overwrite a non-empty directory, overwrite a directory with a file, or overwrite a file with a directory will all result in errors even if -force was specified.  Arguments are processed in the order specified, halting at the first error, if any.  A -- marks the end of switches; the argument following the -- will be treated as a source even if it starts with a -. \n\nfile delete ?-force? ?--? ?pathname ... ? Removes the file or directory specified by each pathname argument.  Non-empty directories will be removed only if the -force option is specified.  When operating on symbolic links, the links themselves will be deleted, not the objects they point to. Trying to delete a non-existent file is not considered an error. Trying to delete a read-only file will cause the file to be deleted, even if the -force flags is not specified.  If the -force option is specified on a directory, Tcl will attempt both to change permissions and move the current directory &#8220;pwd&#8221; out of the given path if that is necessary to allow the deletion to proceed.  Arguments are processed in the order specified, halting at the first error, if any. A -- marks the end of switches; the argument following the -- will be treated as a pathname even if it starts with a -. \n\nfile dirname name Returns a name comprised of all of the path components in name excluding the last element.  If name is a relative file name and only contains one path element, then returns &#8220;.&#8221;. If name refers to a root directory, then the root directory is returned.  For example, \n\n file dirname c:/ \n\n returns c:/.  \n\n Note that tilde substitution will only be performed if it is necessary to complete the command. For example, \n\n file dirname ~/src/foo.c \n\n returns ~/src, whereas \n\n file dirname ~ \n\nreturns /home (or something similar). \n\nfile executable name Returns 1 if file name is executable by the current user, 0 otherwise.   \n\nfile exists name Returns 1 if file name exists and the current user has search privileges for the directories leading to it, 0 otherwise. \n\nfile extension name Returns all of the characters in name after and including the last dot in the last element of name.  If there is no dot in the last element of name then returns the empty string. \n\nfile isdirectory name Returns 1 if file name is a directory, 0 otherwise. \n\nfile isfile name Returns 1 if file name is a regular file, 0 otherwise. \n\nfile join name ?name ...? Takes one or more file names and combines them, using the correct path separator for the current platform.  If a particular name is relative, then it will be joined to the previous file name argument. Otherwise, any earlier arguments will be discarded, and joining will proceed from the current argument.  For example, \n\n file join a b /foo bar \n\n returns /foo/bar. \n\nNote that any of the names can contain separators, and that the result is always canonical for the current platform: / for Unix and Windows. \n\nfile link ?-linktype? linkName ?target? If only one argument is given, that argument is assumed to be linkName, and this command returns the value of the link given by linkName (i.e. the name of the file it points to).  If linkName is not a link or its value cannot be read (as, for example, seems to be the case with hard links, which look just like ordinary files), then an error is returned. \n\n If 2 arguments are given, then these are assumed to be linkName and target. If linkName already exists, or if target does not exist, an error will be returned.  Otherwise, Tcl creates a new link called linkName which points to the existing filesystem object at target (which is also the returned value), where the type of the link is platform-specific (on Unix a symbolic link will be the default).  This is useful for the case where the user wishes to create a link in a cross-platform way, and does not care what type of link is created. \n\n If the user wishes to make a link of a specific type only, (and signal an error if for some reason that is not possible), then the optional -linktype argument should be given.  Accepted values for -linktype are &#8220;-symbolic&#8221; and &#8220;-hard&#8221;. \n\nOn Unix, symbolic links can be made to relative paths, and those paths must be relative to the actual linkName\'s location (not to the cwd), but on all other platforms where relative links are not supported, target paths will always be converted to absolute, normalized form before the link is created (and therefore relative paths are interpreted as relative to the cwd).  Furthermore, &#8220;~user&#8221; paths are always expanded to absolute form.  When creating links on filesystems that either do not support any links, or do not support the specific type requested, an error message will be returned.  In particular Windows 95, 98 and ME do not support any links at present, but most Unix platforms support both symbolic and hard links (the latter for files only) and Windows NT/2000/XP (on NTFS drives) support symbolic directory links and hard file links. \n\nfile lstat name varName Same as stat option (see below) except uses the lstat kernel call instead of stat.  This means that if name refers to a symbolic link the information returned in varName is for the link rather than the file it refers to.  On systems that do not support symbolic links this option behaves exactly the same as the stat option. \n\nfile mkdir ?dir ...? Creates each directory specified.  For each pathname dir specified, this command will create all non-existing parent directories as well as dir itself.  If an existing directory is specified, then no action is taken and no error is returned.  Trying to overwrite an existing file with a directory will result in an error.  Arguments are processed in the order specified, halting at the first error, if any. \n\nfile mtime name ?time? Returns a decimal string giving the time at which file name was last modified.  If time is specified, it is a modification time to set for the file (equivalent to Unix touch).  The time is measured in the standard POSIX fashion as seconds from a fixed starting time (often January 1, 1970).  If the file does not exist or its modified time cannot be queried or set then an error is generated. \n\nfile nativename name Returns the platform-specific name of the file. This is useful if the filename is needed to pass to a platform-specific call, such as to a subprocess via exec under Windows (see EXAMPLES below). \n\nfile normalize name Returns a unique normalized path representation for the file-system object (file, directory, link, etc), whose string value can be used as a unique identifier for it.  A normalized path is an absolute path which has all &#8220;../&#8221; and &#8220;./&#8221; removed.  Also it is one which is in the &#8220;standard&#8221; format for the native platform.  On Unix, this means the segments leading up to the path must be free of symbolic links/aliases (but the very last path component may be a symbolic link), and on Windows it also means we want the long form with that form\'s case-dependence (which gives us a unique, case-dependent path).  The one exception concerning the last link in the path is necessary, because Tcl or the user may wish to operate on the actual symbolic link itself (for example file delete, file rename, file copy are defined to operate on symbolic links, not on the things that they point to). \n\nfile owned name Returns 1 if file name is owned by the current user, 0 otherwise. \n\nfile pathtype name Returns one of absolute, relative, volumerelative. If name refers to a specific file on a specific volume, the path type will be absolute. If name refers to a file relative to the current working directory, then the path type will be relative. If name refers to a file relative to the current working directory on a specified volume, or to a specific file on the current working volume, then the path type is volumerelative. \n\nfile readable name Returns 1 if file name is readable by the current user, 0 otherwise.  \n\nfile readlink name Returns the value of the symbolic link given by name (i.e. the name of the file it points to).  If name is not a symbolic link or its value cannot be read, then an error is returned.  On systems that do not support symbolic links this option is undefined. \n\nfile rename ?-force? ?--? source target \n\nfile rename ?-force? ?--? source ?source ...? targetDir The first form takes the file or directory specified by pathname source and renames it to target, moving the file if the pathname target specifies a name in a different directory.  If target is an existing directory, then the second form is used. The second form moves each source file or directory into the directory targetDir. Existing files will not be overwritten unless the -force option is specified.  When operating inside a single filesystem, Tcl will rename symbolic links rather than the things that they point to.  Trying to overwrite a non-empty directory, overwrite a directory with a file, or a file with a directory will all result in errors.  Arguments are processed in the order specified, halting at the first error, if any.  A -- marks the end of switches; the argument following the -- will be treated as a source even if it starts with a -. \n\nfile rootname name Returns all of the characters in name up to but not including the last &#8220;.&#8221; character in the last component of name.  If the last component of name does not contain a dot, then returns name. \n\nfile separator ?name? If no argument is given, returns the character which is used to separate  path segments for native files on this platform.  If a path is given, the filesystem responsible for that path is asked to return its separator character.  If no file system accepts name, an error is generated. \n\nfile size name Returns a decimal string giving the size of file name in bytes.  If the file does not exist or its size cannot be queried then an error is generated. \n\nfile split name Returns a list whose elements are the path components in name.  The first element of the list will have the same path type as name. All other elements will be relative.  Path separators will be discarded unless they are needed to ensure that an element is unambiguously relative. For example, under Unix \n\n file split /foo/~bar/baz \n\nreturns &#8220;/  foo  ./~bar  baz&#8221; to ensure that later commands that use the third component do not attempt to perform tilde substitution. \n\nfile stat  name varName Invokes the stat kernel call on name, and uses the variable given by varName to hold information returned from the kernel call. VarName is treated as an array variable, and the following elements of that variable are set: atime, ctime, dev, gid, ino, mode, mtime, nlink, size, type, uid.  Each element except type is a decimal string with the value of the corresponding field from the stat return structure; see the manual entry for stat for details on the meanings of the values.  The type element gives the type of the file in the same form returned by the command file type.  This command returns an empty string. \n\nfile system name Returns a list of one or two elements, the first of which is the name of the filesystem to use for the file, and the second, if given, an arbitrary string representing the filesystem-specific nature or type of the location within that filesystem.  If a filesystem only supports one type of file, the second element may not be supplied.  For example the native files have a first element &#8220;native&#8221;, and a second element which when given is a platform-specific type name for the file\'s system (e.g. &#8220;NTFS&#8221;, &#8220;FAT&#8221;, on Windows).  A generic virtual file system might return the list &#8220;vfs ftp&#8221; to represent a file on a remote ftp site mounted as a virtual filesystem through an extension called &#8220;vfs&#8221;. If the file does not belong to any filesystem, an error is generated. \n\nfile tail name Returns all of the characters in the last filesystem component of name.  Any trailing directory separator in name is ignored. If name contains no separators then returns name.  So,  file tail a/b, file tail a/b/ and file tail b all return b. \n\nfile tempfile ?nameVar? ?template? Creates a temporary file and returns a read-write channel opened on that file. If the nameVar is given, it specifies a variable that the name of the temporary file will be written into; if absent, Tcl will attempt to arrange for the temporary file to be deleted once it is no longer required. If the template is present, it specifies parts of the template of the filename to use when creating it (such as the directory, base-name or extension) though some platforms may ignore some or all of these parts and use a built-in default instead. \n\n Note that temporary files are only ever created on the native filesystem. As such, they can be relied upon to be used with operating-system native APIs and external programs that require a filename. \n\nfile type name Returns a string giving the type of file name, which will be one of file, directory, characterSpecial, blockSpecial, fifo, link, or socket. \n\nfile volumes Returns the absolute paths to the volumes mounted on the system, as a proper Tcl list.  Without any virtual filesystems mounted as root volumes, on UNIX, the command will always return &#8220;/&#8221;, since all filesystems are locally mounted. On Windows, it will return a list of the available local drives (e.g. &#8220;a:/ c:/&#8221;). If any virtual filesystem has mounted additional volumes, they will be in the returned list. \n\nfile writable name Returns 1 if file name is writable by the current user, 0 otherwise. \n\n "));
		docs.put("mathfunc", new TCLDoc("mathfunc", "Mathematical functions for Tcl expressions"," The expr command handles mathematical functions of the form sin($x) or atan2($y,$x) by converting them to calls of the form [tcl::mathfunc::sin [expr {$x}]] or [tcl::mathfunc::atan2 [expr {$y}] [expr {$x}]]. A number of math functions are available by default within the namespace ::tcl::mathfunc; these functions are also available for code apart from expr, by invoking the given commands directly. \n\n Tcl supports the following mathematical functions in expressions, all of which work solely with floating-point numbers unless otherwise noted: absacosasinatanatan2boolceilcoscoshdoubleentierexpfloorfmodhypotintisqrtloglog10maxminpowrandroundsinsinhsqrtsrandtantanhwide \n\n In addition to these predefined functions, applications may define additional functions by using proc (or any other method, such as interp alias or Tcl_CreateObjCommand) to define new commands in the tcl::mathfunc namespace.  In addition, an obsolete interface named Tcl_CreateMathFunc() is available to extensions that are written in C. The latter interface is not recommended for new implementations. DETAILED DEFINITIONS  abs arg Returns the absolute value of arg.  Arg may be either integer or floating-point, and the result is returned in the same form. \n\nacos arg Returns the arc cosine of arg, in the range [0,pi] radians. Arg should be in the range [-1,1]. \n\nasin arg Returns the arc sine of arg, in the range [-pi/2,pi/2] radians.  Arg should be in the range [-1,1]. \n\natan arg Returns the arc tangent of arg, in the range [-pi/2,pi/2] radians. \n\natan2 y x Returns the arc tangent of y/x, in the range [-pi,pi] radians.  x and y cannot both be 0.  If x is greater than 0, this is equivalent to &#8220;atan [expr {y/x}]&#8221;. \n\nbool arg Accepts any numeric value, or any string acceptable to string is boolean, and returns the corresponding  boolean value 0 or 1.  Non-zero numbers are true. Other numbers are false.  Non-numeric strings produce boolean value in agreement with string is true and string is false. \n\nceil arg Returns the smallest integral floating-point value (i.e. with a zero fractional part) not less than arg.  The argument may be any numeric value. \n\ncos arg Returns the cosine of arg, measured in radians. \n\ncosh arg Returns the hyperbolic cosine of arg.  If the result would cause an overflow, an error is returned. \n\ndouble arg The argument may be any numeric value, If arg is a floating-point value, returns arg, otherwise converts arg to floating-point and returns the converted value.  May return Inf or -Inf when the argument is a numeric value that exceeds the floating-point range. \n\nentier arg The argument may be any numeric value.  The integer part of arg is determined and returned.  The integer range returned by this function is unlimited, unlike int and wide which truncate their range to fit in particular storage widths. \n\nexp arg Returns the exponential of arg, defined as e**arg. If the result would cause an overflow, an error is returned. \n\nfloor arg Returns the largest integral floating-point value (i.e. with a zero fractional part) not greater than arg.  The argument may be any numeric value. \n\nfmod x y Returns the floating-point remainder of the division of x by y.  If y is 0, an error is returned. \n\nhypot x y Computes the length of the hypotenuse of a right-angled triangle, approximately &#8220;sqrt [expr {x*x+y*y}]&#8221; except for being more numerically stable when the two arguments have substantially different magnitudes. \n\nint arg The argument may be any numeric value.  The integer part of arg is determined, and then the low order bits of that integer value up to the machine word size are returned as an integer value.  For reference, the number of bytes in the machine word are stored in the wordSize element of the tcl_platform array. \n\nisqrt arg Computes the integer part of the square root of arg.  Arg must be a positive value, either an integer or a floating point number. Unlike sqrt, which is limited to the precision of a floating point number, isqrt will return a result of arbitrary precision. \n\nlog arg Returns the natural logarithm of arg.  Arg must be a positive value. \n\nlog10 arg Returns the base 10 logarithm of arg.  Arg must be a positive value. \n\nmax arg ... Accepts one or more numeric arguments.  Returns the one argument with the greatest value. \n\nmin arg ... Accepts one or more numeric arguments.  Returns the one argument with the least value. \n\npow x y Computes the value of x raised to the power y.  If x is negative, y must be an integer value. \n\nrand Returns a pseudo-random floating-point value in the range (0,1).   The generator algorithm is a simple linear congruential generator that is not cryptographically secure.  Each result from rand completely determines all future results from subsequent calls to rand, so rand should not be used to generate a sequence of secrets, such as one-time passwords.  The seed of the generator is initialized from the internal clock of the machine or may be set with the srand function. \n\nround arg If arg is an integer value, returns arg, otherwise converts arg to integer by rounding and returns the converted value. \n\nsin arg Returns the sine of arg, measured in radians. \n\nsinh arg Returns the hyperbolic sine of arg.  If the result would cause an overflow, an error is returned. \n\nsqrt arg The argument may be any non-negative numeric value.  Returns a floating-point value that is the square root of arg.  May return Inf when the argument is a numeric value that exceeds the square of the maximum value of the floating-point range. \n\nsrand arg The arg, which must be an integer, is used to reset the seed for the random number generator of rand.  Returns the first random number (see rand) from that seed.  Each interpreter has its own seed. \n\ntan arg Returns the tangent of arg, measured in radians. \n\ntanh arg Returns the hyperbolic tangent of arg. \n\nwide arg The argument may be any numeric value.  The integer part of arg is determined, and then the low order 64 bits of that integer value are returned as an integer value.   \n\n "));
		docs.put("safe", new TCLDoc("safe", "Creating and manipulating safe interpreters",""));
		docs.put("tcltest", new TCLDoc("tcltest", "Test harness support code and utilities"," The tcltest package provides several utility commands useful in the construction of test suites for code instrumented to be run by evaluation of Tcl commands.  Notably the built-in commands of the Tcl library itself are tested by a test suite using the tcltest package. \n\n All the commands provided by the tcltest package are defined in and exported from the ::tcltest namespace, as indicated in the SYNOPSIS above.  In the following sections, all commands will be described by their simple names, in the interest of brevity. \n\n The central command of tcltest is test that defines and runs a test.  Testing with test involves evaluation of a Tcl script and comparing the result to an expected result, as configured and controlled by a number of options.  Several other commands provided by tcltest govern the configuration of test and the collection of many test commands into test suites. \n\n See CREATING TEST SUITES WITH TCLTEST below for an extended example of how to use the commands of tcltest to produce test suites for your Tcl-enabled code. "));
		docs.put("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", new TCLDoc("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", "standard library of Tcl procedures",""));
		docs.put("fileevent", new TCLDoc("fileevent", "Execute a script when a channel becomes readable or writable"," This command is used to create file event handlers.  A file event handler is a binding between a channel and a script, such that the script is evaluated whenever the channel becomes readable or writable.  File event handlers are most commonly used to allow data to be received from another process on an event-driven basis, so that the receiver can continue to interact with the user while waiting for the data to arrive.  If an application invokes gets or read on a blocking channel when there is no input data available, the process will block; until the input data arrives, it will not be able to service other events, so it will appear to the user to &#8220;freeze up&#8221;. With fileevent, the process can tell when data is present and only invoke gets or read when they will not block. \n\n The channelId argument to fileevent refers to an open channel such as a Tcl standard channel (stdin, stdout, or stderr), the return value from an invocation of open or socket, or the result of a channel creation command provided by a Tcl extension. \n\n If the script argument is specified, then fileevent creates a new event handler:  script will be evaluated whenever the channel becomes readable or writable (depending on the second argument to fileevent). In this case fileevent returns an empty string. The readable and writable event handlers for a file are independent, and may be created and deleted separately. However, there may be at most one readable and one writable handler for a file at a given time in a given interpreter. If fileevent is called when the specified handler already exists in the invoking interpreter, the new script replaces the old one. \n\n If the script argument is not specified, fileevent returns the current script for channelId, or an empty string if there is none. If the script argument is specified as an empty string then the event handler is deleted, so that no script will be invoked. A file event handler is also deleted automatically whenever its channel is closed or its interpreter is deleted. \n\n A channel is considered to be readable if there is unread data available on the underlying device. A channel is also considered to be readable if there is unread data in an input buffer, except in the special case where the most recent attempt to read from the channel was a gets call that could not find a complete line in the input buffer. This feature allows a file to be read a line at a time in nonblocking mode using events. A channel is also considered to be readable if an end of file or error condition is present on the underlying file or device. It is important for script to check for these conditions and handle them appropriately;  for example, if there is no special check for end of file, an infinite loop may occur where script reads no data, returns, and is immediately invoked again. \n\n A channel is considered to be writable if at least one byte of data can be written to the underlying file or device without blocking, or if an error condition is present on the underlying file or device. \n\n Event-driven I/O works best for channels that have been placed into nonblocking mode with the fconfigure command. In blocking mode, a puts command may block if you give it more data than the underlying file or device can accept, and a gets or read command will block if you attempt to read more data than is ready;  no events will be processed while the commands block. In nonblocking mode puts, read, and gets never block. See the documentation for the individual commands for information on how they handle blocking and nonblocking channels. \n\n Testing for the end of file condition should be done after any attempts read the channel data. The eof flag is set once an attempt to read the end of data has occurred and testing before this read will require an additional event to be fired. \n\n The script for a file event is executed at global level (outside the context of any Tcl procedure) in the interpreter in which the fileevent command was invoked. If an error occurs while executing the script then the command registered with interp bgerror is used to report the error. In addition, the file event handler is deleted if it ever returns an error;  this is done in order to prevent infinite loops due to buggy handlers. "));
		docs.put("mathop", new TCLDoc("mathop", "Mathematical operators as Tcl commands"," The commands in the ::tcl::mathop namespace implement the same set of operations as supported by the expr command. All are exported from the namespace, but are not imported into any other namespace by default. Note that renaming, reimplementing or deleting any of the commands in the namespace does not alter the way that the expr command behaves, and nor does defining any new commands in the ::tcl::mathop namespace. \n\n The following operator commands are supported: ~!+-*/%**&|^>>"));
		docs.put("scan", new TCLDoc("scan", "Parse string using conversion specifiers in the style of sscanf",""));
		docs.put("tell", new TCLDoc("tell", "Return current access position for an open channel"," Returns an integer string giving the current access position in channelId.  This value returned is a byte offset that can be passed to seek in order to set the channel to a particular position.  Note that this value is in terms of bytes, not characters like read. The value returned is -1 for channels that do not support seeking. \n\n ChannelId must be an identifier for an open channel such as a Tcl standard channel (stdin, stdout, or stderr), the return value from an invocation of open or socket, or the result of a channel creation command provided by a Tcl extension. "));
		docs.put("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", new TCLDoc("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", "standard library of Tcl procedures",""));
		docs.put("memory", new TCLDoc("memory", "Control Tcl memory debugging capabilities"," The memory command gives the Tcl developer control of Tcl\'s memory debugging capabilities.  The memory command has several suboptions, which are described below.  It is only available when Tcl has been compiled with memory debugging enabled (when TCL_MEM_DEBUG is defined at compile time), and after Tcl_InitMemory has been called. \n\n  memory active file Write a list of all currently allocated memory to the specified file. \n\nmemory break_on_malloc count After the count allocations have been performed, ckalloc outputs a message to this effect and that it is now attempting to enter the C debugger.  Tcl will then issue a SIGINT signal against itself. If you are running Tcl under a C debugger, it should then enter the debugger command mode. \n\nmemory info Returns a report containing the total allocations and frees since  Tcl began, the current packets allocated (the current number of calls to ckalloc not met by a corresponding call  to ckfree), the current bytes allocated, and the maximum number of packets and bytes allocated. \n\nmemory init [on|off] Turn on or off the pre-initialization of all allocated memory with bogus bytes.  Useful for detecting the use of uninitialized values. \n\nmemory objs file Causes a list of all allocated Tcl_Obj values to be written to the specified file immediately, together with where they were allocated.  Useful for checking for leaks of values. \n\nmemory onexit file Causes a list of all allocated memory to be written to the specified file during the finalization of Tcl\'s memory subsystem.  Useful for checking that memory is properly cleaned up during process exit. \n\nmemory tag string Each packet of memory allocated by ckalloc can have associated with it a string-valued tag.  In the lists of allocated memory generated by memory active and memory onexit, the tag for each packet is printed along with other information about the packet.  The memory tag command sets the tag value for subsequent calls to ckalloc to be string.   \n\nmemory trace [on|off] Turns memory tracing on or off.  When memory tracing is on, every call to ckalloc causes a line of trace information to be written to stderr, consisting of the word ckalloc, followed by the address returned, the amount of memory allocated, and the C filename and line number of the code performing the allocation.  For example: \n\n ckalloc 40e478 98 tclProc.c 1406 \n\nCalls to ckfree are traced in the same manner. \n\nmemory trace_on_at_malloc count Enable memory tracing after count ckallocs have been performed. For example, if you enter memory trace_on_at_malloc 100, after the 100th call to ckalloc, memory trace information will begin being displayed for all allocations and frees.  Since there can be a lot of memory activity before a problem occurs, judicious use of this option can reduce the slowdown caused by tracing (and the amount of trace information produced), if you can identify a number of allocations that occur before the problem sets in.  The current number of memory allocations that have  occurred since Tcl started is printed on a guard zone failure. \n\nmemory validate [on|off] Turns memory validation on or off. When memory validation is enabled, on every call to ckalloc or ckfree, the guard zones are checked for every piece of memory currently in existence that was allocated by ckalloc.  This has a large performance impact and should only be used when overwrite problems are strongly suspected. The advantage of enabling memory validation is that a guard zone overwrite can be detected on the first call to ckalloc or ckfree after the overwrite occurred, rather than when the specific memory with the overwritten guard zone(s) is freed, which may occur long after the overwrite occurred. \n\n "));
		docs.put("seek", new TCLDoc("seek", "Change the access position for an open channel"," Changes the current access position for channelId. \n\n ChannelId must be an identifier for an open channel such as a Tcl standard channel (stdin, stdout, or stderr), the return value from an invocation of open or socket, or the result of a channel creation command provided by a Tcl extension. \n\n The offset and origin arguments specify the position at which the next read or write will occur for channelId. Offset must be an integer (which may be negative) and origin must be one of the following: \n\n  start The new access position will be offset bytes from the start of the underlying file or device. \n\ncurrent The new access position will be offset bytes from the current access position; a negative offset moves the access position backwards in the underlying file or device. \n\nend The new access position will be offset bytes from the end of the file or device.  A negative offset places the access position before the end of file, and a positive offset places the access position after the end of file. \n\n \n\n The origin argument defaults to start. \n\n The command flushes all buffered output for the channel before the command returns, even if the channel is in non-blocking mode. It also discards any buffered and unread input. This command returns an empty string. An error occurs if this command is applied to channels whose underlying file or device does not support seeking. \n\n Note that offset values are byte offsets, not character offsets.  Both seek and tell operate in terms of bytes, not characters, unlike read. "));
		docs.put("throw", new TCLDoc("throw", "Generate a machine-readable error"," This command causes the current evaluation to be unwound with an error. The error created is described by the type and message arguments: type must contain a list of words describing the error in a form that is machine-readable (and which will form the error-code part of the result dictionary), and message should contain text that is intended for display to a human being. \n\n The stack will be unwound until the error is trapped by a suitable catch or try command. If it reaches the event loop without being trapped, it will be reported through the bgerror mechanism. If it reaches the top level of script evaluation in tclsh, it will be printed on the console before, in the non-interactive case, causing an exit (the behavior in other programs will depend on the details of how Tcl is embedded and used). \n\n By convention, the words in the type argument should go from most general to most specific. "));
		docs.put("flush", new TCLDoc("flush", "Flush buffered output for a channel"," Flushes any output that has been buffered for channelId. \n\n ChannelId must be an identifier for an open channel such as a Tcl standard channel (stdout or stderr), the return value from an invocation of open or socket, or the result of a channel creation command provided by a Tcl extension.  The channel must have been opened for writing. \n\n If the channel is in blocking mode the command does not return until all the buffered output has been flushed to the channel. If the channel is in nonblocking mode, the command may return before all buffered output has been flushed; the remainder will be flushed in the background as fast as the underlying file or device is able to absorb it. "));
		docs.put("msgcat", new TCLDoc("msgcat", "Tcl message catalog"," The msgcat package provides a set of functions that can be used to manage multi-lingual user interfaces. Text strings are defined in a &#8220;message catalog&#8221; which is independent from the application, and which can be edited or localized without modifying the application source code.  New languages or locales are provided by adding a new file to the message catalog. \n\n Use of the message catalog is optional by any application or package, but is encouraged if the application or package wishes to be enabled for multi-lingual applications. "));
		docs.put("self", new TCLDoc("self", "method call internal introspection"," The self command, which should only be used from within the context of a call to a method (i.e. inside a method, constructor or destructor body) is used to allow the method to discover information about how it was called. It takes an argument, subcommand, that tells it what sort of information is actually desired; if omitted the result will be the same as if self object was invoked. The supported subcommands are: \n\n  self call This returns a two-element list describing the method implementations used to implement the current call chain. The first element is the same as would be reported by info object call for the current method (except that this also reports useful values from within constructors and destructors, whose names are reported as  and  respectively), and the second element is an index into the first element\'s list that indicates which actual implementation is currently executing (the first implementation to execute is always at index 0). \n\nself caller When the method was invoked from inside another object method, this subcommand returns a three element list describing the containing object and method. The first element describes the declaring object or class of the method, the second element is the name of the object on which the containing method was invoked, and the third element is the name of the method (with the strings  and  indicating constructors and destructors respectively). \n\nself class This returns the name of the class that the current method was defined within. Note that this will change as the chain of method implementations is traversed with next, and that if the method was defined on an object then this will fail. \n\n If you want the class of the current object, you need to use this other construct: \n\n info object class [self object] \n\nself filter When invoked inside a filter, this subcommand returns a three element list describing the filter. The first element gives the name of the object or class that declared the filter (note that this may be different from the object or class that provided the implementation of the filter), the second element is either object or class depending on whether the declaring entity was an object or class, and the third element is the name of the filter. \n\nself method This returns the name of the current method (with the strings  and  indicating constructors and destructors respectively). \n\nself namespace This returns the name of the unique namespace of the object that the method was invoked upon. \n\nself next When invoked from a method that is not at the end of a call chain (i.e. where the next command will invoke an actual method implementation), this subcommand returns a two element list describing the next element in the method call chain; the first element is the name of the class or object that declares the next part of the call chain, and the second element is the name of the method (with the strings  and  indicating constructors and destructors respectively). If invoked from a method that is at the end of a call chain, this subcommand returns the empty string. \n\nself object This returns the name of the object that the method was invoked upon. \n\nself target When invoked inside a filter implementation, this subcommand returns a two element list describing the method being filtered. The first element will be the name of the declarer of the method, and the second element will be the actual name of the method. \n\n "));
		docs.put("time", new TCLDoc("time", "Time the execution of a script"," This command will call the Tcl interpreter count times to evaluate script (or once if count is not specified).  It will then return a string of the form \n\n 503.2 microseconds per iteration \n\n which indicates the average amount of time required per iteration, in microseconds. Time is measured in elapsed time, not CPU time. "));
		docs.put("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", new TCLDoc("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", "standard library of Tcl procedures",""));
		docs.put("for", new TCLDoc("for", "'For' loop"," For is a looping command, similar in structure to the C for statement.  The start, next, and body arguments must be Tcl command strings, and test is an expression string. The for command first invokes the Tcl interpreter to execute start.  Then it repeatedly evaluates test as an expression; if the result is non-zero it invokes the Tcl interpreter on body, then invokes the Tcl interpreter on next, then repeats the loop.  The command terminates when test evaluates to 0.  If a continue command is invoked within body then any remaining commands in the current execution of body are skipped; processing continues by invoking the Tcl interpreter on next, then evaluating test, and so on.  If a break command is invoked within body or next, then the for command will return immediately. The operation of break and continue are similar to the corresponding statements in C. For returns an empty string. \n\n Note: test should almost always be enclosed in braces.  If not, variable substitutions will be made before the for command starts executing, which means that variable changes made by the loop body will not be considered in the expression. This is likely to result in an infinite loop.  If test is enclosed in braces, variable substitutions are delayed until the expression is evaluated (before each loop iteration), so changes in the variables will be visible. See below for an example: "));
		docs.put("my", new TCLDoc("my", "invoke any method of current object"," The my command is used to allow methods of objects to invoke any method of the object (or its class). In particular, the set of valid values for methodName is the set of all methods supported by an object and its superclasses, including those that are not exported. The object upon which the method is invoked is always the one that is the current context of the method (i.e. the object that is returned by self object) from which the my command is invoked. \n\n Each object has its own my command, contained in its instance namespace. "));
		docs.put("set", new TCLDoc("set", "Read and write variables"," Returns the value of variable varName. If value is specified, then set the value of varName to value, creating a new variable if one does not already exist, and return its value. If varName contains an open parenthesis and ends with a close parenthesis, then it refers to an array element:  the characters before the first open parenthesis are the name of the array, and the characters between the parentheses are the index within the array. Otherwise varName refers to a scalar variable. \n\n If varName includes namespace qualifiers (in the array name if it refers to an array element), or if varName is unqualified (does not include the names of any containing namespaces) but no procedure is active,  varName refers to a namespace variable resolved according to the rules described under NAME RESOLUTION in the namespace manual page. \n\n If a procedure is active and varName is unqualified, then varName refers to a parameter or local variable of the procedure, unless varName was declared to resolve differently through one of the  global, variable or upvar commands. "));
		docs.put("tm", new TCLDoc("tm", "Facilities for locating and loading of Tcl Modules"," This document describes the facilities for locating and loading Tcl Modules (see MODULE DEFINITION for the definition of a Tcl Module). The following commands are supported: \n\n  ::tcl::tm::path add ?path...? The paths are added at the head to the list of module paths, in order of appearance. This means that the last argument ends up as the new head of the list. \n\n The command enforces the restriction that no path may be an ancestor directory of any other path on the list. If any of the new paths violates this restriction an error will be raised, before any of the paths have been added. In other words, if only one path argument violates the restriction then none will be added. \n\n If a path is already present as is, no error will be raised and no action will be taken. \n\nPaths are searched later in the order of their appearance in the list. As they are added to the front of the list they are searched in reverse order of addition. In other words, the paths added last are looked at first. \n\n::tcl::tm::path remove ?path...? Removes the paths from the list of module paths. The command silently ignores all paths which are not on the list. \n\n::tcl::tm::path list Returns a list containing all registered module paths, in the order that they are searched for modules. \n\n::tcl::tm::roots ?path...? Similar to path add, and layered on top of it. This command takes a list of paths, extends each with &#8220;tclX/site-tcl&#8221;, and &#8220;tclX/X.y&#8221;, for major version X of the Tcl interpreter and minor version y less than or equal to the minor version of the interpreter, and adds the resulting set of paths to the list of paths to search. \n\n This command is used internally by the system to set up the system-specific default paths. \n\nThe command has been exposed to allow a build system to define additional root paths beyond those described by this document. \n\n "));
		docs.put("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", new TCLDoc("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", "standard library of Tcl procedures",""));
		docs.put("foreach", new TCLDoc("foreach", "Iterate over all elements in one or more lists"," The foreach command implements a loop where the loop variable(s) take on values from one or more lists. In the simplest case there is one loop variable, varname, and one list, list, that is a list of values to assign to varname. The body argument is a Tcl script. For each element of list (in order from first to last), foreach assigns the contents of the element to varname as if the lindex command had been used to extract the element, then calls the Tcl interpreter to execute body. \n\n In the general case there can be more than one value list (e.g., list1 and list2), and each value list can be associated with a list of loop variables (e.g., varlist1 and varlist2). During each iteration of the loop the variables of each varlist are assigned consecutive values from the corresponding list. Values in each list are used in order from first to last, and each value is used exactly once. The total number of loop iterations is large enough to use up all the values from all the value lists. If a value list does not contain enough elements for each of its loop variables in each iteration, empty values are used for the missing elements. \n\n The break and continue statements may be invoked inside body, with the same effect as in the for command.  Foreach returns an empty string. "));
		docs.put("namespace", new TCLDoc("namespace", "create and manipulate contexts for commands and variables"," The namespace command lets you create, access, and destroy separate contexts for commands and variables. See the section WHAT IS A NAMESPACE? below for a brief overview of namespaces. The legal values of subcommand are listed below. Note that you can abbreviate the subcommands. \n\n  namespace children ?namespace? ?pattern? Returns a list of all child namespaces that belong to the namespace namespace. If namespace is not specified, then the children are returned for the current namespace. This command returns fully-qualified names, which start with a double colon (::). If the optional pattern is given, then this command returns only the names that match the glob-style pattern. The actual pattern used is determined as follows: a pattern that starts with double colon (::) is used directly, otherwise the namespace namespace (or the fully-qualified name of the current namespace) is prepended onto the pattern. \n\nnamespace code script Captures the current namespace context for later execution of the script script. It returns a new script in which script has been wrapped in a namespace inscope command. The new script has two important properties. First, it can be evaluated in any namespace and will cause script to be evaluated in the current namespace (the one where the namespace code command was invoked). Second, additional arguments can be appended to the resulting script and they will be passed to script as additional arguments. For example, suppose the command set script [namespace code {foo bar}] is invoked in namespace ::a::b. Then eval $script [list x y] can be executed in any namespace (assuming the value of script has been passed in properly) and will have the same effect as the command ::namespace eval ::a::b {foo bar x y}. This command is needed because extensions like Tk normally execute callback scripts in the global namespace. A scoped command captures a command together with its namespace context in a way that allows it to be executed properly later. See the section SCOPED SCRIPTS for some examples of how this is used to create callback scripts. \n\nnamespace current Returns the fully-qualified name for the current namespace. The actual name of the global namespace is &#8220;&#8221; (i.e., an empty string), but this command returns :: for the global namespace as a convenience to programmers. \n\nnamespace delete ?namespace namespace ...? Each namespace namespace is deleted and all variables, procedures, and child namespaces contained in the namespace are deleted. If a procedure is currently executing inside the namespace, the namespace will be kept alive until the procedure returns; however, the namespace is marked to prevent other code from looking it up by name. If a namespace does not exist, this command returns an error. If no namespace names are given, this command does nothing. \n\nnamespace ensemble subcommand ?arg ...? Creates and manipulates a command that is formed out of an ensemble of subcommands.  See the section ENSEMBLES below for further details. \n\nnamespace eval namespace arg ?arg ...? Activates a namespace called namespace and evaluates some code in that context. If the namespace does not already exist, it is created. If more than one arg argument is specified, the arguments are concatenated together with a space between each one in the same fashion as the eval command, and the result is evaluated. \n\n If namespace has leading namespace qualifiers and any leading namespaces do not exist, they are automatically created. \n\nnamespace exists namespace Returns 1 if namespace is a valid namespace in the current context, returns 0 otherwise. \n\nnamespace export ?-clear? ?pattern pattern ...? Specifies which commands are exported from a namespace. The exported commands are those that can be later imported into another namespace using a namespace import command. Both commands defined in a namespace and commands the namespace has previously imported can be exported by a namespace. The commands do not have to be defined at the time the namespace export command is executed. Each pattern may contain glob-style special characters, but it may not include any namespace qualifiers. That is, the pattern can only specify commands in the current (exporting) namespace. Each pattern is appended onto the namespace\'s list of export patterns. If the -clear flag is given, the namespace\'s export pattern list is reset to empty before any pattern arguments are appended. If no patterns are given and the -clear flag is not given, this command returns the namespace\'s current export list. \n\nnamespace forget ?pattern pattern ...? Removes previously imported commands from a namespace. Each pattern is a simple or qualified name such as x, foo::x or a::b::p*. Qualified names contain double colons (::) and qualify a name with the name of one or more namespaces. Each &#8220;qualified pattern&#8221; is qualified with the name of an exporting namespace and may have glob-style special characters in the command name at the end of the qualified name. Glob characters may not appear in a namespace name. For each &#8220;simple pattern&#8221; this command deletes the matching commands of the current namespace that were imported from a different namespace. For &#8220;qualified patterns&#8221;, this command first finds the matching exported commands. It then checks whether any of those commands were previously imported by the current namespace. If so, this command deletes the corresponding imported commands. In effect, this un-does the action of a namespace import command. \n\nnamespace import ?-force? ?pattern pattern ...? Imports commands into a namespace, or queries the set of imported commands in a namespace.  When no arguments are present, namespace import returns the list of commands in the current namespace that have been imported from other namespaces.  The commands in the returned list are in the format of simple names, with no namespace qualifiers at all. This format is suitable for composition with namespace forget (see EXAMPLES below). \n\n When pattern arguments are present, each pattern is a qualified name like foo::x or a::p*. That is, it includes the name of an exporting namespace and may have glob-style special characters in the command name at the end of the qualified name. Glob characters may not appear in a namespace name. When the namespace name is not fully qualified (i.e., does not start with a namespace separator) it is resolved as a namespace name in the way described in the NAME RESOLUTION section; it is an error if no namespace with that name can be found. \n\nAll the commands that match a pattern string and which are currently exported from their namespace are added to the current namespace. This is done by creating a new command in the current namespace that points to the exported command in its original namespace; when the new imported command is called, it invokes the exported command. This command normally returns an error if an imported command conflicts with an existing command. However, if the -force option is given, imported commands will silently replace existing commands. The namespace import command has snapshot semantics: that is, only requested commands that are currently defined in the exporting namespace are imported. In other words, you can import only the commands that are in a namespace at the time when the namespace import command is executed. If another command is defined and exported in this namespace later on, it will not be imported. \n\nnamespace inscope namespace script ?arg ...? Executes a script in the context of the specified namespace. This command is not expected to be used directly by programmers; calls to it are generated implicitly when applications use namespace code commands to create callback scripts that the applications then register with, e.g., Tk widgets. The namespace inscope command is much like the namespace eval command except that the namespace must already exist, and namespace inscope appends additional args as proper list elements. \n\n namespace inscope ::foo $script $x $y $z \n\n is equivalent to \n\n namespace eval ::foo [concat $script [list $x $y $z]] \n\nthus additional arguments will not undergo a second round of substitution, as is the case with namespace eval. \n\nnamespace origin command Returns the fully-qualified name of the original command to which the imported command command refers. When a command is imported into a namespace, a new command is created in that namespace that points to the actual command in the exporting namespace. If a command is imported into a sequence of namespaces a, b,...,n where each successive namespace just imports the command from the previous namespace, this command returns the fully-qualified name of the original command in the first namespace, a. If command does not refer to an imported command, the command\'s own fully-qualified name is returned. \n\nnamespace parent ?namespace? Returns the fully-qualified name of the parent namespace for namespace namespace. If namespace is not specified, the fully-qualified name of the current namespace\'s parent is returned. \n\nnamespace path ?namespaceList? Returns the command resolution path of the current namespace. If namespaceList is specified as a list of named namespaces, the current namespace\'s command resolution path is set to those namespaces and returns the empty list. The default command resolution path is always empty. See the section NAME RESOLUTION below for an explanation of the rules regarding name resolution. \n\nnamespace qualifiers string Returns any leading namespace qualifiers for string. Qualifiers are namespace names separated by double colons (::). For the string ::foo::bar::x, this command returns ::foo::bar, and for :: it returns an empty string. This command is the complement of the namespace tail command. Note that it does not check whether the namespace names are, in fact, the names of currently defined namespaces. \n\nnamespace tail string Returns the simple name at the end of a qualified string. Qualifiers are namespace names separated by double colons (::). For the string ::foo::bar::x, this command returns x, and for :: it returns an empty string. This command is the complement of the namespace qualifiers command. It does not check whether the namespace names are, in fact, the names of currently defined namespaces. \n\nnamespace upvar namespace ?otherVar myVar ... This command arranges for zero or more local variables in the current procedure to refer to variables in namespace. The namespace name is resolved as described in section NAME RESOLUTION. The command namespace upvar $ns a b has the same behaviour as upvar 0 ${ns}::a b, with the sole exception of the resolution rules used for qualified namespace or variable names. namespace upvar returns an empty string. \n\nnamespace unknown ?script? Sets or returns the unknown command handler for the current namespace. The handler is invoked when a command called from within the namespace cannot be found in the current namespace, the namespace\'s path nor in the global namespace.  The script argument, if given, should be a well formed list representing a command name and optional arguments. When the handler is invoked, the full invocation line will be appended to the script and the result evaluated in the context of the namespace. The default handler for all namespaces is ::unknown. If no argument is given, it returns the handler for the current namespace. \n\nnamespace which ?-command? ?-variable? name Looks up name as either a command or variable and returns its fully-qualified name. For example, if name does not exist in the current namespace but does exist in the global namespace, this command returns a fully-qualified name in the global namespace. If the command or variable does not exist, this command returns an empty string.  If the variable has been created but not defined, such as with the variable command or through a trace on the variable, this command will return the fully-qualified name of the variable. If no flag is given, name is treated as a command name. See the section NAME RESOLUTION below for an explanation of the rules regarding name resolution. \n\n "));
		docs.put("socket", new TCLDoc("socket", "Open a TCP network connection"," This command opens a network socket and returns a channel identifier that may be used in future invocations of commands like read, puts and flush.  At present only the TCP network protocol is supported over IPv4 and IPv6; future releases may include support for additional protocols.  The socket command may be used to open either the client or server side of a connection, depending on whether the -server switch is specified. \n\n Note that the default encoding for all sockets is the system encoding, as returned by encoding system.  Most of the time, you will need to use chan configure to alter this to something else, such as utf-8 (ideal for communicating with other Tcl processes) or iso8859-1 (useful for many network protocols, especially the older ones). "));
		docs.put("trace", new TCLDoc("trace", "Monitor variable accesses, command usages and command executions"," This command causes Tcl commands to be executed whenever certain operations are invoked.  The legal options (which may be abbreviated) are: \n\n  trace add type name ops ?args? Where type is command, execution, or variable. \n\n  trace add command name ops commandPrefix Arrange for commandPrefix to be executed (with additional arguments) whenever command name is modified in one of the ways given by the list ops. Name will be resolved using the usual namespace resolution rules used by commands. If the command does not exist, an error will be thrown. \n\n Ops indicates which operations are of interest, and is a list of one or more of the following items: \n\n  rename Invoke commandPrefix whenever the traced command is renamed.  Note that renaming to the empty string is considered deletion, and will not be traced with &#8220;rename&#8221;. \n\ndelete Invoke commandPrefix when the traced command is deleted. Commands can be deleted explicitly by using the rename command to rename the command to an empty string. Commands are also deleted when the interpreter is deleted, but traces will not be invoked because there is no interpreter in which to execute them. \n\n \n\n When the trace triggers, depending on the operations being traced, a number of arguments are appended to commandPrefix so that the actual command is as follows: \n\n commandPrefix oldName newName op \n\nOldName and newName give the traced command\'s current (old) name, and the name to which it is being renamed (the empty string if this is a &#8220;delete&#8221; operation). Op indicates what operation is being performed on the command, and is one of rename or delete as defined above.  The trace operation cannot be used to stop a command from being deleted.  Tcl will always remove the command once the trace is complete.  Recursive renaming or deleting will not cause further traces of the same type to be evaluated, so a delete trace which itself deletes the command, or a rename trace which itself renames the command will not cause further trace evaluations to occur. Both oldName and newName are fully qualified with any namespace(s) in which they appear. \n\ntrace add execution name ops commandPrefix Arrange for commandPrefix to be executed (with additional arguments) whenever command name is executed, with traces occurring at the points indicated by the list ops.  Name will be resolved using the usual namespace resolution rules used by commands.  If the command does not exist, an error will be thrown. \n\n Ops indicates which operations are of interest, and is a list of one or more of the following items: \n\n  enter Invoke commandPrefix whenever the command name is executed, just before the actual execution takes place. \n\nleave Invoke commandPrefix whenever the command name is executed, just after the actual execution takes place. \n\nenterstep Invoke commandPrefix for every Tcl command which is executed from the start of the execution of the procedure name until that procedure finishes. CommandPrefix is invoked just before the actual execution of the Tcl command being reported takes place.  For example if we have &#8220;proc foo {} { puts \"hello\" }&#8221;, then an enterstep trace would be invoked just before &#8220;puts \"hello\"&#8221; is executed. Setting an enterstep trace on a command name that does not refer to a procedure will not result in an error and is simply ignored. \n\nleavestep Invoke commandPrefix for every Tcl command which is executed from the start of the execution of the procedure name until that procedure finishes. CommandPrefix is invoked just after the actual execution of the Tcl command being reported takes place. Setting a leavestep trace on a command name that does not refer to a procedure will not result in an error and is simply ignored. \n\n \n\n When the trace triggers, depending on the operations being traced, a number of arguments are appended to commandPrefix so that the actual command is as follows: \n\n For enter and enterstep operations: \n\n commandPrefix command-string op \n\n Command-string gives the complete current command being executed (the traced command for a enter operation, an arbitrary command for a enterstep operation), including all arguments in their fully expanded form. Op indicates what operation is being performed on the command execution, and is one of enter or enterstep as defined above.  The trace operation can be used to stop the command from executing, by deleting the command in question.  Of course when the command is subsequently executed, an &#8220;invalid command&#8221; error will occur. \n\n For leave and leavestep operations: \n\n commandPrefix command-string code result op \n\n Command-string gives the complete current command being executed (the traced command for a enter operation, an arbitrary command for a enterstep operation), including all arguments in their fully expanded form. Code gives the result code of that execution, and result the result string. Op indicates what operation is being performed on the command execution, and is one of leave or leavestep as defined above. Note that the creation of many enterstep or leavestep traces can lead to unintuitive results, since the invoked commands from one trace can themselves lead to further command invocations for other traces. \n\n CommandPrefix executes in the same context as the code that invoked the traced operation: thus the commandPrefix, if invoked from a procedure, will have access to the same local variables as code in the procedure. This context may be different than the context in which the trace was created. If commandPrefix invokes a procedure (which it normally does) then the procedure will have to use upvar or uplevel commands if it wishes to access the local variables of the code which invoked the trace operation. \n\n While commandPrefix is executing during an execution trace, traces on name are temporarily disabled. This allows the commandPrefix to execute name in its body without invoking any other traces again. If an error occurs while executing the commandPrefix, then the command name as a whole will return that same error. \n\n When multiple traces are set on name, then for enter and enterstep operations, the traced commands are invoked in the reverse order of how the traces were originally created; and for leave and leavestep operations, the traced commands are invoked in the original order of creation. \n\nThe behavior of execution traces is currently undefined for a command name imported into another namespace. \n\ntrace add variable name ops commandPrefix Arrange for commandPrefix to be executed whenever variable name is accessed in one of the ways given by the list ops.  Name may refer to a normal variable, an element of an array, or to an array as a whole (i.e. name may be just the name of an array, with no parenthesized index).  If name refers to a whole array, then commandPrefix is invoked whenever any element of the array is manipulated.  If the variable does not exist, it will be created but will not be given a value, so it will be visible to namespace which queries, but not to info exists queries. \n\n Ops indicates which operations are of interest, and is a list of one or more of the following items: \n\n  array Invoke commandPrefix whenever the variable is accessed or modified via the array command, provided that name is not a scalar variable at the time that the array command is invoked.  If name is a scalar variable, the access via the array command will not trigger the trace. \n\nread Invoke commandPrefix whenever the variable is read. \n\nwrite Invoke commandPrefix whenever the variable is written. \n\nunset Invoke commandPrefix whenever the variable is unset.  Variables can be unset explicitly with the unset command, or implicitly when procedures return (all of their local variables are unset).  Variables are also unset when interpreters are deleted, but traces will not be invoked because there is no interpreter in which to execute them. \n\n \n\n When the trace triggers, three arguments are appended to commandPrefix so that the actual command is as follows: \n\n commandPrefix name1 name2 op \n\n Name1 and name2 give the name(s) for the variable being accessed:  if the variable is a scalar then name1 gives the variable\'s name and name2 is an empty string; if the variable is an array element then name1 gives the name of the array and name2 gives the index into the array; if an entire array is being deleted and the trace was registered on the overall array, rather than a single element, then name1 gives the array name and name2 is an empty string. Name1 and name2 are not necessarily the same as the name used in the trace variable command:  the upvar command allows a procedure to reference a variable under a different name. Op indicates what operation is being performed on the variable, and is one of read, write, or unset as defined above. \n\n CommandPrefix executes in the same context as the code that invoked the traced operation:  if the variable was accessed as part of a Tcl procedure, then commandPrefix will have access to the same local variables as code in the procedure.  This context may be different than the context in which the trace was created. If commandPrefix invokes a procedure (which it normally does) then the procedure will have to use upvar or uplevel if it wishes to access the traced variable.  Note also that name1 may not necessarily be the same as the name used to set the trace on the variable; differences can occur if the access is made through a variable defined with the upvar command. \n\n For read and write traces, commandPrefix can modify the variable to affect the result of the traced operation.  If commandPrefix modifies the value of a variable during a read or write trace, then the new value will be returned as the result of the traced operation.  The return value from  commandPrefix is ignored except that if it returns an error of any sort then the traced operation also returns an error with the same error message returned by the trace command (this mechanism can be used to implement read-only variables, for example). For write traces, commandPrefix is invoked after the variable\'s value has been changed; it can write a new value into the variable to override the original value specified in the write operation.  To implement read-only variables, commandPrefix will have to restore the old value of the variable. \n\n While commandPrefix is executing during a read or write trace, traces on the variable are temporarily disabled.  This means that reads and writes invoked by commandPrefix will occur directly, without invoking commandPrefix (or any other traces) again.  However, if commandPrefix unsets the variable then unset traces will be invoked. \n\n When an unset trace is invoked, the variable has already been deleted: it will appear to be undefined with no traces.  If an unset occurs because of a procedure return, then the trace will be invoked in the variable context of the procedure being returned to:  the stack frame of the returning procedure will no longer exist.  Traces are not disabled during unset traces, so if an unset trace command creates a new trace and accesses the variable, the trace will be invoked.  Any errors in unset traces are ignored. \n\n If there are multiple traces on a variable they are invoked in order of creation, most-recent first.  If one trace returns an error, then no further traces are invoked for the variable.  If an array element has a trace set, and there is also a trace set on the array as a whole, the trace on the overall array is invoked before the one on the element. \n\n Once created, the trace remains in effect either until the trace is removed with the trace remove variable command described below, until the variable is unset, or until the interpreter is deleted. Unsetting an element of array will remove any traces on that element, but will not remove traces on the overall array. \n\nThis command returns an empty string. \n\n \n\ntrace remove type name opList commandPrefix Where type is either command, execution or variable. \n\n  trace remove command name opList commandPrefix If there is a trace set on command name with the operations and command given by opList and commandPrefix, then the trace is removed, so that commandPrefix will never again be invoked.  Returns an empty string.   If name does not exist, the command will throw an error. \n\ntrace remove execution name opList commandPrefix If there is a trace set on command name with the operations and command given by opList and commandPrefix, then the trace is removed, so that commandPrefix will never again be invoked.  Returns an empty string.   If name does not exist, the command will throw an error. \n\ntrace remove variable name opList commandPrefix If there is a trace set on variable name with the operations and command given by opList and commandPrefix, then the trace is removed, so that commandPrefix will never again be invoked.  Returns an empty string. \n\n \n\ntrace info type name Where type is either command, execution or variable. \n\n  trace info command name Returns a list containing one element for each trace currently set on command name. Each element of the list is itself a list containing two elements, which are the opList and commandPrefix associated with the trace.  If name does not have any traces set, then the result of the command will be an empty string.  If name does not exist, the command will throw an error. \n\ntrace info execution name Returns a list containing one element for each trace currently set on command name. Each element of the list is itself a list containing two elements, which are the opList and commandPrefix associated with the trace.  If name does not have any traces set, then the result of the command will be an empty string.  If name does not exist, the command will throw an error. \n\ntrace info variable name Returns a list containing one element for each trace currently set on variable name.  Each element of the list is itself a list containing two elements, which are the opList and commandPrefix associated with the trace.  If name does not exist or does not have any traces set, then the result of the command will be an empty string. \n\n \n\n \n\n For backwards compatibility, three other subcommands are available: \n\n  trace variable name ops command This is equivalent to trace add variable name ops command. \n\ntrace vdelete name ops command This is equivalent to trace remove variable name ops command \n\ntrace vinfo name This is equivalent to trace info variable name \n\n \n\n These subcommands are deprecated and will likely be removed in a future version of Tcl.  They use an older syntax in which array, read, write, unset are replaced by a, r, w and u respectively, and the ops argument is not a list, but simply a string concatenation of the operations, such as rwua. "));
		docs.put("bgerror", new TCLDoc("bgerror", "Command invoked to process background errors"," Release 8.5 of Tcl supports the interp bgerror command, which allows applications to register in an interpreter the command that will handle background errors in that interpreter.  In older releases of Tcl, this level of control was not available, and applications could control the handling of background errors only by creating a command with the particular command name bgerror in the global namespace of an interpreter.  The following documentation describes the interface requirements of the bgerror command an application might define to retain compatibility with pre-8.5 releases of Tcl.  Applications intending to support only Tcl releases 8.5 and later should simply make use of interp bgerror. \n\n The bgerror command does not exist as built-in part of Tcl.  Instead, individual applications or users can define a bgerror command (e.g. as a Tcl procedure) if they wish to handle background errors. \n\n A background error is one that occurs in an event handler or some other command that did not originate with the application. For example, if an error occurs while executing a command specified with the after command, then it is a background error. For a non-background error, the error can simply be returned up through nested Tcl command evaluations until it reaches the top-level code in the application; then the application can report the error in whatever way it wishes.  When a background error occurs, the unwinding ends in the Tcl library and there is no obvious way for Tcl to report the error. \n\n When Tcl detects a background error, it saves information about the error and invokes a handler command registered by interp bgerror later as an idle event handler.  The default handler command in turn calls the bgerror command . Before invoking bgerror, Tcl restores the errorInfo and errorCode variables to their values at the time the error occurred, then it invokes bgerror with the error message as its only argument.  Tcl assumes that the application has implemented the bgerror command, and that the command will report the error in a way that makes sense for the application.  Tcl will ignore any result returned by the bgerror command as long as no error is generated. \n\n If another Tcl error occurs within the bgerror command (for example, because no bgerror command has been defined) then Tcl reports the error itself by writing a message to stderr. \n\n If several background errors accumulate before bgerror is invoked to process them, bgerror will be invoked once for each error, in the order they occurred.  However, if bgerror returns with a break exception, then any remaining errors are skipped without calling bgerror. \n\n If you are writing code that will be used by others as part of a package or other kind of library, consider avoiding bgerror. The reason for this is that the application programmer may also want to define a bgerror, or use other code that does and thus will have trouble integrating your code. "));
		docs.put("format", new TCLDoc("format", "Format a string in the style of sprintf",""));
		docs.put("next, nextto", new TCLDoc("next, nextto", "invoke superclass method implementations"," The next command is used to call implementations of a method by a class, superclass or mixin that are overridden by the current method. It can only be used from within a method. It is also used within filters to indicate the point where a filter calls the actual implementation (the filter may decide to not go along the chain, and may process the results of going along the chain of methods as it chooses). The result of the next command is the result of the next method in the method chain; if there are no further methods in the method chain, the result of next will be an error. The arguments, arg, to next are the arguments to pass to the next method in the chain. \n\n The nextto command is the same as the next command, except that it takes an additional class argument that identifies a class whose implementation of the current method chain (see info object call) should be used; the method implementation selected will be the one provided by the given class, and it must refer to an existing non-filter invocation that lies further along the chain than the current implementation. "));
		docs.put("source", new TCLDoc("source", "Evaluate a file or resource as a Tcl script"," This command takes the contents of the specified file or resource and passes it to the Tcl interpreter as a text script.  The return value from source is the return value of the last command executed in the script.  If an error occurs in evaluating the contents of the script then the source command will return that error. If a return command is invoked from within the script then the remainder of the file will be skipped and the source command will return normally with the result from the return command. \n\n The end-of-file character for files is &#8220;\\32&#8221; (^Z) for all platforms. The source command will read files up to this character.  This restriction does not exist for the read or gets commands, allowing for files containing code and data segments (scripted documents). If you require a &#8220;^Z&#8221; in code for string comparison, you can use &#8220;\\032&#8221; or &#8220;\\u001a&#8221;, which will be safely substituted by the Tcl interpreter into &#8220;^Z&#8221;. \n\n The -encoding option is used to specify the encoding of the data stored in fileName.  When the -encoding option is omitted, the system encoding is assumed. "));
		docs.put("transchan", new TCLDoc("transchan", "command handler API of channel transforms"," The Tcl-level handler for a channel transformation has to be a command with subcommands (termed an ensemble despite not implying that it must be created with namespace ensemble create; this mechanism is not tied to namespace ensemble in any way). Note that cmdPrefix is whatever was specified in the call to chan push, and may consist of multiple arguments; this will be expanded to multiple words in place of the prefix. \n\n Of all the possible subcommands, the handler must support initialize and finalize. Transformations for writable channels must also support write, and transformations for readable channels must also support read. \n\n Note that in the descriptions below cmdPrefix may be more than one word, and handle is the value returned by the chan push call used to create the transformation. GENERIC SUBCOMMANDS The following subcommands are relevant to all types of channel. \n\n  cmdPrefix clear handle This optional subcommand is called to signify to the transformation that any data stored in internal buffers (either incoming or outgoing) must be cleared. It is called when a chan seek is performed on the channel being transformed. \n\ncmdPrefix finalize handle This mandatory subcommand is called last for the given handle, and then never again, and it exists to allow for cleaning up any Tcl-level data structures associated with the transformation. Warning! Any errors thrown by this subcommand will be ignored. It is not guaranteed to be called if the interpreter is deleted. \n\ncmdPrefix initialize handle mode This mandatory subcommand is called first, and then never again (for the given handle). Its responsibility is to initialize all parts of the transformation at the Tcl level. The mode is a list containing any of read and write. \n\n  write implies that the channel is writable. \n\nread implies that the channel is readable. \n\nThe return value of the subcommand should be a list containing the names of all subcommands supported by this handler. Any error thrown by the subcommand will prevent the creation of the transformation. The thrown error will appear as error thrown by chan push.  \n\n READ-RELATED SUBCOMMANDS These subcommands are used for handling transformations applied to readable channels; though strictly read is optional, it must be supported if any of the others is or the channel will be made non-readable. \n\n  cmdPrefix drain handle This optional subcommand is called whenever data in the transformation input (i.e. read) buffer has to be forced upward, i.e. towards the user or script. The result returned by the method is taken as the binary data to push upward to the level above this transformation (the reader or a higher-level transformation). \n\n In other words, when this method is called the transformation cannot defer the actual transformation operation anymore and has to transform all data waiting in its internal read buffers and return the result of that action. \n\ncmdPrefix limit? handle This optional subcommand is called to allow the Tcl I/O engine to determine how far ahead it should read. If present, it should return an integer number greater than zero which indicates how many bytes ahead should be read, or an integer less than zero to indicate that the I/O engine may read as far ahead as it likes. \n\ncmdPrefix read handle buffer This subcommand, which must be present if the transformation is to work with readable channels, is called whenever the base channel, or a transformation below this transformation, pushes data upward. The buffer contains the binary data which has been given to us from below. It is the responsibility of this subcommand to actually transform the data. The result returned by the subcommand is taken as the binary data to push further upward to the transformation above this transformation. This can also be the user or script that originally read from the channel. \n\n Note that the result is allowed to be empty, or even less than the data we received; the transformation is not required to transform everything given to it right now. It is allowed to store incoming data in internal buffers and to defer the actual transformation until it has more data. \n\n WRITE-RELATED SUBCOMMANDS These subcommands are used for handling transformations applied to writable channels; though strictly write is optional, it must be supported if any of the others is or the channel will be made non-writable. \n\n  cmdPrefix flush handle This optional subcommand is called whenever data in the transformation \'write\' buffer has to be forced downward, i.e. towards the base channel. The result returned by the subcommand is taken as the binary data to write to the transformation below the current transformation. This can be the base channel as well. \n\n In other words, when this subcommand is called the transformation cannot defer the actual transformation operation anymore and has to transform all data waiting in its internal write buffers and return the result of that action. \n\ncmdPrefix write handle buffer This subcommand, which must be present if the transformation is to work with writable channels, is called whenever the user, or a transformation above this transformation, writes data downward. The buffer contains the binary data which has been written to us. It is the responsibility of this subcommand to actually transform the data. \n\n The result returned by the subcommand is taken as the binary data to write to the transformation below this transformation. This can be the base channel as well. Note that the result is allowed to be empty, or less than the data we got; the transformation is not required to transform everything which was written to it right now. It is allowed to store this data in internal buffers and to defer the actual transformation until it has more data. \n\n "));
		docs.put("binary", new TCLDoc("binary", "Insert and extract fields from binary strings"," This command provides facilities for manipulating binary data.  The subcommand binary format creates a binary string from normal Tcl values.  For example, given the values 16 and 22, on a 32-bit architecture, it might produce an 8-byte binary string consisting of two 4-byte integers, one for each of the numbers.  The subcommand binary scan, does the opposite: it extracts data from a binary string and returns it as ordinary Tcl string values. The binary encode and binary decode subcommands convert binary data to or from string encodings such as base64 (used in MIME messages for example). "));
		docs.put("gets", new TCLDoc("gets", "Read a line from a channel"," This command reads the next line from channelId, returns everything in the line up to (but not including) the end-of-line character(s), and discards the end-of-line character(s). \n\n ChannelId must be an identifier for an open channel such as the Tcl standard input channel (stdin), the return value from an invocation of open or socket, or the result of a channel creation command provided by a Tcl extension. The channel must have been opened for input. \n\n If varName is omitted the line is returned as the result of the command. If varName is specified then the line is placed in the variable by that name and the return value is a count of the number of characters returned. \n\n If end of file occurs while scanning for an end of line, the command returns whatever input is available up to the end of file. If channelId is in non-blocking mode and there is not a full line of input available, the command returns an empty string and does not consume any input. If varName is specified and an empty string is returned in varName because of end-of-file or because of insufficient data in non-blocking mode, then the return count is -1. Note that if varName is not specified then the end-of-file and no-full-line-available cases can produce the same results as if there were an input line consisting only of the end-of-line character(s). The eof and fblocked commands can be used to distinguish these three cases. "));
		docs.put("next, nextto", new TCLDoc("next, nextto", "invoke superclass method implementations"," The next command is used to call implementations of a method by a class, superclass or mixin that are overridden by the current method. It can only be used from within a method. It is also used within filters to indicate the point where a filter calls the actual implementation (the filter may decide to not go along the chain, and may process the results of going along the chain of methods as it chooses). The result of the next command is the result of the next method in the method chain; if there are no further methods in the method chain, the result of next will be an error. The arguments, arg, to next are the arguments to pass to the next method in the chain. \n\n The nextto command is the same as the next command, except that it takes an additional class argument that identifies a class whose implementation of the current method chain (see info object call) should be used; the method implementation selected will be the one provided by the given class, and it must refer to an existing non-filter invocation that lies further along the chain than the current implementation. "));
		docs.put("split", new TCLDoc("split", "Split a string into a proper Tcl list"," Returns a list created by splitting string at each character that is in the splitChars argument. Each element of the result list will consist of the characters from string that lie between instances of the characters in splitChars. Empty list elements will be generated if string contains adjacent characters in splitChars, or if the first or last character of string is in splitChars. If splitChars is an empty string then each character of string becomes a separate element of the result list. SplitChars defaults to the standard white-space characters. "));
		docs.put("try", new TCLDoc("try", "Trap and process errors and exceptions"," This command executes the script body and, depending on what the outcome of that script is (normal exit, error, or some other exceptional result), runs a handler script to deal with the case. Once that has all happened, if the finally clause is present, the script it includes will be run and the result of the handler (or the body if no handler matched) is allowed to continue to propagate. Note that the finally clause is processed even if an error occurs and irrespective of which, if any, handler is used. \n\n The handler clauses are each expressed as several words, and must have one of the following forms: \n\n  on code variableList script This clause matches if the evaluation of body completed with the exception code code. The code may be expressed as an integer or one of the following literal words: ok, error, return, break, or continue. Those literals correspond to the integers 0 through 4 respectively. \n\ntrap pattern variableList script This clause matches if the evaluation of body resulted in an error and the prefix of the -errorcode from the interpreter\'s status dictionary is equal to the pattern. The number of prefix words taken from the -errorcode is equal to the list-length of pattern, and inter-word spaces are normalized in both the -errorcode and pattern before comparison. \n\n \n\n The variableList word in each handler is always interpreted as a list of variable names. If the first word of the list is present and non-empty, it names a variable into which the result of the evaluation of body (from the main try) will be placed; this will contain the human-readable form of any errors. If the second word of the list is present and non-empty, it names a variable into which the options dictionary of the interpreter at the moment of completion of execution of body will be placed. \n\n The script word of each handler is also always interpreted the same: as a Tcl script to evaluate if the clause is matched. If script is a literal &#8220;-&#8221; and the handler is not the last one, the script of the following handler is invoked instead (just like with the switch command). \n\n Note that handler clauses are matched against in order, and that the first matching one is always selected. At most one handler clause will selected. As a consequence, an on error will mask any subsequent trap in the try. Also note that on error is equivalent to trap {}. \n\n If an exception (i.e. any non-ok result) occurs during the evaluation of either the handler or the finally clause, the original exception\'s status dictionary will be added to the new exception\'s status dictionary under the -during key. "));
		docs.put("break", new TCLDoc("break", "Abort looping command"," This command is typically invoked inside the body of a looping command such as for or foreach or while. It returns a 3 (TCL_BREAK) result code, which causes a break exception to occur. The exception causes the current script to be aborted out to the innermost containing loop command, which then aborts its execution and returns normally. Break exceptions are also handled in a few other situations, such as the catch command, Tk event bindings, and the outermost scripts of procedure bodies. "));
		docs.put("glob", new TCLDoc("glob", "Return names of files that match patterns"," This command performs file name &#8220;globbing&#8221; in a fashion similar to the csh shell or bash shell. It returns a list of the files whose names match any of the pattern arguments. No particular order is guaranteed in the list, so if a sorted list is required the caller should use lsort. OPTIONS If the initial arguments to glob start with - then they are treated as switches. The following switches are currently supported: \n\n  -directory directory Search for files which match the given patterns starting in the given directory. This allows searching of directories whose name contains glob-sensitive characters without the need to quote such characters explicitly. This option may not be used in conjunction with -path, which is used to allow searching for complete file paths whose names may contain glob-sensitive characters. \n\n-join The remaining pattern arguments, after option processing, are treated as a single pattern obtained by joining the arguments with directory separators. \n\n-nocomplain Allows an empty list to be returned without error; without this switch an error is returned if the result list would be empty. \n\n-path pathPrefix Search for files with the given pathPrefix where the rest of the name matches the given patterns. This allows searching for files with names similar to a given file (as opposed to a directory) even when the names contain glob-sensitive characters. This option may not be used in conjunction with -directory. For example, to find all files with the same root name as $path, but differing extensions, you should use &#8220;glob -path [file rootname $path] .*&#8221; which will work even if $path contains numerous glob-sensitive characters. \n\n-tails Only return the part of each file found which follows the last directory named in any -directory or -path path specification. Thus &#8220;glob -tails -directory $dir *&#8221; is equivalent to &#8220;set pwd [pwd]; cd $dir; glob *; cd $pwd&#8221;. For -path specifications, the returned names will include the last path segment, so &#8220;glob -tails -path [file rootname ~/foo.tex] .*&#8221; will return paths like foo.aux foo.bib foo.tex etc. \n\n-types typeList Only list files or directories which match typeList, where the items in the list have two forms. The first form is like the -type option of the Unix find command: b (block special file), c (character special file), d (directory), f (plain file), l (symbolic link), p (named pipe), or s (socket), where multiple types may be specified in the list. Glob will return all files which match at least one of the types given. Note that symbolic links will be returned both if -types l is given, or if the target of a link matches the requested type. So, a link to a directory will be returned if -types d was specified. \n\n The second form specifies types where all the types given must match. These are r, w, x as file permissions, and readonly, hidden as special permission cases. On the Macintosh, MacOS types and creators are also supported, where any item which is four characters long is assumed to be a MacOS type (e.g. TEXT). Items which are of the form {macintosh type XXXX} or {macintosh creator XXXX} will match types or creators respectively. Unrecognized types, or specifications of multiple MacOS types/creators will signal an error. \n\n The two forms may be mixed, so -types {d f r w} will find all regular files OR directories that have both read AND write permissions. The following are equivalent: \n\n glob -type d * glob */ \n\nexcept that the first case doesn\'t return the trailing &#8220;/&#8221; and is more platform independent. \n\n-- Marks the end of switches. The argument following this one will be treated as a pattern even if it starts with a -. \n\n GLOBBING PATTERNS The pattern arguments may contain any of the following special characters, which are a superset of those supported by string match: \n\n  ? Matches any single character. \n\n* Matches any sequence of zero or more characters. \n\n[chars] Matches any single character in chars. If chars contains a sequence of the form a-b then any character between a and b (inclusive) will match. \n\n\\x Matches the character x. \n\n{a,b,...} Matches any of the sub-patterns a, b, etc. \n\n \n\n On Unix, as with csh, a &#8220;.&#8221;  at the beginning of a file\'s name or just after a &#8220;/&#8221; must be matched explicitly or with a {} construct, unless the -types hidden flag is given (since &#8220;.&#8221;  at the beginning of a file\'s name indicates that it is hidden). On other platforms, files beginning with a &#8220;.&#8221;  are handled no differently to any others, except the special directories &#8220;.&#8221;  and &#8220;..&#8221;  which must be matched explicitly (this is to avoid a recursive pattern like &#8220;glob -join * * * *&#8221; from recursing up the directory hierarchy as well as down). In addition, all &#8220;/&#8221; characters must be matched explicitly. \n\n If the first character in a pattern is &#8220;~&#8221; then it refers to the home directory for the user whose name follows the &#8220;~&#8221;. If the &#8220;~&#8221; is followed immediately by &#8220;/&#8221; then the value of the HOME environment variable is used. \n\n The glob command differs from csh globbing in two ways. First, it does not sort its result list (use the lsort command if you want the list sorted). Second, glob only returns the names of files that actually exist; in csh no check for existence is made unless a pattern contains a ?, *, or [] construct. \n\n When the glob command returns relative paths whose filenames start with a tilde &#8220;~&#8221; (for example through glob * or glob -tails, the returned list will not quote the tilde with &#8220;./&#8221;. This means care must be taken if those names are later to be used with file join, to avoid them being interpreted as absolute paths pointing to a given user\'s home directory. "));
		docs.put("oo::class", new TCLDoc("oo::class", "class of all classes",""));
		docs.put("string", new TCLDoc("string", "Manipulate strings"," Performs one of several string operations, depending on option. The legal options (which may be abbreviated) are: \n\n  string bytelength string Returns a decimal string giving the number of bytes used to represent string in memory.  Because UTF-8 uses one to three bytes to represent Unicode characters, the byte length will not be the same as the character length in general.  The cases where a script cares about the byte length are rare. \n\n In almost all cases, you should use the string length operation (including determining the length of a Tcl byte array value).  Refer to the Tcl_NumUtfChars manual entry for more details on the UTF-8 representation. \n\nCompatibility note: it is likely that this subcommand will be withdrawn in a future version of Tcl. It is better to use the encoding convertto command to convert a string to a known encoding and then apply string length to that. \n\nstring compare ?-nocase? ?-length int? string1 string2 Perform a character-by-character comparison of strings string1 and string2.  Returns -1, 0, or 1, depending on whether string1 is lexicographically less than, equal to, or greater than string2.  If -length is specified, then only the first length characters are used in the comparison.  If -length is negative, it is ignored.  If -nocase is specified, then the strings are compared in a case-insensitive manner. \n\nstring equal ?-nocase? ?-length int? string1 string2 Perform a character-by-character comparison of strings string1 and string2.  Returns 1 if string1 and string2 are identical, or 0 when not.  If -length is specified, then only the first length characters are used in the comparison.  If -length is negative, it is ignored.  If -nocase is specified, then the strings are compared in a case-insensitive manner. \n\nstring first needleString haystackString ?startIndex? Search haystackString for a sequence of characters that exactly match the characters in needleString.  If found, return the index of the first character in the first such match within haystackString.  If not found, return -1.  If startIndex is specified (in any of the forms described in STRING INDICES), then the search is constrained to start with the character in haystackString specified by the index.  For example, \n\n string first a 0a23456789abcdef 5 \n\n will return 10, but \n\n string first a 0123456789abcdef 11 \n\nwill return -1. \n\nstring index string charIndex Returns the charIndex\'th character of the string argument. A charIndex of 0 corresponds to the first character of the string.  charIndex may be specified as described in the STRING INDICES section. \n\n If charIndex is less than 0 or greater than or equal to the length of the string then this command returns an empty string. \n\nstring is class ?-strict? ?-failindex varname? string Returns 1 if string is a valid member of the specified character class, otherwise returns 0.  If -strict is specified, then an empty string returns 0, otherwise an empty string will return 1 on any class.  If -failindex is specified, then if the function returns 0, the index in the string where the class was no longer valid will be stored in the variable named varname.  The varname will not be set if string is returns 1.  The following character classes are recognized (the class name can be abbreviated): \n\n  alnum Any Unicode alphabet or digit character. \n\nalpha Any Unicode alphabet character. \n\nascii Any character with a value less than \\u0080 (those that are in the 7-bit ascii range). \n\nboolean Any of the forms allowed to Tcl_GetBoolean. \n\ncontrol Any Unicode control character. \n\ndigit Any Unicode digit character.  Note that this includes characters outside of the [0-9] range. \n\ndouble Any of the valid forms for a double in Tcl, with optional surrounding whitespace.  In case of under/overflow in the value, 0 is returned and the varname will contain -1. \n\nentier Any of the valid string formats for an integer value of arbitrary size in Tcl, with optional surrounding whitespace. The formats accepted are exactly those accepted by the C routine Tcl_GetBignumFromObj. \n\nfalse Any of the forms allowed to Tcl_GetBoolean where the value is false. \n\ngraph Any Unicode printing character, except space. \n\ninteger Any of the valid string formats for a 32-bit integer value in Tcl, with optional surrounding whitespace.  In case of under/overflow in the value, 0 is returned and the varname will contain -1. \n\nlist Any proper list structure, with optional surrounding whitespace. In case of improper list structure, 0 is returned and the varname will contain the index of the &#8220;element&#8221; where the list parsing fails, or -1 if this cannot be determined. \n\nlower Any Unicode lower case alphabet character. \n\nprint Any Unicode printing character, including space. \n\npunct Any Unicode punctuation character. \n\nspace Any Unicode whitespace character, zero width space (U+200b), word joiner (U+2060) and zero width no-break space (U+feff) (=BOM). \n\ntrue Any of the forms allowed to Tcl_GetBoolean where the value is true. \n\nupper Any upper case alphabet character in the Unicode character set. \n\nwideinteger Any of the valid forms for a wide integer in Tcl, with optional surrounding whitespace.  In case of under/overflow in the value, 0 is returned and the varname will contain -1. \n\nwordchar Any Unicode word character.  That is any alphanumeric character, and any Unicode connector punctuation characters (e.g. underscore). \n\nxdigit Any hexadecimal digit character ([0-9A-Fa-f]). \n\nIn the case of boolean, true and false, if the function will return 0, then the varname will always be set to 0, due to the varied nature of a valid boolean value.  \n\nstring last needleString haystackString ?lastIndex? Search haystackString for a sequence of characters that exactly match the characters in needleString.  If found, return the index of the first character in the last such match within haystackString.  If there is no match, then return -1.  If lastIndex is specified (in any of the forms described in STRING INDICES), then only the characters in haystackString at or before the specified lastIndex will be considered by the search.  For example, \n\n string last a 0a23456789abcdef 15 \n\n will return 10, but \n\n string last a 0a23456789abcdef 9 \n\nwill return 1. \n\nstring length string Returns a decimal string giving the number of characters in string.  Note that this is not necessarily the same as the number of bytes used to store the string.  If the value is a byte array value (such as those returned from reading a binary encoded channel), then this will return the actual byte length of the value. \n\nstring map ?-nocase? mapping string Replaces substrings in string based on the key-value pairs in mapping.  mapping is a list of key value key value ... as in the form returned by array get.  Each instance of a key in the string will be replaced with its corresponding value.  If -nocase is specified, then matching is done without regard to case differences. Both key and value may be multiple characters.  Replacement is done in an ordered manner, so the key appearing first in the list will be checked first, and so on. string is only iterated over once, so earlier key replacements will have no affect for later key matches.  For example, \n\n string map {abc 1 ab 2 a 3 1 0} 1abcaababcabababc \n\n will return the string 01321221. \n\n Note that if an earlier key is a prefix of a later one, it will completely mask the later one.  So if the previous example is reordered like this, \n\n string map {1 0 ab 2 a 3 abc 1} 1abcaababcabababc \n\nit will return the string 02c322c222c. \n\nstring match ?-nocase? pattern string See if pattern matches string; return 1 if it does, 0 if it does not.  If -nocase is specified, then the pattern attempts to match against the string in a case insensitive manner.  For the two strings to match, their contents must be identical except that the following special sequences may appear in pattern: \n\n  * Matches any sequence of characters in string, including a null string. \n\n? Matches any single character in string. \n\n[chars] Matches any character in the set given by chars.  If a sequence of the form x-y appears in chars, then any character between x and y, inclusive, will match.  When used with -nocase, the end points of the range are converted to lower case first.  Whereas {[A-z]} matches &#8220;_&#8221; when matching case-sensitively (since &#8220;_&#8221; falls between the &#8220;Z&#8221; and &#8220;a&#8221;), with -nocase this is considered like {[A-Za-z]} (and probably what was meant in the first place). \n\n\\x Matches the single character x.  This provides a way of avoiding the special interpretation of the characters *?[]\\ in pattern. \n\n \n\nstring range string first last Returns a range of consecutive characters from string, starting with the character whose index is first and ending with the character whose index is last. An index of 0 refers to the first character of the string.  first and last may be specified as for the index method.  If first is less than zero then it is treated as if it were zero, and if last is greater than or equal to the length of the string then it is treated as if it were end.  If first is greater than last then an empty string is returned. \n\nstring repeat string count Returns string repeated count number of times. \n\nstring replace string first last ?newstring? Removes a range of consecutive characters from string, starting with the character whose index is first and ending with the character whose index is last.  An index of 0 refers to the first character of the string.  First and last may be specified as for the index method.  If newstring is specified, then it is placed in the removed character range.  If first is less than zero then it is treated as if it were zero, and if last is greater than or equal to the length of the string then it is treated as if it were end.  If first is greater than last or the length of the initial string, or last is less than 0, then the initial string is returned untouched. \n\nstring reverse string Returns a string that is the same length as string but with its characters in the reverse order. \n\nstring tolower string ?first? ?last? Returns a value equal to string except that all upper (or title) case letters have been converted to lower case.  If first is specified, it refers to the first char index in the string to start modifying.  If last is specified, it refers to the char index in the string to stop at (inclusive).  first and last may be specified using the forms described in STRING INDICES. \n\nstring totitle string ?first? ?last? Returns a value equal to string except that the first character in string is converted to its Unicode title case variant (or upper case if there is no title case variant) and the rest of the string is converted to lower case.  If first is specified, it refers to the first char index in the string to start modifying.  If last is specified, it refers to the char index in the string to stop at (inclusive).  first and last may be specified using the forms described in STRING INDICES. \n\nstring toupper string ?first? ?last? Returns a value equal to string except that all lower (or title) case letters have been converted to upper case.  If first is specified, it refers to the first char index in the string to start modifying.  If last is specified, it refers to the char index in the string to stop at (inclusive).  first and last may be specified using the forms described in STRING INDICES. \n\nstring trim string ?chars? Returns a value equal to string except that any leading or trailing characters present in the string given by chars are removed.  If chars is not specified then white space is removed (any character for which string is space returns 1, and \" \"). \n\nstring trimleft string ?chars? Returns a value equal to string except that any leading characters present in the string given by chars are removed.  If chars is not specified then white space is removed (any character for which string is space returns 1, and \" \"). \n\nstring trimright string ?chars? Returns a value equal to string except that any trailing characters present in the string given by chars are removed.  If chars is not specified then white space is removed (any character for which string is space returns 1, and \" \"). \n\nstring wordend string charIndex Returns the index of the character just after the last one in the word containing character charIndex of string.  charIndex may be specified using the forms in STRING INDICES.  A word is considered to be any contiguous range of alphanumeric (Unicode letters or decimal digits) or underscore (Unicode connector punctuation) characters, or any single character other than these. \n\nstring wordstart string charIndex Returns the index of the first character in the word containing character charIndex of string.  charIndex may be specified using the forms in STRING INDICES.  A word is considered to be any contiguous range of alphanumeric (Unicode letters or decimal digits) or underscore (Unicode connector punctuation) characters, or any single character other than these. \n\n "));
		docs.put("unknown", new TCLDoc("unknown", "Handle attempts to use non-existent commands"," This command is invoked by the Tcl interpreter whenever a script tries to invoke a command that does not exist.  The default implementation of unknown is a library procedure defined when Tcl initializes an interpreter.  You can override the default unknown to change its functionality, or you can register a new handler for individual namespaces using the namespace unknown command.  Note that there is no default  implementation of unknown in a safe interpreter. \n\n If the Tcl interpreter encounters a command name for which there is not a defined command (in either the current namespace, or the  global namespace), then Tcl checks for the existence of an unknown handler for the current namespace. By default, this handler is a command named ::unknown.  If there is no such  command, then the interpreter returns an error. If the unknown command exists (or a new handler has been registered for the current namespace), then it is invoked with arguments consisting of the fully-substituted name and arguments for the original non-existent command. The unknown command typically does things like searching through library directories for a command procedure with the name cmdName, or expanding abbreviated command names to full-length, or automatically executing unknown commands as sub-processes. In some cases (such as expanding abbreviations) unknown will change the original command slightly and then (re-)execute it. The result of the unknown command is used as the result for the original non-existent command. \n\n The default implementation of unknown behaves as follows. It first calls the auto_load library procedure to load the command. If this succeeds, then it executes the original command with its original arguments. If the auto-load fails then unknown calls auto_execok to see if there is an executable file by the name cmd. If so, it invokes the Tcl exec command with cmd and all the args as arguments. If cmd cannot be auto-executed, unknown checks to see if the command was invoked at top-level and outside of any script.  If so, then unknown takes two additional steps. First, it sees if cmd has one of the following three forms: !!, !event, or ^old^new?^?. If so, then unknown carries out history substitution in the same way that csh would for these constructs. Finally, unknown checks to see if cmd is a unique abbreviation for an existing Tcl command. If so, it expands the command name and executes the command with the original arguments. If none of the above efforts has been able to execute the command, unknown generates an error return. If the global variable auto_noload is defined, then the auto-load step is skipped. If the global variable auto_noexec is defined then the auto-exec step is skipped. Under normal circumstances the return value from unknown is the return value from the command that was eventually executed. "));
		docs.put("catch", new TCLDoc("catch", "Evaluate script and trap exceptional returns"," The catch command may be used to prevent errors from aborting command interpretation.  The catch command calls the Tcl interpreter recursively to execute script, and always returns without raising an error, regardless of any errors that might occur while executing script. \n\n If script raises an error, catch will return a non-zero integer value corresponding to the exceptional return code returned by evaluation of script.  Tcl defines the normal return code from script evaluation to be zero (0), or TCL_OK.  Tcl also defines four exceptional return codes: 1 (TCL_ERROR), 2 (TCL_RETURN), 3 (TCL_BREAK), and 4 (TCL_CONTINUE).  Errors during evaluation of a script are indicated by a return code of TCL_ERROR.  The other exceptional return codes are returned by the return, break, and continue commands and in other special situations as documented.  Tcl packages can define new commands that return other integer values as return codes as well, and scripts that make use of the return -code command can also have return codes other than the five defined by Tcl. \n\n If the resultVarName argument is given, then the variable it names is set to the result of the script evaluation.  When the return code from the script is 1 (TCL_ERROR), the value stored in resultVarName is an error message.  When the return code from the script is 0 (TCL_OK), the value stored in resultVarName is the value returned from script. \n\n If the optionsVarName argument is given, then the variable it names is set to a dictionary of return options returned by evaluation of script.  Tcl specifies two entries that are always  defined in the dictionary: -code and -level.  When the return code from evaluation of script is not TCL_RETURN, the value of the -level entry will be 0, and the value of the -code entry will be the same as the return code. Only when the return code is TCL_RETURN will the values of the -level and -code entries be something else, as further described in the documentation for the return command. \n\n When the return code from evaluation of script is TCL_ERROR, four additional entries are defined in the dictionary of return options stored in optionsVarName: -errorinfo, -errorcode, -errorline, and -errorstack. The value of the -errorinfo entry is a formatted stack trace containing more information about the context in which the error happened.  The formatted stack trace is meant to be read by a person.  The value of the -errorcode entry is additional information about the error stored as a list.  The -errorcode value is meant to be further processed by programs, and may not be particularly readable by people.  The value of the -errorline entry is an integer indicating which line of script was being evaluated when the error occurred. The value of the -errorstack entry is an even-sized list made of token-parameter pairs accumulated while unwinding the stack. The token may be &#8220;CALL&#8221;, in which case the parameter is a list made of the proc name and arguments at the corresponding level; or it may be &#8220;UP&#8221;, in which case the parameter is the relative level (as in uplevel) of the previous CALL. The salient differences with respect to -errorinfo are that: \n\n   it is a machine-readable form that is amenable to processing with [foreach {tok prm} ...], \n\n it contains the true (substituted) values passed to the functions, instead of the static text of the calling sites, and \n\n it is coarser-grained, with only one element per stack frame (like procs; no separate elements for foreach constructs for example). \n\n \n\n The values of the -errorinfo and -errorcode entries of the most recent error are also available as values of the global variables ::errorInfo and ::errorCode respectively. The value of the -errorstack entry surfaces as info errorstack. \n\n Tcl packages may provide commands that set other entries in the dictionary of return options, and the return command may be used by scripts to set return options in addition to those defined above. "));
		docs.put("global", new TCLDoc("global", "Access global variables"," This command has no effect unless executed in the context of a proc body. If the global command is executed in the context of a proc body, it creates local variables linked to the corresponding global variables (though these linked variables, like those created by upvar, are not included in the list returned by info locals). \n\n If varname contains namespace qualifiers, the local variable\'s name is the unqualified name of the global variable, as determined by the namespace tail command.  \n\n varname is always treated as the name of a variable, not an array element.  An error is returned if the name looks like an array element, such as a(b). "));
		docs.put("oo::copy", new TCLDoc("oo::copy", "create copies of objects and classes"," The oo::copy command creates a copy of an object or class. It takes the name of the object or class to be copied, sourceObject, and optionally the name of the object or class to create, targetObject, which will be resolved relative to the current namespace if not an absolute qualified name. If targetObject is omitted, a new name is chosen. The copied object will be of the same class as the source object, and will have all its per-object methods copied. If it is a class, it will also have all the class methods in the class copied, but it will not have any of its instances copied. \n\n After the targetObject has been created and all definitions of its configuration (e.g., methods, filters, mixins) copied, the  method of targetObject will be invoked, to allow for customization of the created object such as installing related variable traces. The only argument given will be sourceObject. The default implementation of this method (in oo::object) just copies the procedures and variables in the namespace of sourceObject to the namespace of targetObject. If this method call does not return a result that is successful (i.e., an error or other kind of exception) then the targetObject will be deleted and an error returned. \n\n The result of the oo::copy command will be the fully-qualified name of the new object or class. "));
		docs.put("subst", new TCLDoc("subst", "Perform backslash, command, and variable substitutions"," This command performs variable substitutions, command substitutions, and backslash substitutions on its string argument and returns the fully-substituted result. The substitutions are performed in exactly the same way as for Tcl commands. As a result, the string argument is actually substituted twice, once by the Tcl parser in the usual fashion for Tcl commands, and again by the subst command. \n\n If any of the -nobackslashes, -nocommands, or -novariables are specified, then the corresponding substitutions are not performed. For example, if -nocommands is specified, command substitution is not performed:  open and close brackets are treated as ordinary characters with no special interpretation. \n\n Note that the substitution of one kind can include substitution of  other kinds.  For example, even when the -novariables option is specified, command substitution is performed without restriction. This means that any variable substitution necessary to complete the command substitution will still take place.  Likewise, any command substitution necessary to complete a variable substitution will take place, even when -nocommands is specified.  See the EXAMPLES below. \n\n If an error occurs during substitution, then subst will return that error.  If a break exception occurs during command or variable substitution, the result of the whole substitution will be the string (as substituted) up to the start of the substitution that raised the exception.  If a continue exception occurs during the evaluation of a command or variable substitution, an empty string will be substituted for that entire command or variable substitution (as long as it is well-formed Tcl.)  If a return exception occurs, or any other return code is returned during command or variable substitution, then the returned value is substituted for that substitution.  See the EXAMPLES below.  In this way, all exceptional return codes are &#8220;caught&#8221; by subst.  The subst command itself will either return an error, or will complete successfully. "));
		docs.put("unload", new TCLDoc("unload", "Unload machine code"," This command tries to unload shared libraries previously loaded with load from the application\'s address space.  fileName is the name of the file containing the library file to be unload;  it must be the same as the filename provided to load for loading the library. The packageName argument is the name of the package (as determined by or passed to load), and is used to compute the name of the unload procedure; if not supplied, it is computed from fileName in the same manner as load. The interp argument is the path name of the interpreter from which to unload the package (see the interp manual entry for details); if interp is omitted, it defaults to the interpreter in which the unload command was invoked. \n\n If the initial arguments to unload start with - then they are treated as switches.  The following switches are currently supported: \n\n  -nocomplain Suppresses all error messages. If this switch is given, unload will never report an error. \n\n-keeplibrary This switch will prevent unload from issuing the operating system call that will unload the library from the process.  \n\n-- Marks the end of switches.  The argument following this one will be treated as a fileName even if it starts with a -. \n\n UNLOAD OPERATION When a file containing a shared library is loaded through the load command, Tcl associates two reference counts to the library file. The first counter shows how many times the library has been loaded into normal (trusted) interpreters while the second describes how many times the library has been loaded into safe interpreters. As a file containing a shared library can be loaded only once by Tcl (with the first load call on the file), these counters track how many interpreters use the library. Each subsequent call to load after the first simply increments the proper reference count. \n\n unload works in the opposite direction. As a first step, unload will check whether the library is unloadable: an unloadable library exports a special unload procedure. The name of the unload procedure is determined by packageName and whether or not the target interpreter is a safe one.  For normal interpreters the name of the initialization procedure will have the form pkg_Unload, where pkg is the same as packageName except that the first letter is converted to upper case and all other letters are converted to lower case.  For example, if packageName is foo or FOo, the initialization procedure\'s name will be Foo_Unload. If the target interpreter is a safe interpreter, then the name of the initialization procedure will be pkg_SafeUnload instead of pkg_Unload. \n\n If unload determines that a library is not unloadable (or unload functionality has been disabled during compilation), an error will be returned. If the library is unloadable, then unload will call the unload procedure. If the unload procedure returns TCL_OK, unload will proceed and decrease the proper reference count (depending on the target interpreter type). When both reference counts have reached 0, the library will be detached from the process. UNLOAD HOOK PROTOTYPE The unload procedure must match the following prototype: \n\n typedef int Tcl_PackageUnloadProc(         Tcl_Interp *interp,         int flags); \n\n The interp argument identifies the interpreter from which the library is to be unloaded.  The unload procedure must return TCL_OK or TCL_ERROR to indicate whether or not it completed successfully;  in the event of an error it should set the interpreter\'s result to point to an error message.  In this case, the result of the unload command will be the result returned by the unload procedure. \n\n The flags argument can be either TCL_UNLOAD_DETACH_FROM_INTERPRETER or TCL_UNLOAD_DETACH_FROM_PROCESS. In case the library will remain attached to the process after the unload procedure returns (i.e. because the library is used by other interpreters), TCL_UNLOAD_DETACH_FROM_INTERPRETER will be defined. However, if the library is used only by the target interpreter and the library will be detached from the application as soon as the unload procedure returns, the flags argument will be set to TCL_UNLOAD_DETACH_FROM_PROCESS.  NOTES The unload command cannot unload libraries that are statically linked with the application. If fileName is an empty string, then the packageName argument must be specified. \n\n If packageName is omitted or specified as an empty string, Tcl tries to guess the name of the package. This may be done differently on different platforms. The default guess, which is used on most UNIX platforms, is to take the last element of fileName, strip off the first three characters if they are lib, and use any following alphabetic and underline characters as the module name. For example, the command unload libxyz4.2.so uses the module name xyz and the command unload bin/last.so {} uses the module name last. "));
		docs.put("cd", new TCLDoc("cd", "Change working directory"," Change the current working directory to dirName, or to the home directory (as specified in the HOME environment variable) if dirName is not given. Returns an empty string. Note that the current working directory is a per-process resource; the cd command changes the working directory for all interpreters and (in a threaded environment) all threads. "));
		docs.put("history", new TCLDoc("history", "Manipulate the history list"," The history command performs one of several operations related to recently-executed commands recorded in a history list.  Each of these recorded commands is referred to as an &#8220;event&#8221;. When specifying an event to the history command, the following forms may be used: \n\n   A number:  if positive, it refers to the event with that number (all events are numbered starting at 1).  If the number is negative, it selects an event relative to the current event (-1 refers to the previous event, -2 to the one before that, and so on).  Event 0 refers to the current event. \n\n A string:  selects the most recent event that matches the string. An event is considered to match the string either if the string is the same as the first characters of the event, or if the string matches the event in the sense of the string match command. \n\n \n\n The history command can take any of the following forms: \n\n  history Same as history info, described below. \n\nhistory add command ?exec? Adds the command argument to the history list as a new event.  If exec is specified (or abbreviated) then the command is also executed and its result is returned.  If exec is not specified then an empty string is returned as result. \n\nhistory change newValue ?event? Replaces the value recorded for an event with newValue.  Event specifies the event to replace, and defaults to the current event (not event -1).  This command is intended for use in commands that implement new forms of history substitution and wish to replace the current event (which invokes the substitution) with the command created through substitution.  The return value is an empty string. \n\nhistory clear Erase the history list.  The current keep limit is retained. The history event numbers are reset. \n\nhistory event ?event? Returns the value of the event given by event.  Event defaults to -1. \n\nhistory info ?count? Returns a formatted string (intended for humans to read) giving the event number and contents for each of the events in the history list except the current event.  If count is specified then only the most recent count events are returned. \n\nhistory keep ?count? This command may be used to change the size of the history list to count events.  Initially, 20 events are retained in the history list.  If count is not specified, the current keep limit is returned. \n\nhistory nextid Returns the number of the next event to be recorded in the history list.  It is useful for things like printing the event number in command-line prompts. \n\nhistory redo ?event? Re-executes the command indicated by event and returns its result. Event defaults to -1.  This command results in history revision:  see below for details. \n\n "));
		docs.put("oo::define, oo::objdefine", new TCLDoc("oo::define, oo::objdefine", "define and configure classes and objects"," The oo::define command is used to control the configuration of classes, and the oo::objdefine command is used to control the configuration of objects (including classes as instance objects), with the configuration being applied to the entity named in the class or the object argument. Configuring a class also updates the configuration of all subclasses of the class and all objects that are instances of that class or which mix it in (as modified by any per-instance configuration). The way in which the configuration is done is controlled by either the defScript argument or by the subcommand and following arg arguments; when the second is present, it is exactly as if all the arguments from subcommand onwards are made into a list and that list is used as the defScript argument. CONFIGURING CLASSES The following commands are supported in the defScript for oo::define, each of which may also be used in the subcommand form: \n\n  constructor argList bodyScript This creates or updates the constructor for a class. The formal arguments to the constructor (defined using the same format as for the Tcl proc command) will be argList, and the body of the constructor will be bodyScript. When the body of the constructor is evaluated, the current namespace of the constructor will be a namespace that is unique to the object being constructed. Within the constructor, the next command should be used to call the superclasses\' constructors. If bodyScript is the empty string, the constructor will be deleted. \n\ndeletemethod name ?name ... This deletes each of the methods called name from a class. The methods must have previously existed in that class. Does not affect the superclasses of the class, nor does it affect the subclasses or instances of the class (except when they have a call chain through the class being modified). \n\ndestructor bodyScript This creates or updates the destructor for a class. Destructors take no arguments, and the body of the destructor will be bodyScript. The destructor is called when objects of the class are deleted, and when called will have the object\'s unique namespace as the current namespace. Destructors should use the next command to call the superclasses\' destructors. Note that destructors are not called in all situations (e.g. if the interpreter is destroyed). If bodyScript is the empty string, the destructor will be deleted.  Note that errors during the evaluation of a destructor are not returned to the code that causes the destruction of an object. Instead, they are passed to the currently-defined bgerror handler.  \n\nexport name ?name ...? This arranges for each of the named methods, name, to be exported (i.e. usable outside an instance through the instance object\'s command) by the class being defined. Note that the methods themselves may be actually defined by a superclass; subclass exports override superclass visibility, and may in turn be overridden by instances. \n\nfilter ?-slotOperation? ?methodName ...? This slot (see SLOTTED DEFINITIONS below) sets or updates the list of method names that are used to guard whether method call to instances of the class may be called and what the method\'s results are. Each methodName names a single filtering method (which may be exposed or not exposed); it is not an error for a non-existent method to be named since they may be defined by subclasses. By default, this slot works by appending. \n\nforward name cmdName ?arg ...? This creates or updates a forwarded method called name. The method is defined be forwarded to the command called cmdName, with additional arguments, arg etc., added before those arguments specified by the caller of the method. The cmdName will always be resolved using the rules of the invoking objects\' namespaces, i.e., when cmdName is not fully-qualified, the command will be searched for in each object\'s namespace, using the instances\' namespace\'s path, or by looking in the global namespace. The method will be exported if name starts with a lower-case letter, and non-exported otherwise. \n\nmethod name argList bodyScript This creates or updates a method that is implemented as a procedure-like script. The name of the method is name, the formal arguments to the method (defined using the same format as for the Tcl proc command) will be argList, and the body of the method will be bodyScript. When the body of the method is evaluated, the current namespace of the method will be a namespace that is unique to the current object. The method will be exported if name starts with a lower-case letter, and non-exported otherwise; this behavior can be overridden via export and unexport. \n\nmixin ?-slotOperation? ?className ...? This slot (see SLOTTED DEFINITIONS below) sets or updates the list of additional classes that are to be mixed into all the instances of the class being defined. Each className argument names a single class that is to be mixed in. By default, this slot works by replacement. \n\nrenamemethod fromName toName This renames the method called fromName in a class to toName. The method must have previously existed in the class, and toName must not previously refer to a method in that class. Does not affect the superclasses of the class, nor does it affect the subclasses or instances of the class (except when they have a call chain through the class being modified). Does not change the export status of the method; if it was exported before, it will be afterwards. \n\nself subcommand arg ... \n\nself script This command is equivalent to calling oo::objdefine on the class being defined (see CONFIGURING OBJECTS below for a description of the supported values of subcommand). It follows the same general pattern of argument handling as the oo::define and oo::objdefine commands, and &#8220;oo::define cls self subcommand ...&#8221; operates identically to &#8220;oo::objdefine cls subcommand ...&#8221;. \n\nsuperclass ?-slotOperation? ?className ...? This slot (see SLOTTED DEFINITIONS below) allows the alteration of the superclasses of the class being defined. Each className argument names one class that is to be a superclass of the defined class. Note that objects must not be changed from being classes to being non-classes or vice-versa, that an empty parent class is equivalent to oo::object, and that the parent classes of oo::object and oo::class may not be modified. By default, this slot works by replacement. \n\nunexport name ?name ...? This arranges for each of the named methods, name, to be not exported (i.e. not usable outside the instance through the instance object\'s command, but instead just through the my command visible in each object\'s context) by the class being defined. Note that the methods themselves may be actually defined by a superclass; subclass unexports override superclass visibility, and may be overridden by instance unexports. \n\nvariable ?-slotOperation? ?name ...? This slot (see SLOTTED DEFINITIONS below) arranges for each of the named variables to be automatically made available in the methods, constructor and destructor declared by the class being defined. Each variable name must not have any namespace separators and must not look like an array access. All variables will be actually present in the instance object on which the method is executed. Note that the variable lists declared by a superclass or subclass are completely disjoint, as are variable lists declared by instances; the list of variable names is just for methods (and constructors and destructors) declared by this class. By default, this slot works by appending. \n\n CONFIGURING OBJECTS The following commands are supported in the defScript for oo::objdefine, each of which may also be used in the subcommand form: \n\n  class className This allows the class of an object to be changed after creation. Note that the class\'s constructors are not called when this is done, and so the object may well be in an inconsistent state unless additional configuration work is done. \n\ndeletemethod name ?name ... This deletes each of the methods called name from an object. The methods must have previously existed in that object. Does not affect the classes that the object is an instance of. \n\nexport name ?name ...? This arranges for each of the named methods, name, to be exported (i.e. usable outside the object through the object\'s command) by the object being defined. Note that the methods themselves may be actually defined by a class or superclass; object exports override class visibility. \n\nfilter ?-slotOperation? ?methodName ...? This slot (see SLOTTED DEFINITIONS below) sets or updates the list of method names that are used to guard whether a method call to the object may be called and what the method\'s results are. Each methodName names a single filtering method (which may be exposed or not exposed); it is not an error for a non-existent method to be named. Note that the actual list of filters also depends on the filters set upon any classes that the object is an instance of. By default, this slot works by appending. \n\nforward name cmdName ?arg ...? This creates or updates a forwarded object method called name. The method is defined be forwarded to the command called cmdName, with additional arguments, arg etc., added before those arguments specified by the caller of the method. Forwarded methods should be deleted using the method subcommand. The method will be exported if name starts with a lower-case letter, and non-exported otherwise. \n\nmethod name argList bodyScript This creates, updates or deletes an object method. The name of the method is name, the formal arguments to the method (defined using the same format as for the Tcl proc command) will be argList, and the body of the method will be bodyScript. When the body of the method is evaluated, the current namespace of the method will be a namespace that is unique to the object. The method will be exported if name starts with a lower-case letter, and non-exported otherwise. \n\nmixin ?-slotOperation? ?className ...? This slot (see SLOTTED DEFINITIONS below) sets or updates a per-object list of additional classes that are to be mixed into the object. Each argument, className, names a single class that is to be mixed in. By default, this slot works by replacement. \n\nrenamemethod fromName toName This renames the method called fromName in an object to toName. The method must have previously existed in the object, and toName must not previously refer to a method in that object. Does not affect the classes that the object is an instance of. Does not change the export status of the method; if it was exported before, it will be afterwards. \n\nunexport name ?name ...? This arranges for each of the named methods, name, to be not exported (i.e. not usable outside the object through the object\'s command, but instead just through the my command visible in the object\'s context) by the object being defined. Note that the methods themselves may be actually defined by a class; instance unexports override class visibility. \n\nvariable ?-slotOperation? ?name ...? This slot (see SLOTTED DEFINITIONS below) arranges for each of the named variables to be automatically made available in the methods declared by the object being defined.  Each variable name must not have any namespace separators and must not look like an array access. All variables will be actually present in the object on which the method is executed. Note that the variable lists declared by the classes and mixins of which the object is an instance are completely disjoint; the list of variable names is just for methods declared by this object. By default, this slot works by appending. \n\n "));
		docs.put("switch", new TCLDoc("switch", "Evaluate one of several scripts, depending on a given value"," The switch command matches its string argument against each of the pattern arguments in order. As soon as it finds a pattern that matches string it evaluates the following body argument by passing it recursively to the Tcl interpreter and returns the result of that evaluation. If the last pattern argument is default then it matches anything. If no pattern argument matches string and no default is given, then the switch command returns an empty string. \n\n If the initial arguments to switch start with - then they are treated as options unless there are exactly two arguments to switch (in which case the first must the string and the second must be the pattern/body list). The following options are currently supported: \n\n  -exact Use exact matching when comparing string to a pattern.  This is the default. \n\n-glob When matching string to the patterns, use glob-style matching (i.e. the same as implemented by the string match command). \n\n-regexp When matching string to the patterns, use regular expression matching (as described in the re_syntax reference page). \n\n-nocase Causes comparisons to be handled in a case-insensitive manner. \n\n-matchvar varName This option (only legal when -regexp is also specified) specifies the name of a variable into which the list of matches found by the regular expression engine will be written.  The first element of the list written will be the overall substring of the input string (i.e. the string argument to switch) matched, the second element of the list will be the substring matched by the first capturing parenthesis in the regular expression that matched, and so on.  When a default branch is taken, the variable will have the empty list written to it.  This option may be specified at the same time as the -indexvar option. \n\n-indexvar varName This option (only legal when -regexp is also specified) specifies the name of a variable into which the list of indices referring to matching substrings found by the regular expression engine will be written.  The first element of the list written will be a two-element list specifying the index of the start and index of the first character after the end of the overall substring of the input string (i.e. the string argument to switch) matched, in a similar way to the -indices option to the regexp can obtain.  Similarly, the second element of the list refers to the first capturing parenthesis in the regular expression that matched, and so on.  When a default branch is taken, the variable will have the empty list written to it.  This option may be specified at the same time as the -matchvar option. \n\n-- Marks the end of options.  The argument following this one will be treated as string even if it starts with a -. This is not required when the matching patterns and bodies are grouped together in a single argument. \n\n \n\n Two syntaxes are provided for the pattern and body arguments. The first uses a separate argument for each of the patterns and commands; this form is convenient if substitutions are desired on some of the patterns or commands. The second form places all of the patterns and commands together into a single argument; the argument must have proper list structure, with the elements of the list being the patterns and commands. The second form makes it easy to construct multi-line switch commands, since the braces around the whole list make it unnecessary to include a backslash at the end of each line. Since the pattern arguments are in braces in the second form, no command or variable substitutions are performed on them;  this makes the behavior of the second form different than the first form in some cases. \n\n If a body is specified as &#8220;-&#8221; it means that the body for the next pattern should also be used as the body for this pattern (if the next pattern also has a body of &#8220;-&#8221; then the body after that is used, and so on). This feature makes it possible to share a single body among several patterns. \n\n Beware of how you place comments in switch commands.  Comments should only be placed inside the execution body of one of the patterns, and not intermingled with the patterns. "));
		docs.put("unset", new TCLDoc("unset", "Delete variables"," This command removes one or more variables. Each name is a variable name, specified in any of the ways acceptable to the set command. If a name refers to an element of an array then that element is removed without affecting the rest of the array. If a name consists of an array name with no parenthesized index, then the entire array is deleted. The unset command returns an empty string as result. If -nocomplain is specified as the first argument, any possible errors are suppressed.  The option may not be abbreviated, in order to disambiguate it from possible variable names.  The option -- indicates the end of the options, and should be used if you wish to remove a variable with the same name as any of the options. If an error occurs during variable deletion, any variables after the named one causing the error are not deleted.  An error can occur when the named variable does not exist, or the name refers to an array element but the variable is a scalar, or the name refers to a variable in a non-existent namespace. "));
		docs.put("chan", new TCLDoc("chan", "Read, write and manipulate channels"," This command provides several operations for reading from, writing to and otherwise manipulating open channels (such as have been created with the open and socket commands, or the default named channels stdin, stdout or stderr which correspond to the process\'s standard input, output and error streams respectively). Option indicates what to do with the channel; any unique abbreviation for option is acceptable. Valid options are: \n\n  chan blocked channelId This tests whether the last input operation on the channel called channelId failed because it would have otherwise caused the process to block, and returns 1 if that was the case. It returns 0 otherwise. Note that this only ever returns 1 when the channel has been configured to be non-blocking; all Tcl channels have blocking turned on by default. \n\nchan close channelId ?direction? Close and destroy the channel called channelId. Note that this deletes all existing file-events registered on the channel. If the direction argument (which must be read or write or any unique abbreviation of them) is present, the channel will only be half-closed, so that it can go from being read-write to write-only or read-only respectively. If a read-only channel is closed for reading, it is the same as if the channel is fully closed, and respectively similar for write-only channels. Without the direction argument, the channel is closed for both reading and writing (but only if those directions are currently open). It is an error to close a read-only channel for writing, or a write-only channel for reading. \n\n As part of closing the channel, all buffered output is flushed to the channel\'s output device (only if the channel is ceasing to be writable), any buffered input is discarded (only if the channel is ceasing to be readable), the underlying operating system resource is closed and channelId becomes unavailable for future use (both only if the channel is being completely closed). \n\n If the channel is blocking and the channel is ceasing to be writable, the command does not return until all output is flushed.  If the channel is non-blocking and there is unflushed output, the channel remains open and the command returns immediately; output will be flushed in the background and the channel will be closed when all the flushing is complete. \n\n If channelId is a blocking channel for a command pipeline then chan close waits for the child processes to complete. \n\n If the channel is shared between interpreters, then chan close makes channelId unavailable in the invoking interpreter but has no other effect until all of the sharing interpreters have closed the channel. When the last interpreter in which the channel is registered invokes chan close (or close), the cleanup actions described above occur. With half-closing, the half-close of the channel only applies to the current interpreter\'s view of the channel until all channels have closed it in that direction (or completely). See the interp command for a description of channel sharing. \n\n Channels are automatically fully closed when an interpreter is destroyed and when the process exits.  Channels are switched to blocking mode, to ensure that all output is correctly flushed before the process exits. \n\n The command returns an empty string, and may generate an error if an error occurs while flushing output.  If a command in a command pipeline created with open returns an error, chan close generates an error (similar to the exec command.) \n\nNote that half-closes of sockets and command pipelines can have important side effects because they result in a shutdown() or close() of the underlying system resource, which can change how other processes or systems respond to the Tcl program. \n\nchan configure channelId ?optionName? ?value? ?optionName value?... Query or set the configuration options of the channel named channelId. \n\n If no optionName or value arguments are supplied, the command returns a list containing alternating option names and values for the channel.  If optionName is supplied but no value then the command returns the current value of the given option.  If one or more pairs of optionName and value are supplied, the command sets each of the named options to the corresponding value; in this case the return value is an empty string. \n\n The options described below are supported for all channels. In addition, each channel type may add options that only it supports. See the manual entry for the command that creates each type of channel for the options supported by that specific type of channel. For example, see the manual entry for the socket command for additional options for sockets, and the open command for additional options for serial devices. \n\n  -blocking boolean The -blocking option determines whether I/O operations on the channel can cause the process to block indefinitely.  The value of the option must be a proper boolean value.  Channels are normally in blocking mode; if a channel is placed into non-blocking mode it will affect the operation of the chan gets, chan read, chan puts, chan flush, and chan close commands; see the documentation for those commands for details.  For non-blocking mode to work correctly, the application must be using the Tcl event loop (e.g. by calling Tcl_DoOneEvent or invoking the vwait command). \n\n-buffering newValue If newValue is full then the I/O system will buffer output until its internal buffer is full or until the chan flush command is invoked. If newValue is line, then the I/O system will automatically flush output for the channel whenever a newline character is output. If newValue is none, the I/O system will flush automatically after every output operation.  The default is for -buffering to be set to full except for channels that connect to terminal-like devices; for these channels the initial setting is line.  Additionally, stdin and stdout are initially set to line, and stderr is set to none. \n\n-buffersize newSize Newvalue must be an integer; its value is used to set the size of buffers, in bytes, subsequently allocated for this channel to store input or output. Newvalue must be a number of no more than one million, allowing buffers of up to one million bytes in size. \n\n-encoding name This option is used to specify the encoding of the channel as one of the named encodings returned by encoding names or the special value binary, so that the data can be converted to and from Unicode for use in Tcl.  For instance, in order for Tcl to read characters from a Japanese file in shiftjis and properly process and display the contents, the encoding would be set to shiftjis. Thereafter, when reading from the channel, the bytes in the Japanese file would be converted to Unicode as they are read.  Writing is also supported - as Tcl strings are written to the channel they will automatically be converted to the specified encoding on output. \n\n If a file contains pure binary data (for instance, a JPEG image), the encoding for the channel should be configured to be binary.  Tcl will then assign no interpretation to the data in the file and simply read or write raw bytes.  The Tcl binary command can be used to manipulate this byte-oriented data.  It is usually better to set the -translation option to binary when you want to transfer binary data, as this turns off the other automatic interpretations of the bytes in the stream as well. \n\nThe default encoding for newly opened channels is the same platform- and locale-dependent system encoding used for interfacing with the operating system, as returned by encoding system. \n\n-eofchar char \n\n-eofchar {inChar outChar} This option supports DOS file systems that use Control-z (\\x1a) as an end of file marker.  If char is not an empty string, then this character signals end-of-file when it is encountered during input. For output, the end-of-file character is output when the channel is closed.  If char is the empty string, then there is no special end of file character marker.  For read-write channels, a two-element list specifies the end of file marker for input and output, respectively.  As a convenience, when setting the end-of-file character for a read-write channel you can specify a single value that will apply to both reading and writing.  When querying the end-of-file character of a read-write channel, a two-element list will always be returned.  The default value for -eofchar is the empty string in all cases except for files under Windows.  In that case the -eofchar is Control-z (\\x1a) for reading and the empty string for writing. The acceptable range for -eofchar values is \\x01 - \\x7f; attempting to set -eofchar to a value outside of this range will generate an error. \n\n-translation mode \n\n-translation {inMode outMode} In Tcl scripts the end of a line is always represented using a single newline character (\\n).  However, in actual files and devices the end of a line may be represented differently on different platforms, or even for different devices on the same platform.  For example, under UNIX newlines are used in files, whereas carriage-return-linefeed sequences are normally used in network connections.  On input (i.e., with chan gets and chan read) the Tcl I/O system automatically translates the external end-of-line representation into newline characters.  Upon output (i.e., with chan puts), the I/O system translates newlines to the external end-of-line representation. The default translation mode, auto, handles all the common cases automatically, but the -translation option provides explicit control over the end of line translations. \n\n The value associated with -translation is a single item for read-only and write-only channels.  The value is a two-element list for read-write channels; the read translation mode is the first element of the list, and the write translation mode is the second element.  As a convenience, when setting the translation mode for a read-write channel you can specify a single value that will apply to both reading and writing.  When querying the translation mode of a read-write channel, a two-element list will always be returned.  The following values are currently supported: \n\n  auto As the input translation mode, auto treats any of newline (lf), carriage return (cr), or carriage return followed by a newline (crlf) as the end of line representation.  The end of line representation can even change from line-to-line, and all cases are translated to a newline.  As the output translation mode, auto chooses a platform specific representation; for sockets on all platforms Tcl chooses crlf, for all Unix flavors, it chooses lf, and for the various flavors of Windows it chooses crlf.  The default setting for -translation is auto for both input and output. \n\nbinary No end-of-line translations are performed.  This is nearly identical to lf mode, except that in addition binary mode also sets the end-of-file character to the empty string (which disables it) and sets the encoding to binary (which disables encoding filtering). See the description of -eofchar and -encoding for more information. \n\ncr The end of a line in the underlying file or device is represented by a single carriage return character.  As the input translation mode, cr mode converts carriage returns to newline characters.  As the output translation mode, cr mode translates newline characters to carriage returns. \n\ncrlf The end of a line in the underlying file or device is represented by a carriage return character followed by a linefeed character.  As the input translation mode, crlf mode converts carriage-return-linefeed sequences to newline characters.  As the output translation mode, crlf mode translates newline characters to carriage-return-linefeed sequences.  This mode is typically used on Windows platforms and for network connections. \n\nlf The end of a line in the underlying file or device is represented by a single newline (linefeed) character.  In this mode no translations occur during either input or output.  This mode is typically used on UNIX platforms. \n\n \n\n \n\nchan copy inputChan outputChan ?-size size? ?-command callback? Copy data from the channel inputChan, which must have been opened for reading, to the channel outputChan, which must have been opened for writing. The chan copy command leverages the buffering in the Tcl I/O system to avoid extra copies and to avoid buffering too much data in main memory when copying large files to slow destinations like network sockets. \n\n The chan copy command transfers data from inputChan until end of file or size bytes have been transferred. If no -size argument is given, then the copy goes until end of file. All the data read from inputChan is copied to outputChan. Without the -command option, chan copy blocks until the copy is complete and returns the number of bytes written to outputChan. \n\n The -command argument makes chan copy work in the background.  In this case it returns immediately and the callback is invoked later when the copy completes.  The callback is called with one or two additional arguments that indicates how many bytes were written to outputChan.  If an error occurred during the background copy, the second argument is the error string associated with the error.  With a background copy, it is not necessary to put inputChan or outputChan into non-blocking mode; the chan copy command takes care of that automatically.  However, it is necessary to enter the event loop by using the vwait command or by using Tk. \n\n You are not allowed to do other I/O operations with inputChan or outputChan during a background chan copy.  If either inputChan or outputChan get closed while the copy is in progress, the current copy is stopped and the command callback is not made.  If inputChan is closed, then all data already queued for outputChan is written out. \n\n Note that inputChan can become readable during a background copy.  You should turn off any chan event or fileevent handlers during a background copy so those handlers do not interfere with the copy.  Any I/O attempted by a chan event or fileevent handler will get a &#8220;channel busy&#8221; error. \n\n Chan copy translates end-of-line sequences in inputChan and outputChan according to the -translation option for these channels (see chan configure above).  The translations mean that the number of bytes read from inputChan can be different than the number of bytes written to outputChan.  Only the number of bytes written to outputChan is reported, either as the return value of a synchronous chan copy or as the argument to the callback for an asynchronous chan copy. \n\nChan copy obeys the encodings and character translations configured for the channels. This means that the incoming characters are converted internally first UTF-8 and then into the encoding of the channel chan copy writes to (see chan configure above for details on the -encoding and -translation options). No conversion is done if both channels are set to encoding binary and have matching translations. If only the output channel is set to encoding binary the system will write the internal UTF-8 representation of the incoming characters. If only the input channel is set to encoding binary the system will assume that the incoming bytes are valid UTF-8 characters and convert them according to the output encoding. The behaviour of the system for bytes which are not valid UTF-8 characters is undefined in this case. \n\nchan create mode cmdPrefix This subcommand creates a new script level channel using the command prefix cmdPrefix as its handler. Any such channel is called a reflected channel. The specified command prefix, cmdPrefix, must be a non-empty list, and should provide the API described in the refchan manual page. The handle of the new channel is returned as the result of the chan create command, and the channel is open. Use either close or chan close to remove the channel. \n\n The argument mode specifies if the new channel is opened for reading, writing, or both. It has to be a list containing any of the strings &#8220;read&#8221; or &#8220;write&#8221;. The list must have at least one element, as a channel you can neither write to nor read from makes no sense. The handler command for the new channel must support the chosen mode, or an error is thrown. \n\n The command prefix is executed in the global namespace, at the top of call stack, following the appending of arguments as described in the refchan manual page. Command resolution happens at the time of the call. Renaming the command, or destroying it means that the next call of a handler method may fail, causing the channel command invoking the handler to fail as well. Depending on the subcommand being invoked, the error message may not be able to explain the reason for that failure. \n\n Every channel created with this subcommand knows which interpreter it was created in, and only ever executes its handler command in that interpreter, even if the channel was shared with and/or was moved into a different interpreter. Each reflected channel also knows the thread it was created in, and executes its handler command only in that thread, even if the channel was moved into a different thread. To this end all invocations of the handler are forwarded to the original thread by posting special events to it. This means that the original thread (i.e. the thread that executed the chan create command) must have an active event loop, i.e. it must be able to process such events. Otherwise the thread sending them will block indefinitely. Deadlock may occur. \n\n Note that this permits the creation of a channel whose two endpoints live in two different threads, providing a stream-oriented bridge between these threads. In other words, we can provide a way for regular stream communication between threads instead of having to send commands. \n\n When a thread or interpreter is deleted, all channels created with this subcommand and using this thread/interpreter as their computing base are deleted as well, in all interpreters they have been shared with or moved into, and in whatever thread they have been transferred to. While this pulls the rug out under the other thread(s) and/or interpreter(s), this cannot be avoided. Trying to use such a channel will cause the generation of a regular error about unknown channel handles. \n\nThis subcommand is safe and made accessible to safe interpreters.  While it arranges for the execution of arbitrary Tcl code the system also makes sure that the code is always executed within the safe interpreter. \n\nchan eof channelId Test whether the last input operation on the channel called channelId failed because the end of the data stream was reached, returning 1 if end-of-file was reached, and 0 otherwise. \n\nchan event channelId event ?script? Arrange for the Tcl script script to be installed as a file event handler to be called whenever the channel called channelId enters the state described by event (which must be either readable or writable); only one such handler may be installed per event per channel at a time.  If script is the empty string, the current handler is deleted (this also happens if the channel is closed or the interpreter deleted).  If script is omitted, the currently installed script is returned (or an empty string if no such handler is installed).  The callback is only performed if the event loop is being serviced (e.g. via vwait or update). \n\n A file event handler is a binding between a channel and a script, such that the script is evaluated whenever the channel becomes readable or writable.  File event handlers are most commonly used to allow data to be received from another process on an event-driven basis, so that the receiver can continue to interact with the user or with other channels while waiting for the data to arrive.  If an application invokes chan gets or chan read on a blocking channel when there is no input data available, the process will block; until the input data arrives, it will not be able to service other events, so it will appear to the user to &#8220;freeze up&#8221;. With chan event, the process can tell when data is present and only invoke chan gets or chan read when they will not block. \n\n A channel is considered to be readable if there is unread data available on the underlying device.  A channel is also considered to be readable if there is unread data in an input buffer, except in the special case where the most recent attempt to read from the channel was a chan gets call that could not find a complete line in the input buffer.  This feature allows a file to be read a line at a time in non-blocking mode using events.  A channel is also considered to be readable if an end of file or error condition is present on the underlying file or device.  It is important for script to check for these conditions and handle them appropriately; for example, if there is no special check for end of file, an infinite loop may occur where script reads no data, returns, and is immediately invoked again. \n\n A channel is considered to be writable if at least one byte of data can be written to the underlying file or device without blocking, or if an error condition is present on the underlying file or device. Note that client sockets opened in asynchronous mode become writable when they become connected or if the connection fails. \n\n Event-driven I/O works best for channels that have been placed into non-blocking mode with the chan configure command.  In blocking mode, a chan puts command may block if you give it more data than the underlying file or device can accept, and a chan gets or chan read command will block if you attempt to read more data than is ready; no events will be processed while the commands block. In non-blocking mode chan puts, chan read, and chan gets never block. \n\nThe script for a file event is executed at global level (outside the context of any Tcl procedure) in the interpreter in which the chan event command was invoked.  If an error occurs while executing the script then the command registered with interp bgerror is used to report the error.  In addition, the file event handler is deleted if it ever returns an error; this is done in order to prevent infinite loops due to buggy handlers. \n\nchan flush channelId Ensures that all pending output for the channel called channelId is written. \n\n If the channel is in blocking mode the command does not return until all the buffered output has been flushed to the channel. If the channel is in non-blocking mode, the command may return before all buffered output has been flushed; the remainder will be flushed in the background as fast as the underlying file or device is able to absorb it. \n\nchan gets channelId ?varName? Reads the next line from the channel called channelId. If varName is not specified, the result of the command will be the line that has been read (without a trailing newline character) or an empty string upon end-of-file or, in non-blocking mode, if the data available is exhausted. If varName is specified, the line that has been read will be written to the variable called varName and result will be the number of characters that have been read or -1 if end-of-file was reached or, in non-blocking mode, if the data available is exhausted. \n\n If an end-of-file occurs while part way through reading a line, the partial line will be returned (or written into varName). When varName is not specified, the end-of-file case can be distinguished from an empty line using the chan eof command, and the partial-line-but-non-blocking case can be distinguished with the chan blocked command. \n\nchan names ?pattern? Produces a list of all channel names. If pattern is specified, only those channel names that match it (according to the rules of string match) will be returned. \n\nchan pending mode channelId Depending on whether mode is input or output, returns the number of bytes of input or output (respectively) currently buffered  internally for channelId (especially useful in a readable event  callback to impose application-specific limits on input line lengths to avoid a potential denial-of-service attack where a hostile user crafts an extremely long line that exceeds the available memory to buffer it). Returns -1 if the channel was not opened for the mode in question. \n\nchan pipe Creates a standalone pipe whose read- and write-side channels are returned as a 2-element list, the first element being the read side and the second the write side. Can be useful e.g. to redirect separately stderr and stdout from a subprocess. To do this, spawn with \"2>@\" or \">@\" redirection operators onto the write side of a pipe, and then immediately close it in the parent. This is necessary to get an EOF on the read side once the child has exited or otherwise closed its output.  \n\nchan pop channelId Removes the topmost transformation from the channel channelId, if there is any. If there are no transformations added to channelId, this is equivalent to chan close of that channel. The result is normally the empty string, but can be an error in some situations (i.e. where the underlying system stream is closed and that results in an error). \n\nchan postevent channelId eventSpec This subcommand is used by command handlers specified with chan create. It notifies the channel represented by the handle channelId that the event(s) listed in the eventSpec have occurred. The argument has to be a list containing any of the strings read and write. The list must contain at least one element as it does not make sense to invoke the command if there are no events to post. \n\n Note that this subcommand can only be used with channel handles that were created/opened by chan create. All other channels will cause this subcommand to report an error. \n\n As only the Tcl level of a channel, i.e. its command handler, should post events to it we also restrict the usage of this command to the interpreter that created the channel. In other words, posting events to a reflected channel from an interpreter that does not contain it\'s implementation is not allowed. Attempting to post an event from any other interpreter will cause this subcommand to report an error. \n\n Another restriction is that it is not possible to post events that the I/O core has not registered an interest in. Trying to do so will cause the method to throw an error. See the command handler method watch described in refchan, the document specifying the API of command handlers for reflected channels. \n\nThis command is safe and made accessible to safe interpreters. It can trigger the execution of chan event handlers, whether in the current interpreter or in other interpreters or other threads, even where the event is posted from a safe interpreter and listened for by a trusted interpreter. Chan event handlers are always executed in the interpreter that set them up. \n\nchan push channelId cmdPrefix Adds a new transformation on top of the channel channelId. The cmdPrefix argument describes a list of one or more words which represent a handler that will be used to implement the transformation. The command prefix must provide the API described in the transchan manual page. The result of this subcommand is a handle to the transformation. Note that it is important to make sure that the transformation is capable of supporting the channel mode that it is used with or this can make the channel neither readable nor writable. \n\nchan puts ?-nonewline? ?channelId? string Writes string to the channel named channelId followed by a newline character. A trailing newline character is written unless the optional flag -nonewline is given. If channelId is omitted, the string is written to the standard output channel, stdout. \n\n Newline characters in the output are translated by chan puts to platform-specific end-of-line sequences according to the currently configured value of the -translation option for the channel (for example, on PCs newlines are normally replaced with carriage-return-linefeed sequences; see chan configure above for details). \n\n Tcl buffers output internally, so characters written with chan puts may not appear immediately on the output file or device; Tcl will normally delay output until the buffer is full or the channel is closed.  You can force output to appear immediately with the chan flush command. \n\nWhen the output buffer fills up, the chan puts command will normally block until all the buffered data has been accepted for output by the operating system.  If channelId is in non-blocking mode then the chan puts command will not block even if the operating system cannot accept the data.  Instead, Tcl continues to buffer the data and writes it in the background as fast as the underlying file or device can accept it.  The application must use the Tcl event loop for non-blocking output to work; otherwise Tcl never finds out that the file or device is ready for more output data.  It is possible for an arbitrarily large amount of data to be buffered for a channel in non-blocking mode, which could consume a large amount of memory.  To avoid wasting memory, non-blocking I/O should normally be used in an event-driven fashion with the chan event command (do not invoke chan puts unless you have recently been notified via a file event that the channel is ready for more output data). \n\nchan read channelId ?numChars? \n\nchan read ?-nonewline? channelId In the first form, the result will be the next numChars characters read from the channel named channelId; if numChars is omitted, all characters up to the point when the channel would signal a failure (whether an end-of-file, blocked or other error condition) are read. In the second form (i.e. when numChars has been omitted) the flag -nonewline may be given to indicate that any trailing newline in the string that has been read should be trimmed. \n\n If channelId is in non-blocking mode, chan read may not read as many characters as requested: once all available input has been read, the command will return the data that is available rather than blocking for more input.  If the channel is configured to use a multi-byte encoding, then there may actually be some bytes remaining in the internal buffers that do not form a complete character.  These bytes will not be returned until a complete character is available or end-of-file is reached.  The -nonewline switch is ignored if the command returns before reaching the end of the file. \n\n Chan read translates end-of-line sequences in the input into newline characters according to the -translation option for the channel (see chan configure above for a discussion on the ways in which chan configure will alter input). \n\n When reading from a serial port, most applications should configure the serial port channel to be non-blocking, like this: \n\n chan configure channelId -blocking 0. \n\n Then chan read behaves much like described above.  Note that most serial ports are comparatively slow; it is entirely possible to get a readable event for each character read from them. Care must be taken when using chan read on blocking serial ports: \n\n  chan read channelId numChars In this form chan read blocks until numChars have been received from the serial port. \n\nchan read channelId In this form chan read blocks until the reception of the end-of-file character, see chan configure -eofchar. If there no end-of-file character has been configured for the channel, then chan read will block forever. \n\n \n\nchan seek channelId offset ?origin? Sets the current access position within the underlying data stream for the channel named channelId to be offset bytes relative to origin. Offset must be an integer (which may be negative) and origin must be one of the following: \n\n  start The new access position will be offset bytes from the start of the underlying file or device. \n\ncurrent The new access position will be offset bytes from the current access position; a negative offset moves the access position backwards in the underlying file or device. \n\nend The new access position will be offset bytes from the end of the file or device.  A negative offset places the access position before the end of file, and a positive offset places the access position after the end of file. \n\n  \n\n The origin argument defaults to start. \n\n Chan seek flushes all buffered output for the channel before the command returns, even if the channel is in non-blocking mode.  It also discards any buffered and unread input.  This command returns an empty string.  An error occurs if this command is applied to channels whose underlying file or device does not support seeking. \n\n Note that offset values are byte offsets, not character offsets. Both chan seek and chan tell operate in terms of bytes, not characters, unlike chan read.  \n\nchan tell channelId Returns a number giving the current access position within the underlying data stream for the channel named channelId. This value returned is a byte offset that can be passed to chan seek in order to set the channel to a particular position.  Note that this value is in terms of bytes, not characters like chan read.  The value returned is -1 for channels that do not support seeking. \n\nchan truncate channelId ?length? Sets the byte length of the underlying data stream for the channel named channelId to be length (or to the current byte offset within the underlying data stream if length is omitted). The channel is flushed before truncation. \n\n "));
		docs.put("http", new TCLDoc("http", "Client-side implementation of the HTTP/1.1 protocol"," The http package provides the client side of the HTTP/1.1 protocol, as defined in RFC 2616. The package implements the GET, POST, and HEAD operations of HTTP/1.1.  It allows configuration of a proxy host to get through firewalls.  The package is compatible with the Safesock security policy, so it can be used by untrusted applets to do URL fetching from a restricted set of hosts. This package can be extended to support additional HTTP transport protocols, such as HTTPS, by providing a custom socket command, via ::http::register. \n\n The ::http::geturl procedure does a HTTP transaction. Its options  determine whether a GET, POST, or HEAD transaction is performed.   The return value of ::http::geturl is a token for the transaction. The value is also the name of an array in the ::http namespace that contains state information about the transaction.  The elements of this array are described in the STATE ARRAY section. \n\n If the -command option is specified, then the HTTP operation is done in the background. ::http::geturl returns immediately after generating the HTTP request and the callback is invoked when the transaction completes.  For this to work, the Tcl event loop must be active.  In Tk applications this is always true.  For pure-Tcl applications, the caller can use ::http::wait after calling ::http::geturl to start the event loop. "));
		docs.put("oo::define, oo::objdefine", new TCLDoc("oo::define, oo::objdefine", "define and configure classes and objects"," The oo::define command is used to control the configuration of classes, and the oo::objdefine command is used to control the configuration of objects (including classes as instance objects), with the configuration being applied to the entity named in the class or the object argument. Configuring a class also updates the configuration of all subclasses of the class and all objects that are instances of that class or which mix it in (as modified by any per-instance configuration). The way in which the configuration is done is controlled by either the defScript argument or by the subcommand and following arg arguments; when the second is present, it is exactly as if all the arguments from subcommand onwards are made into a list and that list is used as the defScript argument. CONFIGURING CLASSES The following commands are supported in the defScript for oo::define, each of which may also be used in the subcommand form: \n\n  constructor argList bodyScript This creates or updates the constructor for a class. The formal arguments to the constructor (defined using the same format as for the Tcl proc command) will be argList, and the body of the constructor will be bodyScript. When the body of the constructor is evaluated, the current namespace of the constructor will be a namespace that is unique to the object being constructed. Within the constructor, the next command should be used to call the superclasses\' constructors. If bodyScript is the empty string, the constructor will be deleted. \n\ndeletemethod name ?name ... This deletes each of the methods called name from a class. The methods must have previously existed in that class. Does not affect the superclasses of the class, nor does it affect the subclasses or instances of the class (except when they have a call chain through the class being modified). \n\ndestructor bodyScript This creates or updates the destructor for a class. Destructors take no arguments, and the body of the destructor will be bodyScript. The destructor is called when objects of the class are deleted, and when called will have the object\'s unique namespace as the current namespace. Destructors should use the next command to call the superclasses\' destructors. Note that destructors are not called in all situations (e.g. if the interpreter is destroyed). If bodyScript is the empty string, the destructor will be deleted.  Note that errors during the evaluation of a destructor are not returned to the code that causes the destruction of an object. Instead, they are passed to the currently-defined bgerror handler.  \n\nexport name ?name ...? This arranges for each of the named methods, name, to be exported (i.e. usable outside an instance through the instance object\'s command) by the class being defined. Note that the methods themselves may be actually defined by a superclass; subclass exports override superclass visibility, and may in turn be overridden by instances. \n\nfilter ?-slotOperation? ?methodName ...? This slot (see SLOTTED DEFINITIONS below) sets or updates the list of method names that are used to guard whether method call to instances of the class may be called and what the method\'s results are. Each methodName names a single filtering method (which may be exposed or not exposed); it is not an error for a non-existent method to be named since they may be defined by subclasses. By default, this slot works by appending. \n\nforward name cmdName ?arg ...? This creates or updates a forwarded method called name. The method is defined be forwarded to the command called cmdName, with additional arguments, arg etc., added before those arguments specified by the caller of the method. The cmdName will always be resolved using the rules of the invoking objects\' namespaces, i.e., when cmdName is not fully-qualified, the command will be searched for in each object\'s namespace, using the instances\' namespace\'s path, or by looking in the global namespace. The method will be exported if name starts with a lower-case letter, and non-exported otherwise. \n\nmethod name argList bodyScript This creates or updates a method that is implemented as a procedure-like script. The name of the method is name, the formal arguments to the method (defined using the same format as for the Tcl proc command) will be argList, and the body of the method will be bodyScript. When the body of the method is evaluated, the current namespace of the method will be a namespace that is unique to the current object. The method will be exported if name starts with a lower-case letter, and non-exported otherwise; this behavior can be overridden via export and unexport. \n\nmixin ?-slotOperation? ?className ...? This slot (see SLOTTED DEFINITIONS below) sets or updates the list of additional classes that are to be mixed into all the instances of the class being defined. Each className argument names a single class that is to be mixed in. By default, this slot works by replacement. \n\nrenamemethod fromName toName This renames the method called fromName in a class to toName. The method must have previously existed in the class, and toName must not previously refer to a method in that class. Does not affect the superclasses of the class, nor does it affect the subclasses or instances of the class (except when they have a call chain through the class being modified). Does not change the export status of the method; if it was exported before, it will be afterwards. \n\nself subcommand arg ... \n\nself script This command is equivalent to calling oo::objdefine on the class being defined (see CONFIGURING OBJECTS below for a description of the supported values of subcommand). It follows the same general pattern of argument handling as the oo::define and oo::objdefine commands, and &#8220;oo::define cls self subcommand ...&#8221; operates identically to &#8220;oo::objdefine cls subcommand ...&#8221;. \n\nsuperclass ?-slotOperation? ?className ...? This slot (see SLOTTED DEFINITIONS below) allows the alteration of the superclasses of the class being defined. Each className argument names one class that is to be a superclass of the defined class. Note that objects must not be changed from being classes to being non-classes or vice-versa, that an empty parent class is equivalent to oo::object, and that the parent classes of oo::object and oo::class may not be modified. By default, this slot works by replacement. \n\nunexport name ?name ...? This arranges for each of the named methods, name, to be not exported (i.e. not usable outside the instance through the instance object\'s command, but instead just through the my command visible in each object\'s context) by the class being defined. Note that the methods themselves may be actually defined by a superclass; subclass unexports override superclass visibility, and may be overridden by instance unexports. \n\nvariable ?-slotOperation? ?name ...? This slot (see SLOTTED DEFINITIONS below) arranges for each of the named variables to be automatically made available in the methods, constructor and destructor declared by the class being defined. Each variable name must not have any namespace separators and must not look like an array access. All variables will be actually present in the instance object on which the method is executed. Note that the variable lists declared by a superclass or subclass are completely disjoint, as are variable lists declared by instances; the list of variable names is just for methods (and constructors and destructors) declared by this class. By default, this slot works by appending. \n\n CONFIGURING OBJECTS The following commands are supported in the defScript for oo::objdefine, each of which may also be used in the subcommand form: \n\n  class className This allows the class of an object to be changed after creation. Note that the class\'s constructors are not called when this is done, and so the object may well be in an inconsistent state unless additional configuration work is done. \n\ndeletemethod name ?name ... This deletes each of the methods called name from an object. The methods must have previously existed in that object. Does not affect the classes that the object is an instance of. \n\nexport name ?name ...? This arranges for each of the named methods, name, to be exported (i.e. usable outside the object through the object\'s command) by the object being defined. Note that the methods themselves may be actually defined by a class or superclass; object exports override class visibility. \n\nfilter ?-slotOperation? ?methodName ...? This slot (see SLOTTED DEFINITIONS below) sets or updates the list of method names that are used to guard whether a method call to the object may be called and what the method\'s results are. Each methodName names a single filtering method (which may be exposed or not exposed); it is not an error for a non-existent method to be named. Note that the actual list of filters also depends on the filters set upon any classes that the object is an instance of. By default, this slot works by appending. \n\nforward name cmdName ?arg ...? This creates or updates a forwarded object method called name. The method is defined be forwarded to the command called cmdName, with additional arguments, arg etc., added before those arguments specified by the caller of the method. Forwarded methods should be deleted using the method subcommand. The method will be exported if name starts with a lower-case letter, and non-exported otherwise. \n\nmethod name argList bodyScript This creates, updates or deletes an object method. The name of the method is name, the formal arguments to the method (defined using the same format as for the Tcl proc command) will be argList, and the body of the method will be bodyScript. When the body of the method is evaluated, the current namespace of the method will be a namespace that is unique to the object. The method will be exported if name starts with a lower-case letter, and non-exported otherwise. \n\nmixin ?-slotOperation? ?className ...? This slot (see SLOTTED DEFINITIONS below) sets or updates a per-object list of additional classes that are to be mixed into the object. Each argument, className, names a single class that is to be mixed in. By default, this slot works by replacement. \n\nrenamemethod fromName toName This renames the method called fromName in an object to toName. The method must have previously existed in the object, and toName must not previously refer to a method in that object. Does not affect the classes that the object is an instance of. Does not change the export status of the method; if it was exported before, it will be afterwards. \n\nunexport name ?name ...? This arranges for each of the named methods, name, to be not exported (i.e. not usable outside the object through the object\'s command, but instead just through the my command visible in the object\'s context) by the object being defined. Note that the methods themselves may be actually defined by a class; instance unexports override class visibility. \n\nvariable ?-slotOperation? ?name ...? This slot (see SLOTTED DEFINITIONS below) arranges for each of the named variables to be automatically made available in the methods declared by the object being defined.  Each variable name must not have any namespace separators and must not look like an array access. All variables will be actually present in the object on which the method is executed. Note that the variable lists declared by the classes and mixins of which the object is an instance are completely disjoint; the list of variable names is just for methods declared by this object. By default, this slot works by appending. \n\n "));
		docs.put("tailcall", new TCLDoc("tailcall", "Replace the current procedure with another command"," The tailcall command replaces the currently executing procedure, lambda application, or method with another command. The command, which will have arg ... passed as arguments if they are supplied, will be looked up in the current namespace context, not in the caller\'s. Apart from that difference in resolution, it is equivalent to: \n\n return [uplevel 1 [list command ?arg ...?]] \n\n This command may not be invoked from within an uplevel into a procedure or inside a catch inside a procedure or lambda. "));
		docs.put("update", new TCLDoc("update", "Process pending events and idle callbacks"," This command is used to bring the application &#8220;up to date&#8221; by entering the event loop repeatedly until all pending events (including idle callbacks) have been processed. \n\n If the idletasks keyword is specified as an argument to the command, then no new events or errors are processed;  only idle callbacks are invoked. This causes operations that are normally deferred, such as display updates and window layout calculations, to be performed immediately. \n\n The update idletasks command is useful in scripts where changes have been made to the application\'s state and you want those changes to appear on the display immediately, rather than waiting for the script to complete.  Most display updates are performed as idle callbacks, so update idletasks will cause them to run. However, there are some kinds of updates that only happen in response to events, such as those triggered by window size changes; these updates will not occur in update idletasks. \n\n The update command with no options is useful in scripts where you are performing a long-running computation but you still want the application to respond to events such as user interactions;  if you occasionally call update then user input will be processed during the next call to update. "));
		docs.put("clock", new TCLDoc("clock", "Obtain and manipulate dates and times"," The clock command performs several operations that obtain and manipulate values that represent times.  The command supports several subcommands that determine what action is carried out by the command. \n\n  clock add timeVal ?count unit...? ?-option value? Adds a (possibly negative) offset to a time that is expressed as an integer number of seconds.  See CLOCK ARITHMETIC for a full description. \n\nclock clicks ?-option? If no -option argument is supplied, returns a high-resolution time value as a system-dependent integer value.  The unit of the value is system-dependent but should be the highest resolution clock available on the system such as a CPU cycle counter.  See HIGH RESOLUTION TIMERS for a full description. \n\n If the -option argument is -milliseconds, then the command is synonymous with clock milliseconds (see below).  This usage is obsolete, and clock milliseconds is to be considered the preferred way of obtaining a count of milliseconds. \n\nIf the -option argument is -microseconds, then the command is synonymous with clock microseconds (see below).  This usage is obsolete, and clock microseconds is to be considered the preferred way of obtaining a count of microseconds. \n\nclock format timeVal ?-option value...? Formats a time that is expressed as an integer number of seconds into a format intended for consumption by users or external programs. See FORMATTING TIMES for a full description. \n\nclock microseconds Returns the current time as an integer number of microseconds.  See HIGH RESOLUTION TIMERS for a full description. \n\nclock milliseconds Returns the current time as an integer number of milliseconds.  See HIGH RESOLUTION TIMERS for a full description. \n\nclock scan inputString ?-option value...? Scans a time that is expressed as a character string and produces an integer number of seconds. See SCANNING TIMES for a full description. \n\nclock seconds Returns the current time as an integer number of seconds. \n\n PARAMETERS  count An integer representing a count of some unit of time.  See CLOCK ARITHMETIC for the details. \n\ntimeVal An integer value passed to the clock command that represents an absolute time as a number of seconds from the epoch time of 1 January 1970, 00:00 UTC.  Note that the count of seconds does not include any leap seconds; seconds are counted as if each UTC day has exactly 86400 seconds.  Tcl responds to leap seconds by speeding or slowing its clock by a tiny fraction for some minutes until it is back in sync with UTC; its data model does not represent minutes that have 59 or 61 seconds. \n\nunit One of the words, seconds, minutes, hours, days, weeks, months, or years, or any unique prefix of such a word. Used in conjunction with count to identify an interval of time, for example, 3 seconds or 1 year. \n\n OPTIONS  -base time Specifies that any relative times present in a clock scan command are to be given relative to time.  time must be expressed as a count of nominal seconds from the epoch time of 1 January 1970, 00:00 UTC. \n\n-format format Specifies the desired output format for clock format or the expected input format for clock scan.  The format string consists of any number of characters other than the per-cent sign (&#8220;%&#8221;) interspersed with any number of format groups, which are two-character sequences beginning with the per-cent sign.  The permissible format groups, and their interpretation, are described under FORMAT GROUPS. \n\n On clock format, the default format is \n\n %a %b %d %H:%M:%S %z %Y \n\nOn clock scan, the lack of a -format option indicates that a &#8220;free format scan&#8221; is requested; see FREE FORM SCAN for a description of what happens. \n\n-gmt boolean If boolean is true, specifies that a time specified to clock add, clock format or clock scan should be processed in UTC.  If boolean is false, the processing defaults to the local time zone.  This usage is obsolete; the correct current usage is to specify the UTC time zone with &#8220;-timezone :UTC&#8221; or any of the equivalent ways to specify it. \n\n-locale localeName Specifies that locale-dependent scanning and formatting (and date arithmetic for dates preceding the adoption of the Gregorian calendar) is to be done in the locale identified by localeName.  The locale name may be any of the locales acceptable to the msgcat package, or it may be the special name system, which represents the current locale of the process, or the null string, which represents Tcl\'s default locale. \n\n The effect of locale on scanning and formatting is discussed in the descriptions of the individual format groups under FORMAT GROUPS. The effect of locale on clock arithmetic is discussed under CLOCK ARITHMETIC. \n\n-timezone zoneName Specifies that clock arithmetic, formatting, and scanning are to be done according to the rules for the time zone specified by zoneName. The permissible values, and their interpretation, are discussed under TIME ZONES. On subcommands that expect a -timezone argument, the default is to use the current time zone.  The current time zone is determined, in order of preference, by: \n\n   the environment variable TCL_TZ. \n\n the environment variable TZ. \n\n on Windows systems, the time zone settings from the Control Panel. \n\n \n\n \n\n If none of these is present, the C localtime and mktime functions are used to attempt to convert times between local and Greenwich.  On 32-bit systems, this approach is likely to have bugs, particularly for times that lie outside the window (approximately the years 1902 to 2037) that can be represented in a 32-bit integer. "));
		docs.put("if", new TCLDoc("if", "Execute scripts conditionally"," The if command evaluates expr1 as an expression (in the same way that expr evaluates its argument).  The value of the expression must be a boolean (a numeric value, where 0 is false and anything is true, or a string value such as true or yes for true and false or no for false); if it is true then body1 is executed by passing it to the Tcl interpreter. Otherwise expr2 is evaluated as an expression and if it is true then body2 is executed, and so on. If none of the expressions evaluates to true then bodyN is executed. The then and else arguments are optional &#8220;noise words&#8221; to make the command easier to read. There may be any number of elseif clauses, including zero. BodyN may also be omitted as long as else is omitted too. The return value from the command is the result of the body script that was executed, or an empty string if none of the expressions was non-zero and there was no bodyN. "));
		docs.put("oo::object", new TCLDoc("oo::object", "root class of the class hierarchy",""));
		docs.put("Tcl", new TCLDoc("Tcl", "Tool Command Language"," The following rules define the syntax and semantics of the Tcl language: \n\n  [1] Commands. A Tcl script is a string containing one or more commands. Semi-colons and newlines are command separators unless quoted as described below. Close brackets are command terminators during command substitution (see below) unless quoted. \n\n[2] Evaluation. A command is evaluated in two steps. First, the Tcl interpreter breaks the command into words and performs substitutions as described below. These substitutions are performed in the same way for all commands. The first word is used to locate a command procedure to carry out the command, then all of the words of the command are passed to the command procedure. The command procedure is free to interpret each of its words in any way it likes, such as an integer, variable name, list, or Tcl script. Different commands interpret their words differently. \n\n[3] Words. Words of a command are separated by white space (except for newlines, which are command separators). \n\n[4] Double quotes. If the first character of a word is double-quote (&#8220;\"&#8221;) then the word is terminated by the next double-quote character. If semi-colons, close brackets, or white space characters (including newlines) appear between the quotes then they are treated as ordinary characters and included in the word. Command substitution, variable substitution, and backslash substitution are performed on the characters between the quotes as described below. The double-quotes are not retained as part of the word. \n\n[5] Argument expansion. If a word starts with the string &#8220;{*}&#8221; followed by a non-whitespace character, then the leading &#8220;{*}&#8221; is removed and the rest of the word is parsed and substituted as any other word. After substitution, the word is parsed as a list (without command or variable substitutions; backslash substitutions are performed as is normal for a list and individual internal words may be surrounded by either braces or double-quote characters), and its words are added to the command being substituted. For instance, &#8220;cmd a {*}{b [c]} d {*}{$e f {g h}}&#8221; is equivalent to &#8220;cmd a b {[c]} d {$e} f {g h}&#8221;. \n\n[6] Braces. If the first character of a word is an open brace (&#8220;{&#8221;) and rule [5] does not apply, then the word is terminated by the matching close brace (&#8220;}&#8221;). Braces nest within the word: for each additional open brace there must be an additional close brace (however, if an open brace or close brace within the word is quoted with a backslash then it is not counted in locating the matching close brace). No substitutions are performed on the characters between the braces except for backslash-newline substitutions described below, nor do semi-colons, newlines, close brackets, or white space receive any special interpretation. The word will consist of exactly the characters between the outer braces, not including the braces themselves. \n\n[7] Command substitution. If a word contains an open bracket (&#8220;[&#8221;) then Tcl performs command substitution. To do this it invokes the Tcl interpreter recursively to process the characters following the open bracket as a Tcl script. The script may contain any number of commands and must be terminated by a close bracket (&#8220;]&#8221;). The result of the script (i.e. the result of its last command) is substituted into the word in place of the brackets and all of the characters between them. There may be any number of command substitutions in a single word. Command substitution is not performed on words enclosed in braces. \n\n[8] Variable substitution. If a word contains a dollar-sign (&#8220;$&#8221;) followed by one of the forms described below, then Tcl performs variable substitution:  the dollar-sign and the following characters are replaced in the word by the value of a variable. Variable substitution may take any of the following forms: \n\n  $name Name is the name of a scalar variable;  the name is a sequence of one or more characters that are a letter, digit, underscore, or namespace separators (two or more colons). Letters and digits are only the standard ASCII ones (0-9, A-Z and a-z). \n\n$name(index) Name gives the name of an array variable and index gives the name of an element within that array. Name must contain only letters, digits, underscores, and namespace separators, and may be an empty string. Letters and digits are only the standard ASCII ones (0-9, A-Z and a-z). Command substitutions, variable substitutions, and backslash substitutions are performed on the characters of index. \n\n${name} Name is the name of a scalar variable or array element.  It may contain any characters whatsoever except for close braces.  It indicates an array element if name is in the form &#8220;arrayName(index)&#8221; where arrayName does not contain any open parenthesis characters, &#8220;(&#8221;, or close brace characters, &#8220;}&#8221;, and index can be any sequence of characters except for close brace characters.  No further substitutions are performed during the parsing of name. \n\n  \n\n There may be any number of variable substitutions in a single word. Variable substitution is not performed on words enclosed in braces. \n\n Note that variables may contain character sequences other than those listed above, but in that case other mechanisms must be used to access them (e.g., via the set command\'s single-argument form).  \n\n[9] Backslash substitution. If a backslash (&#8220;\\&#8221;) appears within a word then backslash substitution occurs. In all cases but those described below the backslash is dropped and the following character is treated as an ordinary character and included in the word. This allows characters such as double quotes, close brackets, and dollar signs to be included in words without triggering special processing. The following table lists the backslash sequences that are handled specially, along with the value that replaces each sequence. \n\n  \\a Audible alert (bell) (0x7). \n\n\\b Backspace (0x8). \n\n\\f Form feed (0xc). \n\n\\n Newline (0xa). \n\n\\r Carriage-return (0xd). \n\n\\t Tab (0x9). \n\n\\v Vertical tab (0xb). \n\n\\whiteSpace A single space character replaces the backslash, newline, and all spaces and tabs after the newline.  This backslash sequence is unique in that it is replaced in a separate pre-pass before the command is actually parsed. This means that it will be replaced even when it occurs between braces, and the resulting space will be treated as a word separator if it is not in braces or quotes. \n\n\\\\ Backslash (&#8220;\\&#8221;). \n\n\\ooo The digits ooo (one, two, or three of them) give a eight-bit octal  value for the Unicode character that will be inserted, in the range 000 - 377.  The parser will stop just before this range overflows, or when the maximum of three digits is reached.  The upper bits of the Unicode character will be 0. \n\n\\xhh The hexadecimal digits hh (one or two of them) give an eight-bit hexadecimal value for the Unicode character that will be inserted.  The upper bits of the Unicode character will be 0. \n\n\\uhhhh The hexadecimal digits hhhh (one, two, three, or four of them) give a sixteen-bit hexadecimal value for the Unicode character that will be inserted.  The upper bits of the Unicode character will be 0. \n\n\\Uhhhhhhhh The hexadecimal digits hhhhhhhh (one up to eight of them) give a twenty-one-bit hexadecimal value for the Unicode character that will be inserted, in the range U+0000..U+10FFFF.  The parser will stop just before this range overflows, or when the maximum of eight digits is reached.  The upper bits of the Unicode character will be 0. \n\n  \n\n The range U+010000..U+10FFFD is reserved for the future. \n\n Backslash substitution is not performed on words enclosed in braces, except for backslash-newline as described above.  \n\n[10] Comments. If a hash character (&#8220;#&#8221;) appears at a point where Tcl is expecting the first character of the first word of a command, then the hash character and the characters that follow it, up through the next newline, are treated as a comment and ignored. The comment character only has significance when it appears at the beginning of a command. \n\n[11] Order of substitution. Each character is processed exactly once by the Tcl interpreter as part of creating the words of a command. For example, if variable substitution occurs then no further substitutions are performed on the value of the variable;  the value is inserted into the word verbatim. If command substitution occurs then the nested command is processed entirely by the recursive call to the Tcl interpreter; no substitutions are performed before making the recursive call and no additional substitutions are performed on the result of the nested script. \n\n Substitutions take place from left to right, and each substitution is evaluated completely before attempting to evaluate the next.  Thus, a sequence like \n\n set y [set x 0][incr x][incr x] \n\nwill always set the variable y to the value, 012. \n\n[12] Substitution and word boundaries. Substitutions do not affect the word boundaries of a command, except for argument expansion as specified in rule [5]. For example, during variable substitution the entire value of the variable becomes part of a single word, even if the variable\'s value contains spaces. \n\n "));
		docs.put("uplevel", new TCLDoc("uplevel", "Execute a script in a different stack frame"," All of the arg arguments are concatenated as if they had been passed to concat; the result is then evaluated in the variable context indicated by level.  Uplevel returns the result of that evaluation. \n\n If level is an integer then it gives a distance (up the procedure calling stack) to move before executing the command.  If level consists of # followed by a number then the number gives an absolute level number.  If level is omitted then it defaults to 1.  Level cannot be defaulted if the first command argument starts with a digit or #. \n\n For example, suppose that procedure a was invoked from top-level, and that it called b, and that b called c. Suppose that c invokes the uplevel command.  If level is 1 or #2  or omitted, then the command will be executed in the variable context of b.  If level is 2 or #1 then the command will be executed in the variable context of a. If level is 3 or #0 then the command will be executed at top-level (only global variables will be visible). \n\n The uplevel command causes the invoking procedure to disappear from the procedure calling stack while the command is being executed. In the above example, suppose c invokes the command \n\n uplevel 1 {set x 43; d} \n\n where d is another Tcl procedure.  The set command will modify the variable x in b\'s context, and d will execute at level 3, as if called from b.  If it in turn executes the command \n\n uplevel {set x 42} \n\n then the set command will modify the same variable x in b\'s context:  the procedure c does not appear to be on the call stack when d is executing.  The info level command may be used to obtain the level of the current procedure. \n\n Uplevel makes it possible to implement new control constructs as Tcl procedures (for example, uplevel could be used to implement the while construct as a Tcl procedure). \n\n The namespace eval and apply commands offer other ways (besides procedure calls) that the Tcl naming context can change. They add a call frame to the stack to represent the namespace context. This means each namespace eval command counts as another call level for uplevel and upvar commands. For example, info level 1 will return a list describing a command that is either the outermost procedure call or the outermost namespace eval command. Also, uplevel #0 evaluates a script at top-level in the outermost namespace (the global namespace). "));
		docs.put("close", new TCLDoc("close", "Close an open channel"," Closes or half-closes the channel given by channelId. \n\n ChannelId must be an identifier for an open channel such as a Tcl standard channel (stdin, stdout, or stderr), the return value from an invocation of open or socket, or the result of a channel creation command provided by a Tcl extension. \n\n The single-argument form is a simple &#8220;full-close&#8221;: all buffered output is flushed to the channel\'s output device, any buffered input is discarded, the underlying file or device is closed, and channelId becomes unavailable for use. \n\n If the channel is blocking, the command does not return until all output is flushed. If the channel is nonblocking and there is unflushed output, the channel remains open and the command returns immediately; output will be flushed in the background and the channel will be closed when all the flushing is complete. \n\n If channelId is a blocking channel for a command pipeline then close waits for the child processes to complete. \n\n If the channel is shared between interpreters, then close makes channelId unavailable in the invoking interpreter but has no other effect until all of the sharing interpreters have closed the channel. When the last interpreter in which the channel is registered invokes close, the cleanup actions described above occur. See the interp command for a description of channel sharing. \n\n Channels are automatically closed when an interpreter is destroyed and when the process exits. From 8.6 on (TIP#398), nonblocking channels are no longer switched to blocking mode when exiting; this guarantees a timely exit even when the peer or a communication channel is stalled. To ensure proper flushing of stalled nonblocking channels on exit, one must now either (a) actively switch them back to blocking or (b) use the environment variable TCL_FLUSH_NONBLOCKING_ON_EXIT,  which when set and not equal to \"0\" restores the previous behavior. \n\n The command returns an empty string, and may generate an error if an error occurs while flushing output.  If a command in a command pipeline created with open returns an error, close generates an error (similar to the exec command.) \n\n The two-argument form is a &#8220;half-close&#8221;: given a bidirectional channel like a socket or command pipeline and a (possibly abbreviated) direction, it closes only the sub-stream going in that direction. This means a shutdown() on a socket, and a close() of one end of a pipe for a command pipeline. Then, the Tcl-level channel data structure is either kept or freed depending on whether the other direction is still open. \n\n A single-argument close on an already half-closed bidirectional channel is defined to just &#8220;finish the job&#8221;. A half-close on an already closed half, or on a wrong-sided unidirectional channel, raises an error. \n\n In the case of a command pipeline, the child-reaping duty falls upon the shoulders of the last close or half-close, which is thus allowed to report an abnormal exit error. \n\n Currently only sockets and command pipelines support half-close. A future extension will allow reflected and stacked channels to do so. "));
		docs.put("incr", new TCLDoc("incr", "Increment the value of a variable"," Increments the value stored in the variable whose name is varName. The value of the variable must be an integer. If increment is supplied then its value (which must be an integer) is added to the value of variable varName;  otherwise 1 is added to varName. The new value is stored as a decimal string in variable varName and also returned as result. \n\n Starting with the Tcl 8.5 release, the variable varName passed to incr may be unset, and in that case, it will be set to the value increment or to the default increment value of 1. "));
		docs.put("open", new TCLDoc("open", "Open a file-based or command pipeline channel"," This command opens a file, serial port, or command pipeline and returns a channel identifier that may be used in future invocations of commands like read, puts, and close. If the first character of fileName is not | then the command opens a file: fileName gives the name of the file to open, and it must conform to the conventions described in the filename manual entry. \n\n The access argument, if present, indicates the way in which the file (or command pipeline) is to be accessed. In the first form access may have any of the following values: \n\n  r Open the file for reading only; the file must already exist. This is the default value if access is not specified. \n\nr+ Open the file for both reading and writing; the file must already exist. \n\nw Open the file for writing only.  Truncate it if it exists.  If it does not exist, create a new file. \n\nw+ Open the file for reading and writing.  Truncate it if it exists. If it does not exist, create a new file. \n\na Open the file for writing only.  If the file does not exist, create a new empty file. Set the file pointer to the end of the file prior to each write. \n\na+ Open the file for reading and writing.  If the file does not exist, create a new empty file. Set the initial access position  to the end of the file. \n\n \n\n All of the legal access values above may have the character b added as the second or third character in the value to indicate that the opened channel should be configured as if with the fconfigure -translation binary option, making the channel suitable for  reading or writing of binary data. \n\n In the second form, access consists of a list of any of the following flags, all of which have the standard POSIX meanings. One of the flags must be either RDONLY, WRONLY or RDWR. \n\n  RDONLY Open the file for reading only. \n\nWRONLY Open the file for writing only. \n\nRDWR Open the file for both reading and writing. \n\nAPPEND Set the file pointer to the end of the file prior to each write. \n\nBINARY Configure the opened channel with the -translation binary option. \n\nCREAT Create the file if it does not already exist (without this flag it is an error for the file not to exist). \n\nEXCL If CREAT is also specified, an error is returned if the file already exists. \n\nNOCTTY If the file is a terminal device, this flag prevents the file from becoming the controlling terminal of the process. \n\nNONBLOCK Prevents the process from blocking while opening the file, and possibly in subsequent I/O operations.  The exact behavior of this flag is system- and device-dependent;  its use is discouraged (it is better to use the fconfigure command to put a file in nonblocking mode). For details refer to your system documentation on the open system call\'s O_NONBLOCK flag. \n\nTRUNC If the file exists it is truncated to zero length. \n\n \n\n If a new file is created as part of opening it, permissions (an integer) is used to set the permissions for the new file in conjunction with the process\'s file mode creation mask. Permissions defaults to 0666. "));
		docs.put("tcl::prefix", new TCLDoc("tcl::prefix", "facilities for prefix matching"," This document describes commands looking up a prefix in a list of strings. The following commands are supported: \n\n  ::tcl::prefix all table string Returns a list of all elements in table that begin with the prefix string. \n\n::tcl::prefix longest table string Returns the longest common prefix of all elements in table that begin with the prefix string. \n\n::tcl::prefix match ?options? table string If string equals one element in table or is a prefix to exactly one element, the matched element is returned. If not, the result depends on the -error option. (It is recommended that the table be sorted before use with this subcommand, so that the list of matches presented in the error message also becomes sorted, though this is not strictly necessary for the operation of this subcommand itself.) \n\n  -exact Accept only exact matches. \n\n-message string Use string in the error message at a mismatch. Default is &#8220;option&#8221;. \n\n-error options The options are used when no match is found. If options is empty, no error is generated and an empty string is returned. Otherwise the options are used as return options when generating the error message. The default corresponds to setting &#8220;-level 0&#8221;. Example: If &#8220;-error {-errorcode MyError -level 1}&#8221; is used, an error would be generated as: \n\n return -errorcode MyError -level 1 -code error \\        \"ambiguous option ...\" \n\n \n\n "));
		docs.put("upvar", new TCLDoc("upvar", "Create link to variable in a different stack frame"," This command arranges for one or more local variables in the current procedure to refer to variables in an enclosing procedure call or to global variables. Level may have any of the forms permitted for the uplevel command, and may be omitted (it defaults to 1). For each otherVar argument, upvar makes the variable by that name in the procedure frame given by level (or at global level, if level is #0) accessible in the current procedure by the name given in the corresponding myVar argument. The variable named by otherVar need not exist at the time of the call;  it will be created the first time myVar is referenced, just like an ordinary variable.  There must not exist a variable by the name myVar at the time upvar is invoked. MyVar is always treated as the name of a variable, not an array element.  An error is returned if the name looks like an array element, such as a(b). OtherVar may refer to a scalar variable, an array, or an array element. Upvar returns an empty string. \n\n The upvar command simplifies the implementation of call-by-name procedure calling and also makes it easier to build new control constructs as Tcl procedures. For example, consider the following procedure: \n\n proc add2 name {     upvar $name x     set x [expr {$x + 2}] } \n\n If add2 is invoked with an argument giving the name of a variable, it adds two to the value of that variable. Although add2 could have been implemented using uplevel instead of upvar, upvar makes it simpler for add2 to access the variable in the caller\'s procedure frame. \n\n namespace eval is another way (besides procedure calls) that the Tcl naming context can change. It adds a call frame to the stack to represent the namespace context. This means each namespace eval command counts as another call level for uplevel and upvar commands. For example, info level 1 will return a list describing a command that is either the outermost procedure call or the outermost namespace eval command. Also, uplevel #0 evaluates a script at top-level in the outermost namespace (the global namespace). \n\n If an upvar variable is unset (e.g. x in add2 above), the unset operation affects the variable it is linked to, not the upvar variable.  There is no way to unset an upvar variable except by exiting the procedure in which it is defined.  However, it is possible to retarget an upvar variable by executing another upvar command. "));
		docs.put("concat", new TCLDoc("concat", "Join lists together"," This command joins each of its arguments together with spaces after trimming leading and trailing white-space from each of them.  If all of the arguments are lists, this has the same effect as concatenating them into a single list. It permits any number of arguments; if no args are supplied, the result is an empty string. "));
		docs.put("info", new TCLDoc("info", "Return information about the state of the Tcl interpreter"," This command provides information about various internals of the Tcl interpreter. The legal options (which may be abbreviated) are: \n\n  info args procname Returns a list containing the names of the arguments to procedure procname, in order.  Procname must be the name of a Tcl command procedure. \n\ninfo body procname Returns the body of procedure procname.  Procname must be the name of a Tcl command procedure. \n\ninfo class subcommand class ?arg ... Returns information about the class, class. The subcommands are described in CLASS INTROSPECTION below. \n\ninfo cmdcount Returns a count of the total number of commands that have been invoked in this interpreter. \n\ninfo commands ?pattern? If pattern is not specified, returns a list of names of all the Tcl commands visible (i.e. executable without using a qualified name) to the current namespace, including both the built-in commands written in C and the command procedures defined using the proc command. If pattern is specified, only those names matching pattern are returned. Matching is determined using the same rules as for string match. pattern can be a qualified name like Foo::print*. That is, it may specify a particular namespace using a sequence of namespace names separated by double colons (::), and may have pattern matching special characters at the end to specify a set of commands in that namespace. If pattern is a qualified name, the resulting list of command names has each one qualified with the name of the specified namespace, and only the commands defined in the named namespace are returned. \n\ninfo complete command Returns 1 if command is a complete Tcl command in the sense of having no unclosed quotes, braces, brackets or array element names. If the command does not appear to be complete then 0 is returned. This command is typically used in line-oriented input environments to allow users to type in commands that span multiple lines;  if the command is not complete, the script can delay evaluating it until additional lines have been typed to complete the command. \n\ninfo coroutine Returns the name of the currently executing coroutine, or the empty string if either no coroutine is currently executing, or the current coroutine has been deleted (but has not yet returned or yielded since deletion). \n\ninfo default procname arg varname Procname must be the name of a Tcl command procedure and arg must be the name of an argument to that procedure.  If arg does not have a default value then the command returns 0. Otherwise it returns 1 and places the default value of arg into variable varname. \n\ninfo errorstack ?interp? Returns, in a form that is programmatically easy to parse, the function names and arguments at each level from the call stack of the last error in the given interp, or in the current one if not specified. \n\n This form is an even-sized list alternating tokens and parameters. Tokens are currently either CALL, UP, or INNER, but other values may be introduced in the future. CALL indicates a procedure call, and its parameter is the corresponding info level 0. UP indicates a shift in variable frames generated by uplevel or similar, and applies to the previous CALL item. Its parameter is the level offset. INNER identifies the &#8220;inner context&#8221;, which is the innermost atomic command or bytecode instruction that raised the error, along with its arguments when available. While CALL and UP allow to follow complex call paths, INNER homes in on the offending operation in the innermost procedure call, even going to sub-expression granularity. \n\nThis information is also present in the -errorstack entry of the options dictionary returned by 3-argument catch; info errorstack is a convenient way of retrieving it for uncaught errors at top-level in an interactive tclsh. \n\ninfo exists varName Returns 1 if the variable named varName exists in the current context (either as a global or local variable) and has been defined by being given a value, returns 0 otherwise. \n\ninfo frame ?number? This command provides access to all frames on the stack, even those hidden from info level. If number is not specified, this command returns a number giving the frame level of the command. This is 1 if the command is invoked at top-level. If number is specified, then the result is a dictionary containing the location information for the command at the numbered level on the stack. \n\n If number is positive (> 0) then it selects a particular stack level (1 refers to the outer-most active command, 2 to the command it called, and so on, up to the current frame level which refers to info frame itself); otherwise it gives a level relative to the current command (0 refers to the current command, i.e., info frame itself, -1 to its caller, and so on). \n\n This is similar to how info level works, except that this subcommand reports all frames, like sourced scripts, evals, uplevels, etc. \n\n Note that for nested commands, like &#8220;foo [bar [x]]&#8221;, only &#8220;x&#8221; will be seen by an info frame invoked within &#8220;x&#8221;. This is the same as for info level and error stack traces. \n\n The result dictionary may contain the keys listed below, with the specified meanings for their values: \n\n  type This entry is always present and describes the nature of the location for the command. The recognized values are source, proc, eval, and precompiled. \n\n  source means that the command is found in a script loaded by the source command. \n\nproc means that the command is found in dynamically created procedure body. \n\neval means that the command is executed by eval or uplevel. \n\nprecompiled means that the command is found in a pre-compiled script (loadable by the package tbcload), and no further information will be available. \n\n \n\nline This entry provides the number of the line the command is at inside of the script it is a part of. This information is not present for type precompiled. For type source this information is counted relative to the beginning of the file, whereas for the last two types the line is counted relative to the start of the script. \n\nfile This entry is present only for type source. It provides the normalized path of the file the command is in. \n\ncmd This entry provides the string representation of the command. This is usually the unsubstituted form, however for commands which are a canonically-constructed list (e.g., as produced by the list command) executed by eval it is the substituted form as they have no other string representation. Care is taken that the canonicality property of the latter is not spoiled. \n\nproc This entry is present only if the command is found in the body of a regular Tcl procedure. It then provides the name of that procedure. \n\nlambda This entry is present only if the command is found in the body of an anonymous Tcl procedure, i.e. a lambda. It then provides the entire definition of the lambda in question. \n\nlevel This entry is present only if the queried frame has a corresponding frame returned by info level. It provides the index of this frame, relative to the current level (0 and negative numbers). \n\n \n\n A thing of note is that for procedures statically defined in files the locations of commands in their bodies will be reported with type source and absolute line numbers, and not as type proc. The same is true for procedures nested in statically defined procedures, and literal eval scripts in files or statically defined procedures. \n\n In contrast, procedure definitions and eval within a dynamically evaluated environment count line numbers relative to the start of their script, even if they would be able to count relative to the start of the outer dynamic script. That type of number usually makes more sense. \n\n A different way of describing this behaviour is that file based locations are tracked as deeply as possible, and where this is not possible the lines are counted based on the smallest possible eval or procedure body, as that scope is usually easier to find than any dynamic outer scope. \n\nThe syntactic form {*} is handled like eval. I.e. if it is given a literal list argument the system tracks the line number within the list words as well, and otherwise all line numbers are counted relative to the start of each word (smallest scope) \n\ninfo functions ?pattern? If pattern is not specified, returns a list of all the math functions currently defined. If pattern is specified, only those functions whose name matches pattern are returned.  Matching is determined using the same rules as for string match. \n\ninfo globals ?pattern? If pattern is not specified, returns a list of all the names of currently-defined global variables. Global variables are variables in the global namespace. If pattern is specified, only those names matching pattern are returned.  Matching is determined using the same rules as for string match. \n\ninfo hostname Returns the name of the computer on which this invocation is being executed. Note that this name is not guaranteed to be the fully qualified domain name of the host.  Where machines have several different names (as is common on systems with both TCP/IP (DNS) and NetBIOS-based networking installed,) it is the name that is suitable for TCP/IP networking that is returned. \n\ninfo level ?number? If number is not specified, this command returns a number giving the stack level of the invoking procedure, or 0 if the command is invoked at top-level.  If number is specified, then the result is a list consisting of the name and arguments for the procedure call at level number on the stack.  If number is positive then it selects a particular stack level (1 refers to the top-most active procedure, 2 to the procedure it called, and so on); otherwise it gives a level relative to the current level (0 refers to the current procedure, -1 to its caller, and so on). See the uplevel command for more information on what stack levels mean. \n\ninfo library Returns the name of the library directory in which standard Tcl scripts are stored. This is actually the value of the tcl_library variable and may be changed by setting tcl_library. See the tclvars manual entry for more information. \n\ninfo loaded ?interp? Returns a list describing all of the packages that have been loaded into interp with the load command. Each list element is a sub-list with two elements consisting of the name of the file from which the package was loaded and the name of the package. For statically-loaded packages the file name will be an empty string. If interp is omitted then information is returned for all packages loaded in any interpreter in the process. To get a list of just the packages in the current interpreter, specify an empty string for the interp argument. \n\ninfo locals ?pattern? If pattern is not specified, returns a list of all the names of currently-defined local variables, including arguments to the current procedure, if any. Variables defined with the global, upvar  and variable commands will not be returned. If pattern is specified, only those names matching pattern are returned.  Matching is determined using the same rules as for string match. \n\ninfo nameofexecutable Returns the full path name of the binary file from which the application was invoked.  If Tcl was unable to identify the file, then an empty string is returned. \n\ninfo object subcommand object ?arg ... Returns information about the object, object. The subcommands are described in OBJECT INTROSPECTION below. \n\ninfo patchlevel Returns the value of the global variable tcl_patchLevel; see the tclvars manual entry for more information. \n\ninfo procs ?pattern? If pattern is not specified, returns a list of all the names of Tcl command procedures in the current namespace. If pattern is specified, only those procedure names in the current namespace matching pattern are returned. Matching is determined using the same rules as for string match. If pattern contains any namespace separators, they are used to select a namespace relative to the current namespace (or relative to the global namespace if pattern starts with ::) to match within; the matching pattern is taken to be the part after the last namespace separator. \n\ninfo script ?filename? If a Tcl script file is currently being evaluated (i.e. there is a call to Tcl_EvalFile active or there is an active invocation of the source command), then this command returns the name of the innermost file being processed.  If filename is specified, then the return value of this command will be modified for the duration of the active invocation to return that name.  This is useful in virtual file system applications. Otherwise the command returns an empty string. \n\ninfo sharedlibextension Returns the extension used on this platform for the names of files containing shared libraries (for example, .so under Solaris). If shared libraries are not supported on this platform then an empty string is returned. \n\ninfo tclversion Returns the value of the global variable tcl_version; see the tclvars manual entry for more information. \n\ninfo vars ?pattern? If pattern is not specified, returns a list of all the names of currently-visible variables. This includes locals and currently-visible globals. If pattern is specified, only those names matching pattern are returned.  Matching is determined using the same rules as for string match. pattern can be a qualified name like Foo::option*. That is, it may specify a particular namespace using a sequence of namespace names separated by double colons (::), and may have pattern matching special characters at the end to specify a set of variables in that namespace. If pattern is a qualified name, the resulting list of variable names has each matching namespace variable qualified with the name of its namespace. Note that a currently-visible variable may not yet &#8220;exist&#8221; if it has not been set (e.g. a variable declared but not set by variable). \n\n CLASS INTROSPECTION The following subcommand values are supported by info class: \n\n  info class call class method Returns a description of the method implementations that are used to provide a stereotypical instance of class\'s implementation of method (stereotypical instances being objects instantiated by a class without having any object-specific definitions added). This consists of a list of lists of four elements, where each sublist consists of a word that describes the general type of method implementation (being one of method for an ordinary method, filter for an applied filter, and unknown for a method that is invoked as part of unknown method handling), a word giving the name of the particular method invoked (which is always the same as method for the method type, and &#8220;unknown&#8221; for the unknown type), a word giving the fully qualified name of the class that defined the method, and a word describing the type of method implementation (see info class methodtype). \n\n Note that there is no inspection of whether the method implementations actually use next to transfer control along the call chain. \n\ninfo class constructor class This subcommand returns a description of the definition of the constructor of class class. The definition is described as a two element list; the first element is the list of arguments to the constructor in a form suitable for passing to another call to proc or a method definition, and the second element is the body of the constructor. If no constructor is present, this returns the empty list. \n\ninfo class definition class method This subcommand returns a description of the definition of the method named method of class class. The definition is described as a two element list; the first element is the list of arguments to the method in a form suitable for passing to another call to proc or a method definition, and the second element is the body of the method. \n\ninfo class destructor class This subcommand returns the body of the destructor of class class. If no destructor is present, this returns the empty string. \n\ninfo class filters class This subcommand returns the list of filter methods set on the class. \n\ninfo class forward class method This subcommand returns the argument list for the method forwarding called method that is set on the class called class. \n\ninfo class instances class ?pattern? This subcommand returns a list of instances of class class. If the optional pattern argument is present, it constrains the list of returned instances to those that match it according to the rules of string match. \n\ninfo class methods class ?options...? This subcommand returns a list of all public (i.e. exported) methods of the class called class. Any of the following options may be specified, controlling exactly which method names are returned: \n\n  -all If the -all flag is given, the list of methods will include those methods defined not just by the class, but also by the class\'s superclasses and mixins. \n\n-private If the -private flag is given, the list of methods will also include the private (i.e. non-exported) methods of the class (and superclasses and mixins, if -all is also given). \n\n \n\ninfo class methodtype class method This subcommand returns a description of the type of implementation used for the method named method of class class. When the result is method, further information can be discovered with info class definition, and when the result is forward, further information can be discovered with info class forward. \n\ninfo class mixins class This subcommand returns a list of all classes that have been mixed into the class named class. \n\ninfo class subclasses class ?pattern? This subcommand returns a list of direct subclasses of class class. If the optional pattern argument is present, it constrains the list of returned classes to those that match it according to the rules of string match. \n\ninfo class superclasses class This subcommand returns a list of direct superclasses of class class in inheritance precedence order. \n\ninfo class variables class This subcommand returns a list of all variables that have been declared for the class named class (i.e. that are automatically present in the class\'s methods, constructor and destructor). \n\n OBJECT INTROSPECTION The following subcommand values are supported by info object: \n\n  info object call object method Returns a description of the method implementations that are used to provide object\'s implementation of method.  This consists of a list of lists of four elements, where each sublist consists of a word that describes the general type of method implementation (being one of method for an ordinary method, filter for an applied filter, and unknown for a method that is invoked as part of unknown method handling), a word giving the name of the particular method invoked (which is always the same as method for the method type, and &#8220;unknown&#8221; for the unknown type), a word giving what defined the method (the fully qualified name of the class, or the literal string object if the method implementation is on an instance), and a word describing the type of method implementation (see info object methodtype). \n\n Note that there is no inspection of whether the method implementations actually use next to transfer control along the call chain. \n\ninfo object class object ?className? If className is unspecified, this subcommand returns class of the object object. If className is present, this subcommand returns a boolean value indicating whether the object is of that class. \n\ninfo object definition object method This subcommand returns a description of the definition of the method named method of object object. The definition is described as a two element list; the first element is the list of arguments to the method in a form suitable for passing to another call to proc or a method definition, and the second element is the body of the method. \n\ninfo object filters object This subcommand returns the list of filter methods set on the object. \n\ninfo object forward object method This subcommand returns the argument list for the method forwarding called method that is set on the object called object. \n\ninfo object isa category object ?arg? This subcommand tests whether an object belongs to a particular category, returning a boolean value that indicates whether the object argument meets the criteria for the category. The supported categories are: \n\n  info object isa class object This returns whether object is a class (i.e. an instance of oo::class or one of its subclasses). \n\ninfo object isa metaclass object This returns whether object is a class that can manufacture classes (i.e. is oo::class or a subclass of it). \n\ninfo object isa mixin object class This returns whether class is directly mixed into object. \n\ninfo object isa object object This returns whether object really is an object. \n\ninfo object isa typeof object class This returns whether class is the type of object (i.e. whether object is an instance of class or one of its subclasses, whether direct or indirect). \n\n \n\ninfo object methods object ?option...? This subcommand returns a list of all public (i.e. exported) methods of the object called object. Any of the following options may be specified, controlling exactly which method names are returned: \n\n  -all If the -all flag is given, the list of methods will include those methods defined not just by the object, but also by the object\'s class and mixins, plus the superclasses of those classes. \n\n-private If the -private flag is given, the list of methods will also include the private (i.e. non-exported) methods of the object (and classes, if -all is also given). \n\n \n\ninfo object methodtype object method This subcommand returns a description of the type of implementation used for the method named method of object object. When the result is method, further information can be discovered with info object definition, and when the result is forward, further information can be discovered with info object forward. \n\ninfo object mixins object This subcommand returns a list of all classes that have been mixed into the object named object. \n\ninfo object namespace object This subcommand returns the name of the internal namespace of the object named object. \n\ninfo object variables object This subcommand returns a list of all variables that have been declared for the object named object (i.e. that are automatically present in the object\'s methods). \n\ninfo object vars object ?pattern? This subcommand returns a list of all variables in the private namespace of the object named object. If the optional pattern argument is given, it is a filter (in the syntax of a string match glob pattern) that constrains the list of variables returned. Note that this is different from the list returned by info object variables; that can include variables that are currently unset, whereas this can include variables that are not automatically included by any of object\'s methods (or those of its class, superclasses or mixins). \n\n "));
		docs.put("package", new TCLDoc("package", "Facilities for package loading and version control"," This command keeps a simple database of the packages available for use by the current interpreter and how to load them into the interpreter. It supports multiple versions of each package and arranges for the correct version of a package to be loaded based on what is needed by the application. This command also detects and reports version clashes. Typically, only the package require and package provide commands are invoked in normal Tcl scripts;  the other commands are used primarily by system scripts that maintain the package database. \n\n The behavior of the package command is determined by its first argument. The following forms are permitted: \n\n  package forget ?package package ...? Removes all information about each specified package from this interpreter, including information provided by both package ifneeded and package provide. \n\npackage ifneeded package version ?script? This command typically appears only in system configuration scripts to set up the package database. It indicates that a particular version of a particular package is available if needed, and that the package can be added to the interpreter by executing script. The script is saved in a database for use by subsequent package require commands;  typically, script sets up auto-loading for the commands in the package (or calls load and/or source directly), then invokes package provide to indicate that the package is present. There may be information in the database for several different versions of a single package. If the database already contains information for package and version, the new script replaces the existing one. If the script argument is omitted, the current script for version version of package package is returned, or an empty string if no package ifneeded command has been invoked for this package and version. \n\npackage names Returns a list of the names of all packages in the interpreter for which a version has been provided (via package provide) or for which a package ifneeded script is available. The order of elements in the list is arbitrary. \n\npackage present ?-exact? package ?requirement...? This command is equivalent to package require except that it does not try and load the package if it is not already loaded. \n\npackage provide package ?version? This command is invoked to indicate that version version of package package is now present in the interpreter. It is typically invoked once as part of an ifneeded script, and again by the package itself when it is finally loaded. An error occurs if a different version of package has been provided by a previous package provide command. If the version argument is omitted, then the command returns the version number that is currently provided, or an empty string if no package provide command has been invoked for package in this interpreter.   \n\npackage require package ?requirement...? This command is typically invoked by Tcl code that wishes to use a particular version of a particular package.  The arguments indicate which package is wanted, and the command ensures that a suitable version of the package is loaded into the interpreter. If the command succeeds, it returns the version number that is loaded;  otherwise it generates an error. \n\n A suitable version of the package is any version which satisfies at least one of the requirements, per the rules of package vsatisfies. If multiple versions are suitable the implementation with the highest version is chosen. This last part is additionally influenced by the selection mode set with package prefer. \n\n In the &#8220;stable&#8221; selection mode the command will select the highest stable version satisfying the requirements, if any. If no stable version satisfies the requirements, the highest unstable version satisfying the requirements will be selected.  In the &#8220;latest&#8221; selection mode the command will accept the highest version satisfying all the requirements, regardless of its stableness. \n\nIf a version of package has already been provided (by invoking the package provide command), then its version number must satisfy the requirements and the command returns immediately. Otherwise, the command searches the database of information provided by previous package ifneeded commands to see if an acceptable version of the package is available. If so, the script for the highest acceptable version number is evaluated in the global namespace; it must do whatever is necessary to load the package, including calling package provide for the package. If the package ifneeded database does not contain an acceptable version of the package and a package unknown command has been specified for the interpreter then that command is evaluated in the global namespace;  when it completes, Tcl checks again to see if the package is now provided or if there is a package ifneeded script for it. If all of these steps fail to provide an acceptable version of the package, then the command returns an error. \n\npackage require -exact package version This form of the command is used when only the given version of package is acceptable to the caller.  This command is equivalent to package require package version-version. \n\npackage unknown ?command? This command supplies a &#8220;last resort&#8221; command to invoke during package require if no suitable version of a package can be found in the package ifneeded database. If the command argument is supplied, it contains the first part of a command;  when the command is invoked during a package require command, Tcl appends one or more additional arguments giving the desired package name and requirements. For example, if command is foo bar and later the command package require test 2.4 is invoked, then Tcl will execute the command foo bar test 2.4 to load the package. If no requirements are supplied to the package require command, then only the name will be added to invoked command. If the package unknown command is invoked without a command argument, then the current package unknown script is returned, or an empty string if there is none. If command is specified as an empty string, then the current package unknown script is removed, if there is one. \n\npackage vcompare version1 version2 Compares the two version numbers given by version1 and version2. Returns -1 if version1 is an earlier version than version2, 0 if they are equal, and 1 if version1 is later than version2. \n\npackage versions package Returns a list of all the version numbers of package for which information has been provided by package ifneeded commands. \n\npackage vsatisfies version requirement... Returns 1 if the version satisfies at least one of the given requirements, and 0 otherwise. Each requirement is allowed to have any of the forms: \n\n  min This form is called &#8220;min-bounded&#8221;. \n\nmin- This form is called &#8220;min-unbound&#8221;. \n\nmin-max This form is called &#8220;bounded&#8221;. \n\n \n\n where &#8220;min&#8221; and &#8220;max&#8221; are valid version numbers. The legacy syntax is a special case of the extended syntax, keeping backward compatibility. Regarding satisfaction the rules are: \n\n   The version has to pass at least one of the listed requirements to be satisfactory. \n\n A version satisfies a &#8220;bounded&#8221; requirement when \n\n   For min equal to the max if, and only if the version is equal to the min. \n\n Otherwise if, and only if the version is greater than or equal to the min, and less than the max, where both min and max have been padded internally with &#8220;a0&#8221;. Note that while the comparison to min is inclusive, the comparison to max is exclusive. \n\n \n\n A &#8220;min-bounded&#8221; requirement is a &#8220;bounded&#8221; requirement in disguise, with the max part implicitly specified as the next higher major version number of the min part. A version satisfies it per the rules above. \n\n A version satisfies a &#8220;min-unbound&#8221; requirement if, and only if it is greater than or equal to the min, where the min has been padded internally with &#8220;a0&#8221;. There is no constraint to a maximum. \n\n \n\npackage prefer ?latest|stable? With no arguments, the commands returns either &#8220;latest&#8221; or &#8220;stable&#8221;, whichever describes the current mode of selection logic used by package require. \n\n When passed the argument &#8220;latest&#8221;, it sets the selection logic mode to &#8220;latest&#8221;. \n\n When passed the argument &#8220;stable&#8221;, if the mode is already &#8220;stable&#8221;, that value is kept.  If the mode is already &#8220;latest&#8221;, then the attempt to set it back to &#8220;stable&#8221; is ineffective and the mode value remains &#8220;latest&#8221;. \n\n When passed any other value as an argument, raise an invalid argument error. \n\nWhen an interpreter is created, its initial selection mode value is set to &#8220;stable&#8221; unless the environment variable TCL_PKG_PREFER_LATEST is set.  If that environment variable is defined (with any value) then the initial (and permanent) selection mode value is set to &#8220;latest&#8221;. \n\n "));
		docs.put("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", new TCLDoc("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", "standard library of Tcl procedures",""));
		docs.put("variable", new TCLDoc("variable", "create and initialize a namespace variable"," This command is normally used within a namespace eval command to create one or more variables within a namespace. Each variable name is initialized with value. The value for the last variable is optional. \n\n If a variable name does not exist, it is created. In this case, if value is specified, it is assigned to the newly created variable. If no value is specified, the new variable is left undefined. If the variable already exists, it is set to value if value is specified or left unchanged if no value is given. Normally, name is unqualified (does not include the names of any containing namespaces), and the variable is created in the current namespace. If name includes any namespace qualifiers, the variable is created in the specified namespace.  If the variable is not defined, it will be visible to the namespace which command, but not to the info exists command. \n\n If the variable command is executed inside a Tcl procedure, it creates local variables linked to the corresponding namespace variables (and therefore these variables are listed by info vars.) In this way the variable command resembles the global command, although the global command only links to variables in the global namespace. If any values are given, they are used to modify the values of the associated namespace variables. If a namespace variable does not exist, it is created and optionally initialized. \n\n A name argument cannot reference an element within an array. Instead, name should reference the entire array, and the initialization value should be left off. After the variable has been declared, elements within the array can be set using ordinary set or array commands. "));
		docs.put("continue", new TCLDoc("continue", "Skip to the next iteration of a loop"," This command is typically invoked inside the body of a looping command such as for or foreach or while. It returns a 4 (TCL_CONTINUE) result code, which causes a continue exception to occur. The exception causes the current script to be aborted out to the innermost containing loop command, which then continues with the next iteration of the loop. Catch exceptions are also handled in a few other situations, such as the catch command and the outermost scripts of procedure bodies. "));
		docs.put("interp", new TCLDoc("interp", "Create and manipulate Tcl interpreters"," This command makes it possible to create one or more new Tcl interpreters that co-exist with the creating interpreter in the same application.  The creating interpreter is called the master and the new interpreter is called a slave. A master can create any number of slaves, and each slave can itself create additional slaves for which it is master, resulting in a hierarchy of interpreters. \n\n Each interpreter is independent from the others: it has its own name space for commands, procedures, and global variables. A master interpreter may create connections between its slaves and itself using a mechanism called an alias.  An alias is a command in a slave interpreter which, when invoked, causes a command to be invoked in its master interpreter or in another slave interpreter.  The only other connections between interpreters are through environment variables (the env variable), which are normally shared among all interpreters in the application, and by resource limit exceeded callbacks. Note that the name space for files (such as the names returned by the open command) is no longer shared between interpreters. Explicit commands are provided to share files and to transfer references to open files from one interpreter to another. \n\n The interp command also provides support for safe interpreters.  A safe interpreter is a slave whose functions have been greatly restricted, so that it is safe to execute untrusted scripts without fear of them damaging other interpreters or the application\'s environment. For example, all IO channel creation commands and subprocess creation commands are made inaccessible to safe interpreters. See SAFE INTERPRETERS below for more information on what features are present in a safe interpreter. The dangerous functionality is not removed from the safe interpreter; instead, it is hidden, so that only trusted interpreters can obtain access to it. For a detailed explanation of hidden commands, see HIDDEN COMMANDS, below. The alias mechanism can be used for protected communication (analogous to a kernel call) between a slave interpreter and its master. See ALIAS INVOCATION, below, for more details on how the alias mechanism works. \n\n A qualified interpreter name is a proper Tcl lists containing a subset of its ancestors in the interpreter hierarchy, terminated by the string naming the interpreter in its immediate master. Interpreter names are relative to the interpreter in which they are used. For example, if &#8220;a&#8221; is a slave of the current interpreter and it has a slave &#8220;a1&#8221;, which in turn has a slave &#8220;a11&#8221;, the qualified name of &#8220;a11&#8221; in &#8220;a&#8221; is the list &#8220;a1 a11&#8221;. \n\n The interp command, described below, accepts qualified interpreter names as arguments; the interpreter in which the command is being evaluated can always be referred to as {} (the empty list or string). Note that it is impossible to refer to a master (ancestor) interpreter by name in a slave interpreter except through aliases. Also, there is no global name by which one can refer to the first interpreter created in an application. Both restrictions are motivated by safety concerns. "));
		docs.put("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", new TCLDoc("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", "standard library of Tcl procedures",""));
		docs.put("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", new TCLDoc("auto_execok, auto_import, auto_load, auto_mkindex, auto_qualify, auto_reset, tcl_findLibrary, parray, tcl_endOfWord, tcl_startOfNextWord, tcl_startOfPreviousWord, tcl_wordBreakAfter, tcl_wordBreakBefore", "standard library of Tcl procedures",""));
		docs.put("vwait", new TCLDoc("vwait", "Process events until a variable is written"," This command enters the Tcl event loop to process events, blocking the application if no events are ready.  It continues processing events until some event handler sets the value of the global variable varName.  Once varName has been set, the vwait command will return as soon as the event handler that modified varName completes.  The varName argument is always interpreted as a variable name with respect to the global namespace, but can refer to any namespace\'s variables if the fully-qualified name is given. \n\n In some cases the vwait command may not return immediately after varName is set.  This happens if the event handler that sets varName does not complete immediately.  For example, if an event handler sets varName and then itself calls vwait to wait for a different variable, then it may not return for a long time.  During this time the top-level vwait is blocked waiting for the event handler to complete, so it cannot return either. (See the NESTED VWAITS BY EXAMPLE below.) \n\n To be clear, multiple vwait calls will nest and will not happen in parallel.  The outermost call to vwait will not return until all the inner ones do.  It is recommended that code should never nest vwait calls (by avoiding putting them in event callbacks) but when that is not possible, care should be taken to add interlock variables to the code to prevent all reentrant calls to vwait that are not strictly necessary. Be aware that the synchronous modes of operation of some Tcl packages (e.g., http) use vwait internally; if using the event loop, it is best to use the asynchronous callback-based modes of operation of those packages where available. "));
		docs.put("coroutine, yield, yieldto", new TCLDoc("coroutine, yield, yieldto", "Create and produce values from coroutines"," The coroutine command creates a new coroutine context (with associated command) named name and executes that context by calling command, passing in the other remaining arguments without further interpretation. Once command returns normally or with an exception (e.g., an error) the coroutine context name is deleted. \n\n Within the context, values may be generated as results by using the yield command; if no value is supplied, the empty string is used. When that is called, the context will suspend execution and the coroutine command will return the argument to yield. The execution of the context can then be resumed by calling the context command, optionally passing in the single value to use as the result of the yield call that caused the context to be suspended. If the coroutine context never yields and instead returns conventionally, the result of the coroutine command will be the result of the evaluation of the context. \n\n The coroutine may also suspend its execution by use of the yieldto command, which instead of returning, cedes execution to some command called command (resolved in the context of the coroutine) and to which any number of arguments may be passed. Since every coroutine has a context command, yieldto can be used to transfer control directly from one coroutine to another (this is only advisable if the two coroutines are expecting this to happen) but any command may be the target. If a coroutine is suspended by this mechanism, the coroutine processing can be resumed by calling the context command optionally passing in an arbitrary number of arguments. The return value of the yieldto call will be the list of arguments passed to the context command; it is up to the caller to decide what to do with those values. \n\n The recommended way of writing a version of yield that allows resumption with multiple arguments is by using yieldto and the return command, like this: \n\n proc yieldm {value} {     yieldto return -level 0 $value } \n\n The coroutine can also be deleted by destroying the command name, and the name of the current coroutine can be retrieved by using info coroutine. If there are deletion traces on variables in the coroutine\'s implementation, they will fire at the point when the coroutine is explicitly deleted (or, naturally, if the command returns conventionally). \n\n At the point when command is called, the current namespace will be the global namespace and there will be no stack frames above it (in the sense of upvar and uplevel). However, which command to call will be determined in the namespace that the coroutine command was called from. "));
		docs.put("join", new TCLDoc("join", "Create a string by joining together list elements"," The list argument must be a valid Tcl list. This command returns the string formed by joining all of the elements of list together with joinString separating each adjacent pair of elements. The joinString argument defaults to a space character. "));
		docs.put("pid", new TCLDoc("pid", "Retrieve process identifiers"," If the fileId argument is given then it should normally refer to a process pipeline created with the open command. In this case the pid command will return a list whose elements are the process identifiers of all the processes in the pipeline, in order. The list will be empty if fileId refers to an open file that is not a process pipeline. If no fileId argument is given then pid returns the process identifier of the current process. All process identifiers are returned as decimal strings. "));
		docs.put("while", new TCLDoc("while", "Execute script repeatedly as long as a condition is met"," The while command evaluates test as an expression (in the same way that expr evaluates its argument). The value of the expression must a proper boolean value; if it is a true value then body is executed by passing it to the Tcl interpreter. Once body has been executed then test is evaluated again, and the process repeats until eventually test evaluates to a false boolean value.  Continue commands may be executed inside body to terminate the current iteration of the loop, and break commands may be executed inside body to cause immediate termination of the while command.  The while command always returns an empty string. \n\n Note: test should almost always be enclosed in braces.  If not, variable substitutions will be made before the while command starts executing, which means that variable changes made by the loop body will not be considered in the expression. This is likely to result in an infinite loop.  If test is enclosed in braces, variable substitutions are delayed until the expression is evaluated (before each loop iteration), so changes in the variables will be visible. For an example, try the following script with and without the braces around $x"));
		docs.put("dde", new TCLDoc("dde", "Execute a Dynamic Data Exchange command"," This command allows an application to send Dynamic Data Exchange (DDE) command when running under Microsoft Windows. Dynamic Data Exchange is a mechanism where applications can exchange raw data. Each DDE transaction needs a service name and a topic. Both the service name and topic are application defined; Tcl uses the service name TclEval, while the topic name is the name of the interpreter given by dde servername. Other applications have their own service names and topics. For instance, Microsoft Excel has the service name Excel. \n\n "));
		docs.put("lappend", new TCLDoc("lappend", "Append list elements onto a variable"," This command treats the variable given by varName as a list and appends each of the value arguments to that list as a separate element, with spaces between elements. If varName does not exist, it is created as a list with elements given by the value arguments. Lappend is similar to append except that the values are appended as list elements rather than raw text. This command provides a relatively efficient way to build up large lists.  For example, &#8220;lappend a $b&#8221; is much more efficient than &#8220;set a [concat $a [list $b]]&#8221; when $a is long. "));
		docs.put("pkg::create", new TCLDoc("pkg::create", "Construct an appropriate 'package ifneeded' command for a given package specification"," ::pkg::create is a utility procedure that is part of the standard Tcl library.  It is used to create an appropriate package ifneeded command for a given package specification.  It can be used to construct a pkgIndex.tcl file for use with the package mechanism.  "));
		docs.put("coroutine, yield, yieldto", new TCLDoc("coroutine, yield, yieldto", "Create and produce values from coroutines"," The coroutine command creates a new coroutine context (with associated command) named name and executes that context by calling command, passing in the other remaining arguments without further interpretation. Once command returns normally or with an exception (e.g., an error) the coroutine context name is deleted. \n\n Within the context, values may be generated as results by using the yield command; if no value is supplied, the empty string is used. When that is called, the context will suspend execution and the coroutine command will return the argument to yield. The execution of the context can then be resumed by calling the context command, optionally passing in the single value to use as the result of the yield call that caused the context to be suspended. If the coroutine context never yields and instead returns conventionally, the result of the coroutine command will be the result of the evaluation of the context. \n\n The coroutine may also suspend its execution by use of the yieldto command, which instead of returning, cedes execution to some command called command (resolved in the context of the coroutine) and to which any number of arguments may be passed. Since every coroutine has a context command, yieldto can be used to transfer control directly from one coroutine to another (this is only advisable if the two coroutines are expecting this to happen) but any command may be the target. If a coroutine is suspended by this mechanism, the coroutine processing can be resumed by calling the context command optionally passing in an arbitrary number of arguments. The return value of the yieldto call will be the list of arguments passed to the context command; it is up to the caller to decide what to do with those values. \n\n The recommended way of writing a version of yield that allows resumption with multiple arguments is by using yieldto and the return command, like this: \n\n proc yieldm {value} {     yieldto return -level 0 $value } \n\n The coroutine can also be deleted by destroying the command name, and the name of the current coroutine can be retrieved by using info coroutine. If there are deletion traces on variables in the coroutine\'s implementation, they will fire at the point when the coroutine is explicitly deleted (or, naturally, if the command returns conventionally). \n\n At the point when command is called, the current namespace will be the global namespace and there will be no stack frames above it (in the sense of upvar and uplevel). However, which command to call will be determined in the namespace that the coroutine command was called from. "));
		docs.put("dict", new TCLDoc("dict", "Manipulate dictionaries"," Performs one of several operations on dictionary values or variables containing dictionary values (see the DICTIONARY VALUES section below for a description), depending on option.  The legal options (which may be abbreviated) are: \n\n  dict append dictionaryVariable key ?string ...? This appends the given string (or strings) to the value that the given key maps to in the dictionary value contained in the given variable, writing the resulting dictionary value back to that variable. Non-existent keys are treated as if they map to an empty string. \n\ndict create ?key value ...? Create a new dictionary that contains each of the key/value mappings listed as arguments (keys and values alternating, with each key being followed by its associated value.) \n\ndict exists dictionaryValue key ?key ...? This returns a boolean value indicating whether the given key (or path of keys through a set of nested dictionaries) exists in the given dictionary value. This returns a true value exactly when dict get on that path will succeed. \n\ndict filter dictionaryValue filterType arg ?arg ...? This takes a dictionary value and returns a new dictionary that contains just those key/value pairs that match the specified filter type (which may be abbreviated.)  Supported filter types are: \n\n  dict filter dictionaryValue key ?globPattern ...? The key rule only matches those key/value pairs whose keys match any of the given patterns (in the style of string match.) \n\ndict filter dictionaryValue script {keyVar valueVar} script The script rule tests for matching by assigning the key to the keyVar and the value to the valueVar, and then evaluating the given script which should return a boolean value (with the key/value pair only being included in the result of the dict filter when a true value is returned.)  Note that the first argument after the rule selection word is a two-element list.  If the script returns with a condition of TCL_BREAK, no further key/value pairs are considered for inclusion in the resulting dictionary, and a condition of TCL_CONTINUE is equivalent to a false result. The key/value pairs are tested in the order in which the keys were inserted into the dictionary. \n\ndict filter dictionaryValue value ?globPattern ...? The value rule only matches those key/value pairs whose values match any of the given patterns (in the style of string match.) \n\n \n\ndict for {keyVar valueVar} dictionaryValue body This command takes three arguments, the first a two-element list of variable names (for the key and value respectively of each mapping in the dictionary), the second the dictionary value to iterate across, and the third a script to be evaluated for each mapping with the key and value variables set appropriately (in the manner of foreach.) The result of the command is an empty string. If any evaluation of the body generates a TCL_BREAK result, no further pairs from the dictionary will be iterated over and the dict for command will terminate successfully immediately. If any evaluation of the body generates a TCL_CONTINUE result, this shall be treated exactly like a normal TCL_OK result. The order of iteration is the order in which the keys were inserted into the dictionary. \n\ndict get dictionaryValue ?key ...? Given a dictionary value (first argument) and a key (second argument), this will retrieve the value for that key. Where several keys are supplied, the behaviour of the command shall be as if the result of dict get $dictVal $key was passed as the first argument to dict get with the remaining arguments as second (and possibly subsequent) arguments. This facilitates lookups in nested dictionaries. For example, the following two commands are equivalent: \n\n dict get $dict foo bar spong dict get [dict get [dict get $dict foo] bar] spong \n\n If no keys are provided, dict get will return a list containing pairs of elements in a manner similar to array get. That is, the first element of each pair would be the key and the second element would be the value for that key. \n\nIt is an error to attempt to retrieve a value for a key that is not present in the dictionary. \n\ndict incr dictionaryVariable key ?increment? This adds the given increment value (an integer that defaults to 1 if not specified) to the value that the given key maps to in the dictionary value contained in the given variable, writing the resulting dictionary value back to that variable. Non-existent keys are treated as if they map to 0. It is an error to increment a value for an existing key if that value is not an integer. \n\ndict info dictionaryValue This returns information (intended for display to people) about the given dictionary though the format of this data is dependent on the implementation of the dictionary. For dictionaries that are implemented by hash tables, it is expected that this will return the string produced by Tcl_HashStats, similar to array statistics. \n\ndict keys dictionaryValue ?globPattern? Return a list of all keys in the given dictionary value. If a pattern is supplied, only those keys that match it (according to the rules of string match) will be returned. The returned keys will be in the order that they were inserted into the dictionary. \n\ndict lappend dictionaryVariable key ?value ...? This appends the given items to the list value that the given key maps to in the dictionary value contained in the given variable, writing the resulting dictionary value back to that variable. Non-existent keys are treated as if they map to an empty list, and it is legal for there to be no items to append to the list. It is an error for the value that the key maps to to not be representable as a list. \n\ndict map {keyVar valueVar} dictionaryValue body This command applies a transformation to each element of a dictionary, returning a new dictionary. It takes three arguments: the first is a two-element list of variable names (for the key and value respectively of each mapping in the dictionary), the second the dictionary value to iterate across, and the third a script to be evaluated for each mapping with the key and value variables set appropriately (in the manner of lmap). In an iteration where the evaluated script completes normally (TCL_OK, as opposed to an error, etc.) the result of the script is put into an accumulator dictionary using the key that is the current contents of the keyVar variable at that point. The result of the dict map command is the accumulator dictionary after all keys have been iterated over. \n\n If the evaluation of the body for any particular step generates a break, no further pairs from the dictionary will be iterated over and the dict map command will terminate successfully immediately. If the evaluation of the body for a particular step generates a continue result, the current iteration is aborted and the accumulator dictionary is not modified. The order of iteration is the natural order of the dictionary (typically the order in which the keys were added to the dictionary; the order is the same as that used in dict for). \n\ndict merge ?dictionaryValue ...? Return a dictionary that contains the contents of each of the dictionaryValue arguments.  Where two (or more) dictionaries contain a mapping for the same key, the resulting dictionary maps that key to the value according to the last dictionary on the command line containing a mapping for that key. \n\ndict remove dictionaryValue ?key ...? Return a new dictionary that is a copy of an old one passed in as first argument except without mappings for each of the keys listed. It is legal for there to be no keys to remove, and it also legal for any of the keys to be removed to not be present in the input dictionary in the first place. \n\ndict replace dictionaryValue ?key value ...? Return a new dictionary that is a copy of an old one passed in as first argument except with some values different or some extra key/value pairs added. It is legal for this command to be called with no key/value pairs, but illegal for this command to be called with a key but no value. \n\ndict set dictionaryVariable key ?key ...? value This operation takes the name of a variable containing a dictionary value and places an updated dictionary value in that variable containing a mapping from the given key to the given value. When multiple keys are present, this operation creates or updates a chain of nested dictionaries. \n\ndict size dictionaryValue Return the number of key/value mappings in the given dictionary value. \n\ndict unset dictionaryVariable key ?key ...? This operation (the companion to dict set) takes the name of a variable containing a dictionary value and places an updated dictionary value in that variable that does not contain a mapping for the given key. Where multiple keys are present, this describes a path through nested dictionaries to the mapping to remove. At least one key must be specified, but the last key on the key-path need not exist. All other components on the path must exist. \n\ndict update dictionaryVariable key varName ?key varName ...? body Execute the Tcl script in body with the value for each key (as found by reading the dictionary value in dictionaryVariable) mapped to the variable varName. There may be multiple key/varName pairs. If a key does not have a mapping, that corresponds to an unset varName. When body terminates, any changes made to the varNames is reflected back to the dictionary within dictionaryVariable (unless dictionaryVariable itself becomes unreadable, when all updates are silently discarded), even if the result of body is an error or some other kind of exceptional exit. The result of dict update is (unless some kind of error occurs) the result of the evaluation of body. \n\n Each varName is mapped in the scope enclosing the dict update; it is recommended that this command only be used in a local scope (procedure, lambda term for apply, or method). Because of this, the variables set by dict update will continue to exist after the command finishes (unless explicitly unset). Note that the mapping of values to variables does not use traces; changes to the dictionaryVariable\'s contents only happen when body terminates. \n\ndict values dictionaryValue ?globPattern? Return a list of all values in the given dictionary value. If a pattern is supplied, only those values that match it (according to the rules of string match) will be returned. The returned values will be in the order of that the keys associated with those values were inserted into the dictionary. \n\ndict with dictionaryVariable ?key ...? body Execute the Tcl script in body with the value for each key in dictionaryVariable mapped (in a manner similarly to dict update) to a variable with the same name. Where one or more keys are available, these indicate a chain of nested dictionaries, with the innermost dictionary being the one opened out for the execution of body. As with dict update, making dictionaryVariable unreadable will make the updates to the dictionary be discarded, and this also happens if the contents of dictionaryVariable are adjusted so that the chain of dictionaries no longer exists. The result of dict with is (unless some kind of error occurs) the result of the evaluation of body. \n\n The variables are mapped in the scope enclosing the dict with; it is recommended that this command only be used in a local scope (procedure, lambda term for apply, or method). Because of this, the variables set by dict with will continue to exist after the command finishes (unless explicitly unset). Note that the mapping of values to variables does not use traces; changes to the dictionaryVariable\'s contents only happen when body terminates. \n\nIf the dictionaryVariable contains a value that is not a dictionary at the point when the body terminates (which can easily happen if the name is the same as any of the keys in dictionary) then an error occurs at that point. This command is thus not recommended for use when the keys in the dictionary are expected to clash with the dictionaryVariable name itself. Where the contained key does map to a dictionary, the net effect is to combine that inner dictionary into the outer dictionary; see the EXAMPLES below for an illustration of this. \n\n "));
		docs.put("lassign", new TCLDoc("lassign", "Assign list elements to variables"," This command treats the value list as a list and assigns successive elements from that list to the variables given by the varName arguments in order.  If there are more variable names than list elements, the remaining variables are set to the empty string.  If there are more list elements than variables, a list of unassigned elements is returned. "));
		docs.put("pkg_mkIndex", new TCLDoc("pkg_mkIndex", "Build an index for automatic loading of packages"," Pkg_mkIndex is a utility procedure that is part of the standard Tcl library. It is used to create index files that allow packages to be loaded automatically when package require commands are executed. To use pkg_mkIndex, follow these steps: \n\n   Create the package(s). Each package may consist of one or more Tcl script files or binary files. Binary files must be suitable for loading with the load command with a single argument;  for example, if the file is test.so it must be possible to load this file with the command load test.so. Each script file must contain a package provide command to declare the package and version number, and each binary file must contain a call to Tcl_PkgProvide. \n\n Create the index by invoking pkg_mkIndex. The dir argument gives the name of a directory and each pattern argument is a glob-style pattern that selects script or binary files in dir. The default pattern is *.tcl and *.[info sharedlibextension]. \n\n Pkg_mkIndex will create a file pkgIndex.tcl in dir with package information about all the files given by the pattern arguments. It does this by loading each file into a slave interpreter and seeing what packages and new commands appear (this is why it is essential to have package provide commands or Tcl_PkgProvide calls in the files, as described above). If you have a package split among scripts and binary files,  or if you have dependencies among files, you may have to use the -load option or adjust the order in which pkg_mkIndex processes the files.  See COMPLEX CASES below. \n\n Install the package as a subdirectory of one of the directories given by the tcl_pkgPath variable.  If $tcl_pkgPath contains more than one directory, machine-dependent packages (e.g., those that contain binary shared libraries) should normally be installed under the first directory and machine-independent packages (e.g., those that contain only Tcl scripts) should be installed under the second directory. The subdirectory should include the package\'s script and/or binary files as well as the pkgIndex.tcl file.  As long as the package is installed as a subdirectory of a directory in $tcl_pkgPath it will automatically be found during package require commands. \n\n If you install the package anywhere else, then you must ensure that the directory containing the package is in the auto_path global variable or an immediate subdirectory of one of the directories in auto_path. Auto_path contains a list of directories that are searched by both the auto-loader and the package loader; by default it includes $tcl_pkgPath. The package loader also checks all of the subdirectories of the directories in auto_path. You can add a directory to auto_path explicitly in your application, or you can add the directory to your TCLLIBPATH environment variable:  if this environment variable is present, Tcl initializes auto_path from it during application startup. \n\n Once the above steps have been taken, all you need to do to use a package is to invoke package require. For example, if versions 2.1, 2.3, and 3.1 of package Test have been indexed by pkg_mkIndex, the command package require Test will make version 3.1 available and the command package require -exact Test 2.1 will make version 2.1 available. There may be many versions of a package in the various index files in auto_path, but only one will actually be loaded in a given interpreter, based on the first call to package require. Different versions of a package may be loaded in different interpreters. \n\n "));
		docs.put("coroutine, yield, yieldto", new TCLDoc("coroutine, yield, yieldto", "Create and produce values from coroutines"," The coroutine command creates a new coroutine context (with associated command) named name and executes that context by calling command, passing in the other remaining arguments without further interpretation. Once command returns normally or with an exception (e.g., an error) the coroutine context name is deleted. \n\n Within the context, values may be generated as results by using the yield command; if no value is supplied, the empty string is used. When that is called, the context will suspend execution and the coroutine command will return the argument to yield. The execution of the context can then be resumed by calling the context command, optionally passing in the single value to use as the result of the yield call that caused the context to be suspended. If the coroutine context never yields and instead returns conventionally, the result of the coroutine command will be the result of the evaluation of the context. \n\n The coroutine may also suspend its execution by use of the yieldto command, which instead of returning, cedes execution to some command called command (resolved in the context of the coroutine) and to which any number of arguments may be passed. Since every coroutine has a context command, yieldto can be used to transfer control directly from one coroutine to another (this is only advisable if the two coroutines are expecting this to happen) but any command may be the target. If a coroutine is suspended by this mechanism, the coroutine processing can be resumed by calling the context command optionally passing in an arbitrary number of arguments. The return value of the yieldto call will be the list of arguments passed to the context command; it is up to the caller to decide what to do with those values. \n\n The recommended way of writing a version of yield that allows resumption with multiple arguments is by using yieldto and the return command, like this: \n\n proc yieldm {value} {     yieldto return -level 0 $value } \n\n The coroutine can also be deleted by destroying the command name, and the name of the current coroutine can be retrieved by using info coroutine. If there are deletion traces on variables in the coroutine\'s implementation, they will fire at the point when the coroutine is explicitly deleted (or, naturally, if the command returns conventionally). \n\n At the point when command is called, the current namespace will be the global namespace and there will be no stack frames above it (in the sense of upvar and uplevel). However, which command to call will be determined in the namespace that the coroutine command was called from. "));
		docs.put("encoding", new TCLDoc("encoding", "Manipulate encodings",""));
		docs.put("lindex", new TCLDoc("lindex", "Retrieve an element from a list"," The lindex command accepts a parameter, list, which it treats as a Tcl list. It also accepts zero or more indices into the list.  The indices may be presented either consecutively on the command line, or grouped in a Tcl list and presented as a single argument. \n\n If no indices are presented, the command takes the form: \n\n lindex list \n\n or \n\n lindex list {} \n\n In this case, the return value of lindex is simply the value of the list parameter. \n\n When presented with a single index, the lindex command treats list as a Tcl list and returns the index\'th element from it (0 refers to the first element of the list). In extracting the element, lindex observes the same rules concerning braces and quotes and backslashes as the Tcl command interpreter; however, variable substitution and command substitution do not occur. If index is negative or greater than or equal to the number of elements in value, then an empty string is returned. The interpretation of each simple index value is the same as  for the command string index, supporting simple index arithmetic and indices relative to the end of the list. \n\n If additional index arguments are supplied, then each argument is used in turn to select an element from the previous indexing operation, allowing the script to select elements from sublists.  The command, \n\n lindex $a 1 2 3 \n\n or \n\n lindex $a {1 2 3} \n\n is synonymous with \n\n lindex [lindex [lindex $a 1] 2] 3 "));
		docs.put("platform", new TCLDoc("platform", "System identification support code and utilities"," The platform package provides several utility commands useful for the identification of the architecture of a machine running Tcl. \n\n Whilst Tcl provides the tcl_platform array for identifying the current architecture (in particular, the platform and machine elements) this is not always sufficient. This is because (on Unix machines) tcl_platform reflects the values returned by the uname command and these are not standardized across platforms and architectures. In addition, on at least one platform (AIX) the tcl_platform(machine) contains the CPU serial number. \n\n Consequently, individual applications need to manipulate the values in tcl_platform (along with the output of system specific utilities) - which is both inconvenient for developers, and introduces the potential for inconsistencies in identifying architectures and in naming conventions. \n\n The platform package prevents such fragmentation - i.e., it establishes a standard naming convention for architectures running Tcl and makes it more convenient for developers to identify the current architecture a Tcl program is running on. "));
		docs.put("zlib", new TCLDoc("zlib", "compression and decompression operations"," The zlib command provides access to the compression and check-summing facilities of the Zlib library by Jean-loup Gailly and Mark Adler. It has the following subcommands. COMPRESSION SUBCOMMANDS  zlib compress string ?level? Returns the zlib-format compressed binary data of the binary string in string. If present, level gives the compression level to use (from 0, which is uncompressed, to 9, maximally compressed). \n\nzlib decompress string ?bufferSize? Returns the uncompressed version of the raw compressed binary data in string. If present, bufferSize is a hint as to what size of buffer is to be used to receive the data. \n\nzlib deflate string ?level? Returns the raw compressed binary data of the binary string in string. If present, level gives the compression level to use (from 0, which is uncompressed, to 9, maximally compressed). \n\nzlib gunzip string ?-headerVar varName? Return the uncompressed contents of binary string string, which must have been in gzip format. If -headerVar is given, store a dictionary describing the contents of the gzip header in the variable called varName. The keys of the dictionary that may be present are: \n\n  comment The comment field from the header, if present. \n\ncrc A boolean value describing whether a CRC of the header is computed. \n\nfilename The filename field from the header, if present. \n\nos The operating system type code field from the header (if not the QW unknown value). See RFC 1952 for the meaning of these codes. \n\nsize The size of the uncompressed data. \n\ntime The time field from the header if non-zero, expected to be time that the file named by the filename field was modified. Suitable for use with clock format. \n\ntype The type of the uncompressed data (binary or text) if known. \n\n \n\nzlib gzip string ?-level level? ?-header dict? Return the compressed contents of binary string string in gzip format. If -level is given, level gives the compression level to use (from 0, which is uncompressed, to 9, maximally compressed). If -header is given, dict is a dictionary containing values used for the gzip header. The following keys may be defined: \n\n  comment Add the given comment to the header of the gzip-format data. \n\ncrc A boolean saying whether to compute a CRC of the header. Note that if the data is to be interchanged with the gzip program, a header CRC should not be computed. \n\nfilename The name of the file that the data to be compressed came from. \n\nos The operating system type code, which should be one of the values described in RFC 1952. \n\ntime The time that the file named in the filename key was last modified. This will be in the same as is returned by clock seconds or file mtime. \n\ntype The type of the data being compressed, being binary or text. \n\n \n\nzlib inflate string ?bufferSize? Returns the uncompressed version of the raw compressed binary data in string. If present, bufferSize is a hint as to what size of buffer is to be used to receive the data. \n\n CHANNEL SUBCOMMAND  zlib push mode channel ?options ...? Pushes a compressing or decompressing transformation onto the channel channel. The transformation can be removed again with chan pop. The mode argument determines what type of transformation is pushed; the following are supported: \n\n  compress The transformation will be a compressing transformation that produces zlib-format data on channel, which must be writable. \n\ndecompress The transformation will be a decompressing transformation that reads zlib-format data from channel, which must be readable. \n\ndeflate The transformation will be a compressing transformation that produces raw compressed data on channel, which must be writable. \n\ngunzip The transformation will be a decompressing transformation that reads gzip-format data from channel, which must be readable. \n\ngzip The transformation will be a compressing transformation that produces gzip-format data on channel, which must be writable. \n\ninflate The transformation will be a decompressing transformation that reads raw compressed data from channel, which must be readable. \n\n  \n\n The following options may be set when creating a transformation via the &#8220;options ...&#8221; to the zlib push command: \n\n  -dictionary binData Sets the compression dictionary to use when working with compressing or decompressing the data to be binData. Not valid for transformations that work with gzip-format data. \n\n-header dictionary Passes a description of the gzip header to create, in the same format that zlib gzip understands. \n\n-level compressionLevel How hard to compress the data. Must be an integer from 0 (uncompressed) to 9 (maximally compressed). \n\n-limit readaheadLimit The maximum number of bytes ahead to read when decompressing. This defaults to 1, which ensures that data is always decompressed correctly, but may be increased to improve performance. This is more useful when the channel is non-blocking. \n\n \n\n Both compressing and decompressing channel transformations add extra configuration options that may be accessed through chan configure. The options are: \n\n  -checksum checksum This read-only option gets the current checksum for the uncompressed data that the compression engine has seen so far. It is valid for both compressing and decompressing transforms, but not for the raw inflate and deflate formats. The compression algorithm depends on what format is being produced or consumed. \n\n-dictionary binData This read-write options gets or sets the compression dictionary to use when working with compressing or decompressing the data to be binData. It is not valid for transformations that work with gzip-format data, and should not normally be set on compressing transformations other than at the point where the transformation is stacked. \n\n-flush type This write-only operation flushes the current state of the compressor to the underlying channel. It is only valid for compressing transformations. The type must be either sync or full for a normal flush or an expensive flush respectively. Flushing degrades the compression ratio, but makes it easier for a decompressor to recover more of the file in the case of data corruption. \n\n-header dictionary This read-only option, only valid for decompressing transforms that are processing gzip-format data, returns the dictionary describing the header read off the data stream. \n\n-limit readaheadLimit This read-write option is used by decompressing channels to control the maximum number of bytes ahead to read from the underlying data source. This defaults to 1, which ensures that data is always decompressed correctly, but may be increased to improve performance. This is more useful when the channel is non-blocking. \n\n  \n\n STREAMING SUBCOMMAND  zlib stream mode ?options? Creates a streaming compression or decompression command based on the mode, and return the name of the command. For a description of how that command works, see STREAMING INSTANCE COMMAND below. The following modes and options are supported: \n\n  zlib stream compress ?-dictionary bindata? ?-level level? The stream will be a compressing stream that produces zlib-format output, using compression level level (if specified) which will be an integer from 0 to 9, and the compression dictionary bindata (if specified). \n\nzlib stream decompress ?-dictionary bindata? The stream will be a decompressing stream that takes zlib-format input and produces uncompressed output. If bindata is supplied, it is a compression dictionary to use if required. \n\nzlib stream deflate ?-dictionary bindata? ?-level level? The stream will be a compressing stream that produces raw output, using compression level level (if specified) which will be an integer from 0 to 9, and the compression dictionary bindata (if specified). Note that the raw compressed data includes no metadata about what compression dictionary was used, if any; that is a feature of the zlib-format data. \n\nzlib stream gunzip The stream will be a decompressing stream that takes gzip-format input and produces uncompressed output. \n\nzlib stream gzip ?-header header? ?-level level? The stream will be a compressing stream that produces gzip-format output, using compression level level (if specified) which will be an integer from 0 to 9, and the header descriptor dictionary header (if specified; for keys see zlib gzip). \n\nzlib stream inflate ?-dictionary bindata? The stream will be a decompressing stream that takes raw compressed input and produces uncompressed output. If bindata is supplied, it is a compression dictionary to use. Note that there are no checks in place to determine whether the compression dictionary is correct. \n\n \n\n CHECKSUMMING SUBCOMMANDS  zlib adler32 string ?initValue? Compute a checksum of binary string string using the Adler-32 algorithm. If given, initValue is used to initialize the checksum engine. \n\nzlib crc32 string ?initValue? Compute a checksum of binary string string using the CRC-32 algorithm. If given, initValue is used to initialize the checksum engine. \n\n "));
		docs.put("linsert", new TCLDoc("linsert", "Insert elements into a list"," This command produces a new list from list by inserting all of the element arguments just before the index\'th element of list.  Each element argument will become a separate element of the new list.  If index is less than or equal to zero, then the new elements are inserted at the beginning of the list, and if index is greater or equal to the length of list, it is as if it was end. As with string index, the index value supports both simple index arithmetic and end-relative indexing. \n\n Subject to the restrictions that indices must refer to locations inside the list and that the elements will always be inserted in order, insertions are done so that when index is start-relative, the first element will be at that index in the resulting list, and when index is end-relative, the last element will be at that index in the resulting list. "));
		docs.put("platform::shell", new TCLDoc("platform::shell", "System identification support code and utilities"," The platform::shell package provides several utility commands useful for the identification of the architecture of a specific Tcl shell. \n\n This package allows the identification of the architecture of a specific Tcl shell different from the shell running the package. The only requirement is that the other shell (identified by its path), is actually executable on the current machine. \n\n While for most platform this means that the architecture of the interrogated shell is identical to the architecture of the running shell this is not generally true. A counter example are all platforms which have 32 and 64 bit variants and where a 64bit system is able to run 32bit code. For these running and interrogated shell may have different 32/64 bit settings and thus different identifiers. \n\n For applications like a code repository it is important to identify the architecture of the shell which will actually run the installed packages, versus the architecture of the shell running the repository software. "));
		docs.put("eof", new TCLDoc("eof", "Check for end of file condition on channel"," Returns 1 if an end of file condition occurred during the most recent input operation on channelId (such as gets), 0 otherwise. \n\n ChannelId must be an identifier for an open channel such as a Tcl standard channel (stdin, stdout, or stderr), the return value from an invocation of open or socket, or the result of a channel creation command provided by a Tcl extension. "));
		docs.put("list", new TCLDoc("list", "Create a list"," This command returns a list comprised of all the args, or an empty string if no args are specified. Braces and backslashes get added as necessary, so that the lindex command may be used on the result to re-extract the original arguments, and also so that eval may be used to execute the resulting list, with arg1 comprising the command\'s name and the other args comprising its arguments.  List produces slightly different results than concat:  concat removes one level of grouping before forming the list, while list works directly from the original arguments. "));
		docs.put("proc", new TCLDoc("proc", "Create a Tcl procedure"," The proc command creates a new Tcl procedure named name, replacing any existing command or procedure there may have been by that name. Whenever the new command is invoked, the contents of body will be executed by the Tcl interpreter. Normally, name is unqualified (does not include the names of any containing namespaces), and the new procedure is created in the current namespace. If name includes any namespace qualifiers, the procedure is created in the specified namespace. Args specifies the formal arguments to the procedure.  It consists of a list, possibly empty, each of whose elements specifies one argument.  Each argument specifier is also a list with either one or two fields.  If there is only a single field in the specifier then it is the name of the argument; if there are two fields, then the first is the argument name and the second is its default value.  Arguments with default values that are followed by non-defaulted arguments become required arguments.  In 8.6 this will be considered an  error.  \n\n When name is invoked a local variable will be created for each of the formal arguments to the procedure; its value will be the value of corresponding argument in the invoking command or the argument\'s default value. Actual arguments are assigned to formal arguments strictly in order. Arguments with default values need not be specified in a procedure invocation.  However, there must be enough actual arguments for all the formal arguments that do not have defaults, and there must not be any extra actual arguments.   Arguments with default values that are followed by non-defaulted arguments become required arguments (in 8.6 it will be considered an  error). There is one special case to permit procedures with variable numbers of arguments.  If the last formal argument has the name args, then a call to the procedure may contain more actual arguments than the procedure has formal arguments.  In this case, all of the actual arguments starting at the one that would be assigned to args are combined into a list (as if the list command had been used); this combined value is assigned to the local variable args. \n\n When body is being executed, variable names normally refer to local variables, which are created automatically when referenced and deleted when the procedure returns.  One local variable is automatically created for each of the procedure\'s arguments. Other variables can only be accessed by invoking one of the global,  variable, upvar or namespace upvar commands. The current namespace when body is executed will be the namespace that the procedure\'s name exists in, which will be the namespace that it was created in unless it has been changed with rename. \n\n The proc command returns an empty string.  When a procedure is invoked, the procedure\'s return value is the value specified in a return command.  If the procedure does not execute an explicit return, then its return value is the value of the last command executed in the procedure\'s body. If an error occurs while executing the procedure body, then the procedure-as-a-whole will return that same error. "));
		docs.put("error", new TCLDoc("error", "Generate an error"," Returns a TCL_ERROR code, which causes command interpretation to be unwound.  Message is a string that is returned to the application to indicate what went wrong. \n\n The -errorinfo return option of an interpreter is used to accumulate a stack trace of what was in progress when an error occurred; as nested commands unwind, the Tcl interpreter adds information to the -errorinfo return option.  If the info argument is present, it is used to initialize the -errorinfo return options and the first increment of unwind information will not be added by the Tcl interpreter.   In other words, the command containing the error command will not appear in the stack trace; in its place will be info. Historically, this feature had been most useful in conjunction with the catch command: if a caught error cannot be handled successfully, info can be used to return a stack trace reflecting the original point of occurrence of the error: \n\n catch {...} errMsg set savedInfo $::errorInfo 	... error $errMsg $savedInfo \n\n When working with Tcl 8.5 or later, the following code should be used instead: \n\n catch {...} errMsg options 	... return -options $options $errMsg \n\n If the code argument is present, then its value is stored in the -errorcode return option.  The -errorcode return option is intended to hold a machine-readable description of the error in cases where such information is available; see the return manual page for information on the proper format for this option\'s value. "));
		docs.put("llength", new TCLDoc("llength", "Count the number of elements in a list"," Treats list as a list and returns a decimal string giving the number of elements in it. "));
		docs.put("puts", new TCLDoc("puts", "Write to a channel"," Writes the characters given by string to the channel given by channelId. \n\n ChannelId must be an identifier for an open channel such as a Tcl standard channel (stdout or stderr), the return value from an invocation of open or socket, or the result of a channel creation command provided by a Tcl extension. The channel must have been opened for output. \n\n If no channelId is specified then it defaults to stdout. Puts normally outputs a newline character after string, but this feature may be suppressed by specifying the -nonewline switch. \n\n Newline characters in the output are translated by puts to platform-specific end-of-line sequences according to the current value of the -translation option for the channel (for example, on PCs newlines are normally replaced with carriage-return-linefeed sequences. See the fconfigure manual entry for a discussion on ways in which fconfigure will alter output. \n\n Tcl buffers output internally, so characters written with puts may not appear immediately on the output file or device;  Tcl will normally delay output until the buffer is full or the channel is closed. You can force output to appear immediately with the flush command. \n\n When the output buffer fills up, the puts command will normally block until all the buffered data has been accepted for output by the operating system. If channelId is in nonblocking mode then the puts command will not block even if the operating system cannot accept the data. Instead, Tcl continues to buffer the data and writes it in the background as fast as the underlying file or device can accept it. The application must use the Tcl event loop for nonblocking output to work;  otherwise Tcl never finds out that the file or device is ready for more output data. It is possible for an arbitrarily large amount of data to be buffered for a channel in nonblocking mode, which could consume a large amount of memory. To avoid wasting memory, nonblocking I/O should normally be used in an event-driven fashion with the fileevent command (do not invoke puts unless you have recently been notified via a file event that the channel is ready for more output data). "));
		docs.put("lmap", new TCLDoc("lmap", "Iterate over all elements in one or more lists and collect results"," The lmap command implements a loop where the loop variable(s) take on values from one or more lists, and the loop returns a list of results collected from each iteration. \n\n In the simplest case there is one loop variable, varname, and one list, list, that is a list of values to assign to varname. The body argument is a Tcl script. For each element of list (in order from first to last), lmap assigns the contents of the element to varname as if the lindex command had been used to extract the element, then calls the Tcl interpreter to execute body. If execution of the body completes normally then the result of the body is appended to an accumulator list. lmap returns the accumulator list. \n\n In the general case there can be more than one value list (e.g., list1 and list2), and each value list can be associated with a list of loop variables (e.g., varlist1 and varlist2). During each iteration of the loop the variables of each varlist are assigned consecutive values from the corresponding list. Values in each list are used in order from first to last, and each value is used exactly once. The total number of loop iterations is large enough to use up all the values from all the value lists. If a value list does not contain enough elements for each of its loop variables in each iteration, empty values are used for the missing elements. \n\n The break and continue statements may be invoked inside body, with the same effect as in the for and foreach commands. In these cases the body does not complete normally and the result is not appended to the accumulator list. "));
		docs.put("pwd", new TCLDoc("pwd", "Return the absolute path of the current working directory"," Returns the absolute path name of the current working directory. "));
	
	}
}